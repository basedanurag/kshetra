{"ast":null,"code":"var _a, _b;\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nexport class ExpirableMap {\n  static {\n    _a = Symbol.iterator, _b = Symbol.toStringTag;\n  }\n  // Internals\n  #inner;\n  #expirationTime;\n  /**\n   * Create a new ExpirableMap.\n   * @param {ExpirableMapOptions<any, any>} options - options for the map.\n   * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n   * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n   */\n  constructor(options = {}) {\n    this[_a] = this.entries.bind(this);\n    this[_b] = 'ExpirableMap';\n    const {\n      source = [],\n      expirationTime = 10 * 60 * 1000\n    } = options;\n    const currentTime = Date.now();\n    this.#inner = new Map([...source].map(([key, value]) => [key, {\n      value,\n      timestamp: currentTime\n    }]));\n    this.#expirationTime = expirationTime;\n  }\n  /**\n   * Prune removes all expired entries.\n   */\n  prune() {\n    const currentTime = Date.now();\n    for (const [key, entry] of this.#inner.entries()) {\n      if (currentTime - entry.timestamp > this.#expirationTime) {\n        this.#inner.delete(key);\n      }\n    }\n    return this;\n  }\n  // Implementing the Map interface\n  /**\n   * Set the value for the given key. Prunes expired entries.\n   * @param key for the entry\n   * @param value of the entry\n   * @returns this\n   */\n  set(key, value) {\n    this.prune();\n    const entry = {\n      value,\n      timestamp: Date.now()\n    };\n    this.#inner.set(key, entry);\n    return this;\n  }\n  /**\n   * Get the value associated with the key, if it exists and has not expired.\n   * @param key K\n   * @returns the value associated with the key, or undefined if the key is not present or has expired.\n   */\n  get(key) {\n    const entry = this.#inner.get(key);\n    if (entry === undefined) {\n      return undefined;\n    }\n    if (Date.now() - entry.timestamp > this.#expirationTime) {\n      this.#inner.delete(key);\n      return undefined;\n    }\n    return entry.value;\n  }\n  /**\n   * Clear all entries.\n   */\n  clear() {\n    this.#inner.clear();\n  }\n  /**\n   * Entries returns the entries of the map, without the expiration time.\n   * @returns an iterator over the entries of the map.\n   */\n  entries() {\n    const iterator = this.#inner.entries();\n    const generator = function* () {\n      for (const [key, value] of iterator) {\n        yield [key, value.value];\n      }\n      return undefined;\n    };\n    return generator();\n  }\n  /**\n   * Values returns the values of the map, without the expiration time.\n   * @returns an iterator over the values of the map.\n   */\n  values() {\n    const iterator = this.#inner.values();\n    const generator = function* () {\n      for (const value of iterator) {\n        yield value.value;\n      }\n      return undefined;\n    };\n    return generator();\n  }\n  /**\n   * Keys returns the keys of the map\n   * @returns an iterator over the keys of the map.\n   */\n  keys() {\n    return this.#inner.keys();\n  }\n  /**\n   * forEach calls the callbackfn on each entry of the map.\n   * @param callbackfn to call on each entry\n   * @param thisArg to use as this when calling the callbackfn\n   */\n  forEach(callbackfn, thisArg) {\n    for (const [key, value] of this.#inner.entries()) {\n      callbackfn.call(thisArg, value.value, key, this);\n    }\n  }\n  /**\n   * has returns true if the key exists and has not expired.\n   * @param key K\n   * @returns true if the key exists and has not expired.\n   */\n  has(key) {\n    return this.#inner.has(key);\n  }\n  /**\n   * delete the entry for the given key.\n   * @param key K\n   * @returns true if the key existed and has been deleted.\n   */\n  delete(key) {\n    return this.#inner.delete(key);\n  }\n  /**\n   * get size of the map.\n   * @returns the size of the map.\n   */\n  get size() {\n    return this.#inner.size;\n  }\n}","map":{"version":3,"names":["ExpirableMap","Symbol","iterator","_b","toStringTag","inner","expirationTime","constructor","options","_a","entries","bind","source","currentTime","Date","now","Map","map","key","value","timestamp","prune","entry","delete","set","get","undefined","clear","generator","values","keys","forEach","callbackfn","thisArg","call","has","size"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\utils\\expirableMap.ts"],"sourcesContent":["export type ExpirableMapOptions<K, V> = {\n  source?: Iterable<[K, V]>;\n  expirationTime?: number;\n};\n\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nexport class ExpirableMap<K, V> implements Map<K, V> {\n  // Internals\n  #inner: Map<K, { value: V; timestamp: number }>;\n  #expirationTime: number;\n\n  [Symbol.iterator]: () => MapIterator<[K, V]> = this.entries.bind(this);\n  [Symbol.toStringTag] = 'ExpirableMap';\n\n  /**\n   * Create a new ExpirableMap.\n   * @param {ExpirableMapOptions<any, any>} options - options for the map.\n   * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n   * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n   */\n  constructor(options: ExpirableMapOptions<K, V> = {}) {\n    const { source = [], expirationTime = 10 * 60 * 1000 } = options;\n    const currentTime = Date.now();\n    this.#inner = new Map(\n      [...source].map(([key, value]) => [key, { value, timestamp: currentTime }]),\n    );\n    this.#expirationTime = expirationTime;\n  }\n\n  /**\n   * Prune removes all expired entries.\n   */\n  prune() {\n    const currentTime = Date.now();\n    for (const [key, entry] of this.#inner.entries()) {\n      if (currentTime - entry.timestamp > this.#expirationTime) {\n        this.#inner.delete(key);\n      }\n    }\n    return this;\n  }\n\n  // Implementing the Map interface\n\n  /**\n   * Set the value for the given key. Prunes expired entries.\n   * @param key for the entry\n   * @param value of the entry\n   * @returns this\n   */\n  set(key: K, value: V) {\n    this.prune();\n    const entry = {\n      value,\n      timestamp: Date.now(),\n    };\n    this.#inner.set(key, entry);\n\n    return this;\n  }\n\n  /**\n   * Get the value associated with the key, if it exists and has not expired.\n   * @param key K\n   * @returns the value associated with the key, or undefined if the key is not present or has expired.\n   */\n  get(key: K) {\n    const entry = this.#inner.get(key);\n    if (entry === undefined) {\n      return undefined;\n    }\n    if (Date.now() - entry.timestamp > this.#expirationTime) {\n      this.#inner.delete(key);\n      return undefined;\n    }\n    return entry.value;\n  }\n\n  /**\n   * Clear all entries.\n   */\n  clear() {\n    this.#inner.clear();\n  }\n\n  /**\n   * Entries returns the entries of the map, without the expiration time.\n   * @returns an iterator over the entries of the map.\n   */\n  entries(): MapIterator<[K, V]> {\n    const iterator = this.#inner.entries();\n    const generator = function* () {\n      for (const [key, value] of iterator) {\n        yield [key, value.value] as [K, V];\n      }\n      return undefined;\n    };\n    return generator();\n  }\n\n  /**\n   * Values returns the values of the map, without the expiration time.\n   * @returns an iterator over the values of the map.\n   */\n  values(): MapIterator<V> {\n    const iterator = this.#inner.values();\n    const generator = function* () {\n      for (const value of iterator) {\n        yield value.value;\n      }\n      return undefined;\n    };\n    return generator();\n  }\n\n  /**\n   * Keys returns the keys of the map\n   * @returns an iterator over the keys of the map.\n   */\n  keys(): MapIterator<K> {\n    return this.#inner.keys();\n  }\n\n  /**\n   * forEach calls the callbackfn on each entry of the map.\n   * @param callbackfn to call on each entry\n   * @param thisArg to use as this when calling the callbackfn\n   */\n  forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: ExpirableMap<K, V>) {\n    for (const [key, value] of this.#inner.entries()) {\n      callbackfn.call(thisArg, value.value, key, this);\n    }\n  }\n\n  /**\n   * has returns true if the key exists and has not expired.\n   * @param key K\n   * @returns true if the key exists and has not expired.\n   */\n  has(key: K): boolean {\n    return this.#inner.has(key);\n  }\n\n  /**\n   * delete the entry for the given key.\n   * @param key K\n   * @returns true if the key existed and has been deleted.\n   */\n  delete(key: K) {\n    return this.#inner.delete(key);\n  }\n\n  /**\n   * get size of the map.\n   * @returns the size of the map.\n   */\n  get size() {\n    return this.#inner.size;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}