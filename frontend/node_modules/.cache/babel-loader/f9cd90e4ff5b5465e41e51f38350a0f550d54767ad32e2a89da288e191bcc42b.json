{"ast":null,"code":"var _a, _b;\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nexport class ExpirableMap {\n  static #_ = (() => (_a = Symbol.iterator, _b = Symbol.toStringTag))(); // Internals\n  #inner;\n  #expirationTime;\n  /**\n   * Create a new ExpirableMap.\n   * @param {ExpirableMapOptions<any, any>} options - options for the map.\n   * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n   * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this[_a] = this.entries.bind(this);\n    this[_b] = 'ExpirableMap';\n    const {\n      source = [],\n      expirationTime = 10 * 60 * 1000\n    } = options;\n    const currentTime = Date.now();\n    this.#inner = new Map([...source].map(_ref => {\n      let [key, value] = _ref;\n      return [key, {\n        value,\n        timestamp: currentTime\n      }];\n    }));\n    this.#expirationTime = expirationTime;\n  }\n  /**\n   * Prune removes all expired entries.\n   */\n  prune() {\n    const currentTime = Date.now();\n    for (const [key, entry] of this.#inner.entries()) {\n      if (currentTime - entry.timestamp > this.#expirationTime) {\n        this.#inner.delete(key);\n      }\n    }\n    return this;\n  }\n  // Implementing the Map interface\n  /**\n   * Set the value for the given key. Prunes expired entries.\n   * @param key for the entry\n   * @param value of the entry\n   * @returns this\n   */\n  set(key, value) {\n    this.prune();\n    const entry = {\n      value,\n      timestamp: Date.now()\n    };\n    this.#inner.set(key, entry);\n    return this;\n  }\n  /**\n   * Get the value associated with the key, if it exists and has not expired.\n   * @param key K\n   * @returns the value associated with the key, or undefined if the key is not present or has expired.\n   */\n  get(key) {\n    const entry = this.#inner.get(key);\n    if (entry === undefined) {\n      return undefined;\n    }\n    if (Date.now() - entry.timestamp > this.#expirationTime) {\n      this.#inner.delete(key);\n      return undefined;\n    }\n    return entry.value;\n  }\n  /**\n   * Clear all entries.\n   */\n  clear() {\n    this.#inner.clear();\n  }\n  /**\n   * Entries returns the entries of the map, without the expiration time.\n   * @returns an iterator over the entries of the map.\n   */\n  entries() {\n    const iterator = this.#inner.entries();\n    const generator = function* () {\n      for (const [key, value] of iterator) {\n        yield [key, value.value];\n      }\n      return undefined;\n    };\n    return generator();\n  }\n  /**\n   * Values returns the values of the map, without the expiration time.\n   * @returns an iterator over the values of the map.\n   */\n  values() {\n    const iterator = this.#inner.values();\n    const generator = function* () {\n      for (const value of iterator) {\n        yield value.value;\n      }\n      return undefined;\n    };\n    return generator();\n  }\n  /**\n   * Keys returns the keys of the map\n   * @returns an iterator over the keys of the map.\n   */\n  keys() {\n    return this.#inner.keys();\n  }\n  /**\n   * forEach calls the callbackfn on each entry of the map.\n   * @param callbackfn to call on each entry\n   * @param thisArg to use as this when calling the callbackfn\n   */\n  forEach(callbackfn, thisArg) {\n    for (const [key, value] of this.#inner.entries()) {\n      callbackfn.call(thisArg, value.value, key, this);\n    }\n  }\n  /**\n   * has returns true if the key exists and has not expired.\n   * @param key K\n   * @returns true if the key exists and has not expired.\n   */\n  has(key) {\n    return this.#inner.has(key);\n  }\n  /**\n   * delete the entry for the given key.\n   * @param key K\n   * @returns true if the key existed and has been deleted.\n   */\n  delete(key) {\n    return this.#inner.delete(key);\n  }\n  /**\n   * get size of the map.\n   * @returns the size of the map.\n   */\n  get size() {\n    return this.#inner.size;\n  }\n}","map":{"version":3,"names":["ExpirableMap","_","Symbol","iterator","_b","toStringTag","inner","expirationTime","constructor","options","arguments","length","undefined","_a","entries","bind","source","currentTime","Date","now","Map","map","_ref","key","value","timestamp","prune","entry","delete","set","get","clear","generator","values","keys","forEach","callbackfn","thisArg","call","has","size"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\utils\\expirableMap.ts"],"sourcesContent":["export type ExpirableMapOptions<K, V> = {\n  source?: Iterable<[K, V]>;\n  expirationTime?: number;\n};\n\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nexport class ExpirableMap<K, V> implements Map<K, V> {\n  // Internals\n  #inner: Map<K, { value: V; timestamp: number }>;\n  #expirationTime: number;\n\n  [Symbol.iterator]: () => MapIterator<[K, V]> = this.entries.bind(this);\n  [Symbol.toStringTag] = 'ExpirableMap';\n\n  /**\n   * Create a new ExpirableMap.\n   * @param {ExpirableMapOptions<any, any>} options - options for the map.\n   * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n   * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n   */\n  constructor(options: ExpirableMapOptions<K, V> = {}) {\n    const { source = [], expirationTime = 10 * 60 * 1000 } = options;\n    const currentTime = Date.now();\n    this.#inner = new Map(\n      [...source].map(([key, value]) => [key, { value, timestamp: currentTime }]),\n    );\n    this.#expirationTime = expirationTime;\n  }\n\n  /**\n   * Prune removes all expired entries.\n   */\n  prune() {\n    const currentTime = Date.now();\n    for (const [key, entry] of this.#inner.entries()) {\n      if (currentTime - entry.timestamp > this.#expirationTime) {\n        this.#inner.delete(key);\n      }\n    }\n    return this;\n  }\n\n  // Implementing the Map interface\n\n  /**\n   * Set the value for the given key. Prunes expired entries.\n   * @param key for the entry\n   * @param value of the entry\n   * @returns this\n   */\n  set(key: K, value: V) {\n    this.prune();\n    const entry = {\n      value,\n      timestamp: Date.now(),\n    };\n    this.#inner.set(key, entry);\n\n    return this;\n  }\n\n  /**\n   * Get the value associated with the key, if it exists and has not expired.\n   * @param key K\n   * @returns the value associated with the key, or undefined if the key is not present or has expired.\n   */\n  get(key: K) {\n    const entry = this.#inner.get(key);\n    if (entry === undefined) {\n      return undefined;\n    }\n    if (Date.now() - entry.timestamp > this.#expirationTime) {\n      this.#inner.delete(key);\n      return undefined;\n    }\n    return entry.value;\n  }\n\n  /**\n   * Clear all entries.\n   */\n  clear() {\n    this.#inner.clear();\n  }\n\n  /**\n   * Entries returns the entries of the map, without the expiration time.\n   * @returns an iterator over the entries of the map.\n   */\n  entries(): MapIterator<[K, V]> {\n    const iterator = this.#inner.entries();\n    const generator = function* () {\n      for (const [key, value] of iterator) {\n        yield [key, value.value] as [K, V];\n      }\n      return undefined;\n    };\n    return generator();\n  }\n\n  /**\n   * Values returns the values of the map, without the expiration time.\n   * @returns an iterator over the values of the map.\n   */\n  values(): MapIterator<V> {\n    const iterator = this.#inner.values();\n    const generator = function* () {\n      for (const value of iterator) {\n        yield value.value;\n      }\n      return undefined;\n    };\n    return generator();\n  }\n\n  /**\n   * Keys returns the keys of the map\n   * @returns an iterator over the keys of the map.\n   */\n  keys(): MapIterator<K> {\n    return this.#inner.keys();\n  }\n\n  /**\n   * forEach calls the callbackfn on each entry of the map.\n   * @param callbackfn to call on each entry\n   * @param thisArg to use as this when calling the callbackfn\n   */\n  forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: ExpirableMap<K, V>) {\n    for (const [key, value] of this.#inner.entries()) {\n      callbackfn.call(thisArg, value.value, key, this);\n    }\n  }\n\n  /**\n   * has returns true if the key exists and has not expired.\n   * @param key K\n   * @returns true if the key exists and has not expired.\n   */\n  has(key: K): boolean {\n    return this.#inner.has(key);\n  }\n\n  /**\n   * delete the entry for the given key.\n   * @param key K\n   * @returns true if the key existed and has been deleted.\n   */\n  delete(key: K) {\n    return this.#inner.delete(key);\n  }\n\n  /**\n   * get size of the map.\n   * @returns the size of the map.\n   */\n  get size() {\n    return this.#inner.size;\n  }\n}\n"],"mappings":";AAKA;;;;AAIA,OAAM,MAAOA,YAAY;EAAA,QAAAC,CAAA,W,KAKtBC,MAAM,CAACC,QAAQ,EAAAC,EAAA,GACfF,MAAM,CAACG,WAAW,MALnB;EACA,CAAAC,KAAM;EACN,CAAAC,cAAe;EAKf;;;;;;EAMAC,YAAA,EAAmD;IAAA,IAAvCC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAqC,EAAE;IATnD,KAAAG,EAAA,CAAiB,GAA8B,IAAI,CAACC,OAAO,CAACC,IAAI,CAAC,IAAI,CAAC;IACtE,KAAAX,EAAA,CAAoB,GAAG,cAAc;IASnC,MAAM;MAAEY,MAAM,GAAG,EAAE;MAAET,cAAc,GAAG,EAAE,GAAG,EAAE,GAAG;IAAI,CAAE,GAAGE,OAAO;IAChE,MAAMQ,WAAW,GAAGC,IAAI,CAACC,GAAG,EAAE;IAC9B,IAAI,CAAC,CAAAb,KAAM,GAAG,IAAIc,GAAG,CACnB,CAAC,GAAGJ,MAAM,CAAC,CAACK,GAAG,CAACC,IAAA;MAAA,IAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,GAAAF,IAAA;MAAA,OAAK,CAACC,GAAG,EAAE;QAAEC,KAAK;QAAEC,SAAS,EAAER;MAAW,CAAE,CAAC;IAAA,EAAC,CAC5E;IACD,IAAI,CAAC,CAAAV,cAAe,GAAGA,cAAc;EACvC;EAEA;;;EAGAmB,KAAKA,CAAA;IACH,MAAMT,WAAW,GAAGC,IAAI,CAACC,GAAG,EAAE;IAC9B,KAAK,MAAM,CAACI,GAAG,EAAEI,KAAK,CAAC,IAAI,IAAI,CAAC,CAAArB,KAAM,CAACQ,OAAO,EAAE,EAAE;MAChD,IAAIG,WAAW,GAAGU,KAAK,CAACF,SAAS,GAAG,IAAI,CAAC,CAAAlB,cAAe,EAAE;QACxD,IAAI,CAAC,CAAAD,KAAM,CAACsB,MAAM,CAACL,GAAG,CAAC;MACzB;IACF;IACA,OAAO,IAAI;EACb;EAEA;EAEA;;;;;;EAMAM,GAAGA,CAACN,GAAM,EAAEC,KAAQ;IAClB,IAAI,CAACE,KAAK,EAAE;IACZ,MAAMC,KAAK,GAAG;MACZH,KAAK;MACLC,SAAS,EAAEP,IAAI,CAACC,GAAG;KACpB;IACD,IAAI,CAAC,CAAAb,KAAM,CAACuB,GAAG,CAACN,GAAG,EAAEI,KAAK,CAAC;IAE3B,OAAO,IAAI;EACb;EAEA;;;;;EAKAG,GAAGA,CAACP,GAAM;IACR,MAAMI,KAAK,GAAG,IAAI,CAAC,CAAArB,KAAM,CAACwB,GAAG,CAACP,GAAG,CAAC;IAClC,IAAII,KAAK,KAAKf,SAAS,EAAE;MACvB,OAAOA,SAAS;IAClB;IACA,IAAIM,IAAI,CAACC,GAAG,EAAE,GAAGQ,KAAK,CAACF,SAAS,GAAG,IAAI,CAAC,CAAAlB,cAAe,EAAE;MACvD,IAAI,CAAC,CAAAD,KAAM,CAACsB,MAAM,CAACL,GAAG,CAAC;MACvB,OAAOX,SAAS;IAClB;IACA,OAAOe,KAAK,CAACH,KAAK;EACpB;EAEA;;;EAGAO,KAAKA,CAAA;IACH,IAAI,CAAC,CAAAzB,KAAM,CAACyB,KAAK,EAAE;EACrB;EAEA;;;;EAIAjB,OAAOA,CAAA;IACL,MAAMX,QAAQ,GAAG,IAAI,CAAC,CAAAG,KAAM,CAACQ,OAAO,EAAE;IACtC,MAAMkB,SAAS,GAAG,UAAAA,CAAA,EAAS;MACzB,KAAK,MAAM,CAACT,GAAG,EAAEC,KAAK,CAAC,IAAIrB,QAAQ,EAAE;QACnC,MAAM,CAACoB,GAAG,EAAEC,KAAK,CAACA,KAAK,CAAW;MACpC;MACA,OAAOZ,SAAS;IAClB,CAAC;IACD,OAAOoB,SAAS,EAAE;EACpB;EAEA;;;;EAIAC,MAAMA,CAAA;IACJ,MAAM9B,QAAQ,GAAG,IAAI,CAAC,CAAAG,KAAM,CAAC2B,MAAM,EAAE;IACrC,MAAMD,SAAS,GAAG,UAAAA,CAAA,EAAS;MACzB,KAAK,MAAMR,KAAK,IAAIrB,QAAQ,EAAE;QAC5B,MAAMqB,KAAK,CAACA,KAAK;MACnB;MACA,OAAOZ,SAAS;IAClB,CAAC;IACD,OAAOoB,SAAS,EAAE;EACpB;EAEA;;;;EAIAE,IAAIA,CAAA;IACF,OAAO,IAAI,CAAC,CAAA5B,KAAM,CAAC4B,IAAI,EAAE;EAC3B;EAEA;;;;;EAKAC,OAAOA,CAACC,UAAsD,EAAEC,OAA4B;IAC1F,KAAK,MAAM,CAACd,GAAG,EAAEC,KAAK,CAAC,IAAI,IAAI,CAAC,CAAAlB,KAAM,CAACQ,OAAO,EAAE,EAAE;MAChDsB,UAAU,CAACE,IAAI,CAACD,OAAO,EAAEb,KAAK,CAACA,KAAK,EAAED,GAAG,EAAE,IAAI,CAAC;IAClD;EACF;EAEA;;;;;EAKAgB,GAAGA,CAAChB,GAAM;IACR,OAAO,IAAI,CAAC,CAAAjB,KAAM,CAACiC,GAAG,CAAChB,GAAG,CAAC;EAC7B;EAEA;;;;;EAKAK,MAAMA,CAACL,GAAM;IACX,OAAO,IAAI,CAAC,CAAAjB,KAAM,CAACsB,MAAM,CAACL,GAAG,CAAC;EAChC;EAEA;;;;EAIA,IAAIiB,IAAIA,CAAA;IACN,OAAO,IAAI,CAAC,CAAAlC,KAAM,CAACkC,IAAI;EACzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}