{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { concat, PipeArrayBuffer as Pipe, uint8ToDataView } from \"./utils/buffer.js\";\nimport { idlLabelToId } from \"./utils/hash.js\";\nimport { lebDecode, lebEncode, readIntLE, readUIntLE, safeRead, safeReadUint8, slebDecode, slebEncode, writeIntLE, writeUIntLE } from \"./utils/leb128.js\";\nimport { iexp2 } from \"./utils/bigint-math.js\";\n/**\n * This module provides a combinator library to create serializers/deserializers\n * between JavaScript values and IDL used by canisters on the Internet Computer,\n * as documented at https://github.com/dfinity/candid/blob/119703ba342d2fef6ab4972d2541b9fe36ae8e36/spec/Candid.md\n */\nvar IDLTypeIds;\n(function (IDLTypeIds) {\n  IDLTypeIds[IDLTypeIds[\"Null\"] = -1] = \"Null\";\n  IDLTypeIds[IDLTypeIds[\"Bool\"] = -2] = \"Bool\";\n  IDLTypeIds[IDLTypeIds[\"Nat\"] = -3] = \"Nat\";\n  IDLTypeIds[IDLTypeIds[\"Int\"] = -4] = \"Int\";\n  IDLTypeIds[IDLTypeIds[\"Float32\"] = -13] = \"Float32\";\n  IDLTypeIds[IDLTypeIds[\"Float64\"] = -14] = \"Float64\";\n  IDLTypeIds[IDLTypeIds[\"Text\"] = -15] = \"Text\";\n  IDLTypeIds[IDLTypeIds[\"Reserved\"] = -16] = \"Reserved\";\n  IDLTypeIds[IDLTypeIds[\"Empty\"] = -17] = \"Empty\";\n  IDLTypeIds[IDLTypeIds[\"Opt\"] = -18] = \"Opt\";\n  IDLTypeIds[IDLTypeIds[\"Vector\"] = -19] = \"Vector\";\n  IDLTypeIds[IDLTypeIds[\"Record\"] = -20] = \"Record\";\n  IDLTypeIds[IDLTypeIds[\"Variant\"] = -21] = \"Variant\";\n  IDLTypeIds[IDLTypeIds[\"Func\"] = -22] = \"Func\";\n  IDLTypeIds[IDLTypeIds[\"Service\"] = -23] = \"Service\";\n  IDLTypeIds[IDLTypeIds[\"Principal\"] = -24] = \"Principal\";\n})(IDLTypeIds || (IDLTypeIds = {}));\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\nfunction zipWith(xs, ys, f) {\n  return xs.map((x, i) => f(x, ys[i]));\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n  constructor() {\n    // List of types. Needs to be an array as the index needs to be stable.\n    this._typs = [];\n    this._idx = new Map();\n  }\n  has(obj) {\n    return this._idx.has(obj.name);\n  }\n  add(type, buf) {\n    const idx = this._typs.length;\n    this._idx.set(type.name, idx);\n    this._typs.push(buf);\n  }\n  merge(obj, knot) {\n    const idx = this._idx.get(obj.name);\n    const knotIdx = this._idx.get(knot);\n    if (idx === undefined) {\n      throw new Error('Missing type index for ' + obj);\n    }\n    if (knotIdx === undefined) {\n      throw new Error('Missing type index for ' + knot);\n    }\n    this._typs[idx] = this._typs[knotIdx];\n    // Delete the type.\n    this._typs.splice(knotIdx, 1);\n    this._idx.delete(knot);\n  }\n  encode() {\n    const len = lebEncode(this._typs.length);\n    const buf = concat(...this._typs);\n    return concat(len, buf);\n  }\n  indexOf(typeName) {\n    if (!this._idx.has(typeName)) {\n      throw new Error('Missing type index for ' + typeName);\n    }\n    return slebEncode(this._idx.get(typeName) || 0);\n  }\n}\nexport class Visitor {\n  visitType(_t, _data) {\n    throw new Error('Not implemented');\n  }\n  visitPrimitive(t, data) {\n    return this.visitType(t, data);\n  }\n  visitEmpty(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitBool(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitNull(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitReserved(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitText(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitNumber(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitInt(t, data) {\n    return this.visitNumber(t, data);\n  }\n  visitNat(t, data) {\n    return this.visitNumber(t, data);\n  }\n  visitFloat(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitFixedInt(t, data) {\n    return this.visitNumber(t, data);\n  }\n  visitFixedNat(t, data) {\n    return this.visitNumber(t, data);\n  }\n  visitPrincipal(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitConstruct(t, data) {\n    return this.visitType(t, data);\n  }\n  visitVec(t, _ty, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitOpt(t, _ty, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitRecord(t, _fields, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitTuple(t, components, data) {\n    const fields = components.map((ty, i) => [`_${i}_`, ty]);\n    return this.visitRecord(t, fields, data);\n  }\n  visitVariant(t, _fields, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitRec(_t, ty, data) {\n    return this.visitConstruct(ty, data);\n  }\n  visitFunc(t, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitService(t, data) {\n    return this.visitConstruct(t, data);\n  }\n}\n// We try to use hard-to-accidentally-pick names to avoid potential collisions with other types.\nvar IdlTypeName;\n(function (IdlTypeName) {\n  IdlTypeName[\"EmptyClass\"] = \"__IDL_EmptyClass__\";\n  IdlTypeName[\"UnknownClass\"] = \"__IDL_UnknownClass__\";\n  IdlTypeName[\"BoolClass\"] = \"__IDL_BoolClass__\";\n  IdlTypeName[\"NullClass\"] = \"__IDL_NullClass__\";\n  IdlTypeName[\"ReservedClass\"] = \"__IDL_ReservedClass__\";\n  IdlTypeName[\"TextClass\"] = \"__IDL_TextClass__\";\n  IdlTypeName[\"IntClass\"] = \"__IDL_IntClass__\";\n  IdlTypeName[\"NatClass\"] = \"__IDL_NatClass__\";\n  IdlTypeName[\"FloatClass\"] = \"__IDL_FloatClass__\";\n  IdlTypeName[\"FixedIntClass\"] = \"__IDL_FixedIntClass__\";\n  IdlTypeName[\"FixedNatClass\"] = \"__IDL_FixedNatClass__\";\n  IdlTypeName[\"VecClass\"] = \"__IDL_VecClass__\";\n  IdlTypeName[\"OptClass\"] = \"__IDL_OptClass__\";\n  IdlTypeName[\"RecordClass\"] = \"__IDL_RecordClass__\";\n  IdlTypeName[\"TupleClass\"] = \"__IDL_TupleClass__\";\n  IdlTypeName[\"VariantClass\"] = \"__IDL_VariantClass__\";\n  IdlTypeName[\"RecClass\"] = \"__IDL_RecClass__\";\n  IdlTypeName[\"PrincipalClass\"] = \"__IDL_PrincipalClass__\";\n  IdlTypeName[\"FuncClass\"] = \"__IDL_FuncClass__\";\n  IdlTypeName[\"ServiceClass\"] = \"__IDL_ServiceClass__\";\n})(IdlTypeName || (IdlTypeName = {}));\n/**\n * Represents an IDL type.\n */\nexport class Type {\n  /* Display type name */\n  display() {\n    return this.name;\n  }\n  valueToString(x) {\n    return toReadableString(x);\n  }\n  /* Implement `T` in the IDL spec, only needed for non-primitive types */\n  buildTypeTable(typeTable) {\n    if (!typeTable.has(this)) {\n      this._buildTypeTableImpl(typeTable);\n    }\n  }\n}\nexport class PrimitiveType extends Type {\n  checkType(t) {\n    if (this.name !== t.name) {\n      throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    return t;\n  }\n  _buildTypeTableImpl(_typeTable) {\n    // No type table encoding for Primitive types.\n    return;\n  }\n}\nexport class ConstructType extends Type {\n  checkType(t) {\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      }\n      return ty;\n    }\n    throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n  }\n  encodeType(typeTable) {\n    return typeTable.indexOf(this.name);\n  }\n}\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.EmptyClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.EmptyClass;\n  }\n  accept(v, d) {\n    return v.visitEmpty(this, d);\n  }\n  covariant(x) {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue() {\n    throw new Error('Empty cannot appear as a function argument');\n  }\n  valueToString() {\n    throw new Error('Empty cannot appear as a value');\n  }\n  encodeType() {\n    return slebEncode(IDLTypeIds.Empty);\n  }\n  decodeValue() {\n    throw new Error('Empty cannot appear as an output');\n  }\n  get name() {\n    return 'empty';\n  }\n}\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nexport class UnknownClass extends Type {\n  get typeName() {\n    return IdlTypeName.UnknownClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.UnknownClass;\n  }\n  checkType(_t) {\n    throw new Error('Method not implemented for unknown.');\n  }\n  accept(v, d) {\n    throw v.visitType(this, d);\n  }\n  covariant(x) {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue() {\n    throw new Error('Unknown cannot appear as a function argument');\n  }\n  valueToString() {\n    throw new Error('Unknown cannot appear as a value');\n  }\n  encodeType() {\n    throw new Error('Unknown cannot be serialized');\n  }\n  decodeValue(b, t) {\n    let decodedValue = t.decodeValue(b, t);\n    if (Object(decodedValue) !== decodedValue) {\n      // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n      // The type() function is important for primitives because otherwise we cannot tell apart the\n      // different number types.\n      decodedValue = Object(decodedValue);\n    }\n    let typeFunc;\n    if (t instanceof RecClass) {\n      typeFunc = () => t.getType();\n    } else {\n      typeFunc = () => t;\n    }\n    // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n    // 'type' which means it would be serialized if the value would be candid encoded again.\n    // This in turn leads to problems if the decoded value is a variant because these values are\n    // only allowed to have a single property.\n    Object.defineProperty(decodedValue, 'type', {\n      value: typeFunc,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n    return decodedValue;\n  }\n  _buildTypeTableImpl() {\n    throw new Error('Unknown cannot be serialized');\n  }\n  get name() {\n    return 'Unknown';\n  }\n}\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.BoolClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.BoolClass;\n  }\n  accept(v, d) {\n    return v.visitBool(this, d);\n  }\n  covariant(x) {\n    if (typeof x === 'boolean') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return new Uint8Array([x ? 1 : 0]);\n  }\n  encodeType() {\n    return slebEncode(IDLTypeIds.Bool);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    switch (safeReadUint8(b)) {\n      case 0:\n        return false;\n      case 1:\n        return true;\n      default:\n        throw new Error('Boolean value out of range');\n    }\n  }\n  get name() {\n    return 'bool';\n  }\n}\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.NullClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.NullClass;\n  }\n  accept(v, d) {\n    return v.visitNull(this, d);\n  }\n  covariant(x) {\n    if (x === null) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue() {\n    return new Uint8Array(0);\n  }\n  encodeType() {\n    return slebEncode(IDLTypeIds.Null);\n  }\n  decodeValue(_b, t) {\n    this.checkType(t);\n    return null;\n  }\n  get name() {\n    return 'null';\n  }\n}\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.ReservedClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.ReservedClass;\n  }\n  accept(v, d) {\n    return v.visitReserved(this, d);\n  }\n  covariant(_x) {\n    return true;\n  }\n  encodeValue() {\n    return new Uint8Array(0);\n  }\n  encodeType() {\n    return slebEncode(IDLTypeIds.Reserved);\n  }\n  decodeValue(b, t) {\n    if (t.name !== this.name) {\n      t.decodeValue(b, t);\n    }\n    return null;\n  }\n  get name() {\n    return 'reserved';\n  }\n}\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.TextClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.TextClass;\n  }\n  accept(v, d) {\n    return v.visitText(this, d);\n  }\n  covariant(x) {\n    if (typeof x === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const buf = new TextEncoder().encode(x);\n    const len = lebEncode(buf.byteLength);\n    return concat(len, buf);\n  }\n  encodeType() {\n    return slebEncode(IDLTypeIds.Text);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    const len = lebDecode(b);\n    const buf = safeRead(b, Number(len));\n    const decoder = new TextDecoder('utf8', {\n      fatal: true\n    });\n    return decoder.decode(buf);\n  }\n  get name() {\n    return 'text';\n  }\n  valueToString(x) {\n    return '\"' + x + '\"';\n  }\n}\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.IntClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.IntClass;\n  }\n  accept(v, d) {\n    return v.visitInt(this, d);\n  }\n  covariant(x) {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' || Number.isInteger(x)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return slebEncode(x);\n  }\n  encodeType() {\n    return slebEncode(IDLTypeIds.Int);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    return slebDecode(b);\n  }\n  get name() {\n    return 'int';\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.NatClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.NatClass;\n  }\n  accept(v, d) {\n    return v.visitNat(this, d);\n  }\n  covariant(x) {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' && x >= BigInt(0) || Number.isInteger(x) && x >= 0) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return lebEncode(x);\n  }\n  encodeType() {\n    return slebEncode(IDLTypeIds.Nat);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    return lebDecode(b);\n  }\n  get name() {\n    return 'nat';\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.FloatClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.FloatClass;\n  }\n  constructor(_bits) {\n    super();\n    this._bits = _bits;\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n  }\n  accept(v, d) {\n    return v.visitFloat(this, d);\n  }\n  covariant(x) {\n    if (typeof x === 'number' || x instanceof Number) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const buf = new ArrayBuffer(this._bits / 8);\n    const view = new DataView(buf);\n    if (this._bits === 32) {\n      view.setFloat32(0, x, true);\n    } else {\n      view.setFloat64(0, x, true);\n    }\n    return new Uint8Array(buf);\n  }\n  encodeType() {\n    const opcode = this._bits === 32 ? IDLTypeIds.Float32 : IDLTypeIds.Float64;\n    return slebEncode(opcode);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    const bytes = safeRead(b, this._bits / 8);\n    const view = uint8ToDataView(bytes);\n    if (this._bits === 32) {\n      return view.getFloat32(0, true);\n    } else {\n      return view.getFloat64(0, true);\n    }\n  }\n  get name() {\n    return 'float' + this._bits;\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.FixedIntClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.FixedIntClass;\n  }\n  constructor(_bits) {\n    super();\n    this._bits = _bits;\n  }\n  accept(v, d) {\n    return v.visitFixedInt(this, d);\n  }\n  covariant(x) {\n    const min = iexp2(this._bits - 1) * BigInt(-1);\n    const max = iexp2(this._bits - 1) - BigInt(1);\n    let ok = false;\n    if (typeof x === 'bigint') {\n      ok = x >= min && x <= max;\n    } else if (Number.isInteger(x)) {\n      const v = BigInt(x);\n      ok = v >= min && v <= max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return writeIntLE(x, this._bits / 8);\n  }\n  encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-9 - offset);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    const num = readIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n  get name() {\n    return `int${this._bits}`;\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.FixedNatClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.FixedNatClass;\n  }\n  constructor(_bits) {\n    super();\n    this._bits = _bits;\n  }\n  accept(v, d) {\n    return v.visitFixedNat(this, d);\n  }\n  covariant(x) {\n    const max = iexp2(this._bits);\n    let ok = false;\n    if (typeof x === 'bigint' && x >= BigInt(0)) {\n      ok = x < max;\n    } else if (Number.isInteger(x) && x >= 0) {\n      const v = BigInt(x);\n      ok = v < max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return writeUIntLE(x, this._bits / 8);\n  }\n  encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-5 - offset);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    const num = readUIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n  get name() {\n    return `nat${this._bits}`;\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nexport class VecClass extends ConstructType {\n  get typeName() {\n    return IdlTypeName.VecClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.VecClass;\n  }\n  constructor(_type) {\n    super();\n    this._type = _type;\n    // If true, this vector is really a blob and we can just use memcpy.\n    //\n    // NOTE:\n    // With support of encoding/dencoding of TypedArrays, this optimization is\n    // only used when plain array of bytes are passed as encoding input in order\n    // to be backward compatible.\n    this._blobOptimization = false;\n    if (_type instanceof FixedNatClass && _type._bits === 8) {\n      this._blobOptimization = true;\n    }\n  }\n  accept(v, d) {\n    return v.visitVec(this, this._type, d);\n  }\n  covariant(x) {\n    // Special case for ArrayBuffer\n    const bits = this._type instanceof FixedNatClass ? this._type._bits : this._type instanceof FixedIntClass ? this._type._bits : 0;\n    if (ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8 || Array.isArray(x) && x.every((v, idx) => {\n      try {\n        return this._type.covariant(v);\n      } catch (e) {\n        throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n      }\n    })) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const len = lebEncode(x.length);\n    if (this._blobOptimization) {\n      return concat(len, new Uint8Array(x));\n    }\n    if (ArrayBuffer.isView(x)) {\n      // Handle TypedArrays with endianness concerns\n      if (x instanceof Int16Array || x instanceof Uint16Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 2));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int16Array) {\n            buffer.setInt16(i * 2, x[i], true); // true = little-endian\n          } else {\n            buffer.setUint16(i * 2, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof Int32Array || x instanceof Uint32Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 4));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int32Array) {\n            buffer.setInt32(i * 4, x[i], true);\n          } else {\n            buffer.setUint32(i * 4, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof BigInt64Array || x instanceof BigUint64Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 8));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof BigInt64Array) {\n            buffer.setBigInt64(i * 8, x[i], true);\n          } else {\n            buffer.setBigUint64(i * 8, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else {\n        // For Uint8Array, Int8Array, etc. that don't have endianness concerns\n        return concat(len, new Uint8Array(x.buffer, x.byteOffset, x.byteLength));\n      }\n    }\n    const buf = new Pipe(new Uint8Array(len.byteLength + x.length), 0);\n    buf.write(len);\n    for (const d of x) {\n      const encoded = this._type.encodeValue(d);\n      buf.write(new Uint8Array(encoded));\n    }\n    return buf.buffer;\n  }\n  _buildTypeTableImpl(typeTable) {\n    this._type.buildTypeTable(typeTable);\n    const opCode = slebEncode(IDLTypeIds.Vector);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n  decodeValue(b, t) {\n    const vec = this.checkType(t);\n    if (!(vec instanceof VecClass)) {\n      throw new Error('Not a vector type');\n    }\n    const len = Number(lebDecode(b));\n    if (this._type instanceof FixedNatClass) {\n      if (this._type._bits == 8) {\n        return new Uint8Array(b.read(len));\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Check if we need to swap bytes for endianness\n        const u16 = new Uint16Array(bytes.buffer, bytes.byteOffset, len);\n        return u16;\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const u32 = new Uint32Array(bytes.buffer, bytes.byteOffset, len);\n        return u32;\n      }\n      if (this._type._bits == 64) {\n        return new BigUint64Array(b.read(len * 8).buffer);\n      }\n    }\n    if (this._type instanceof FixedIntClass) {\n      if (this._type._bits == 8) {\n        return new Int8Array(b.read(len));\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Create a DataView to properly handle endianness\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n        // Create result array with correct endianness\n        const result = new Int16Array(len);\n        for (let i = 0; i < len; i++) {\n          // Read each value as little-endian (Candid wire format is little-endian)\n          result[i] = view.getInt16(i * 2, true);\n        }\n        return result;\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n        const result = new Int32Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getInt32(i * 4, true);\n        }\n        return result;\n      }\n      if (this._type._bits == 64) {\n        const bytes = b.read(len * 8);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n        const result = new BigInt64Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getBigInt64(i * 8, true);\n        }\n        return result;\n      }\n    }\n    const rets = [];\n    for (let i = 0; i < len; i++) {\n      rets.push(this._type.decodeValue(b, vec._type));\n    }\n    return rets;\n  }\n  get name() {\n    return `vec ${this._type.name}`;\n  }\n  display() {\n    return `vec ${this._type.display()}`;\n  }\n  valueToString(x) {\n    const elements = x.map(e => this._type.valueToString(e));\n    return 'vec {' + elements.join('; ') + '}';\n  }\n}\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass extends ConstructType {\n  get typeName() {\n    return IdlTypeName.OptClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.OptClass;\n  }\n  constructor(_type) {\n    super();\n    this._type = _type;\n  }\n  accept(v, d) {\n    return v.visitOpt(this, this._type, d);\n  }\n  covariant(x) {\n    try {\n      if (Array.isArray(x) && (x.length === 0 || x.length === 1 && this._type.covariant(x[0]))) return true;\n    } catch (e) {\n      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`);\n    }\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    if (x.length === 0) {\n      return new Uint8Array([0]);\n    } else {\n      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n    }\n  }\n  _buildTypeTableImpl(typeTable) {\n    this._type.buildTypeTable(typeTable);\n    const opCode = slebEncode(IDLTypeIds.Opt);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n  decodeValue(b, t) {\n    if (t instanceof NullClass) {\n      return [];\n    }\n    if (t instanceof ReservedClass) {\n      return [];\n    }\n    let wireType = t;\n    // unfold wireType, if needed\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      } else wireType = ty;\n    }\n    if (wireType instanceof OptClass) {\n      switch (safeReadUint8(b)) {\n        case 0:\n          return [];\n        case 1:\n          {\n            // Save the current state of the Pipe `b` to allow rollback in case of an error\n            const checkpoint = b.save();\n            try {\n              // Attempt to decode a value using the `_type` of the current instance\n              const v = this._type.decodeValue(b, wireType._type);\n              return [v];\n            } catch (e) {\n              // If an error occurs during decoding, restore the Pipe `b` to its previous state\n              b.restore(checkpoint);\n              // Skip the value at the current wire type to advance the Pipe `b` position\n              wireType._type.decodeValue(b, wireType._type);\n              // Return an empty array to indicate a `none` value\n              return [];\n            }\n          }\n        default:\n          throw new Error('Not an option value');\n      }\n    } else if (\n    // this check corresponds to `not (null <: <t>)` in the spec\n    this._type instanceof NullClass || this._type instanceof OptClass || this._type instanceof ReservedClass) {\n      // null <: <t> :\n      // skip value at wire type (to advance b) and return \"null\", i.e. []\n      wireType.decodeValue(b, wireType);\n      return [];\n    } else {\n      // not (null <: t) :\n      // try constituent type\n      const checkpoint = b.save();\n      try {\n        const v = this._type.decodeValue(b, t);\n        return [v];\n      } catch (e) {\n        // decoding failed, but this is opt, so return \"null\", i.e. []\n        b.restore(checkpoint);\n        // skip value at wire type (to advance b)\n        wireType.decodeValue(b, t);\n        // return \"null\"\n        return [];\n      }\n    }\n  }\n  get name() {\n    return `opt ${this._type.name}`;\n  }\n  display() {\n    return `opt ${this._type.display()}`;\n  }\n  valueToString(x) {\n    if (x.length === 0) {\n      return 'null';\n    } else {\n      return `opt ${this._type.valueToString(x[0])}`;\n    }\n  }\n}\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType {\n  get typeName() {\n    return IdlTypeName.RecordClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    // TupleClass extends RecordClass, so we need to check both here\n    return instance.typeName === IdlTypeName.RecordClass || instance.typeName === IdlTypeName.TupleClass;\n  }\n  constructor(fields = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n  accept(v, d) {\n    return v.visitRecord(this, this._fields, d);\n  }\n  tryAsTuple() {\n    const res = [];\n    for (let i = 0; i < this._fields.length; i++) {\n      const [key, type] = this._fields[i];\n      if (key !== `_${i}_`) {\n        return null;\n      }\n      res.push(type);\n    }\n    return res;\n  }\n  covariant(x) {\n    if (typeof x === 'object' && this._fields.every(([k, t]) => {\n      // eslint-disable-next-line\n      if (!x.hasOwnProperty(k)) {\n        throw new Error(`Record is missing key \"${k}\".`);\n      }\n      try {\n        return t.covariant(x[k]);\n      } catch (e) {\n        throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n      }\n    })) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const values = this._fields.map(([key]) => x[key]);\n    const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n  _buildTypeTableImpl(T) {\n    this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Record);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(T)));\n    T.add(this, concat(opCode, len, concat(...fields)));\n  }\n  decodeValue(b, t) {\n    const record = this.checkType(t);\n    if (!(record instanceof RecordClass)) {\n      throw new Error('Not a record type');\n    }\n    const x = {};\n    let expectedRecordIdx = 0;\n    let actualRecordIdx = 0;\n    while (actualRecordIdx < record._fields.length) {\n      const [hash, type] = record._fields[actualRecordIdx];\n      if (expectedRecordIdx >= this._fields.length) {\n        // skip unexpected left over fields present on the wire\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n        continue;\n      }\n      const [expectKey, expectType] = this._fields[expectedRecordIdx];\n      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);\n      const actualId = idlLabelToId(hash);\n      if (expectedId === actualId) {\n        // the current field on the wire matches the expected field\n        x[expectKey] = expectType.decodeValue(b, type);\n        expectedRecordIdx++;\n        actualRecordIdx++;\n      } else if (actualId > expectedId) {\n        // The expected field does not exist on the wire\n        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n          x[expectKey] = [];\n          expectedRecordIdx++;\n        } else {\n          throw new Error('Cannot find required field ' + expectKey);\n        }\n      } else {\n        // The field on the wire does not exist in the output type, so we can skip it\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n      }\n    }\n    // initialize left over expected optional fields\n    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n        // TODO this assumes null value in opt is represented as []\n        x[expectKey] = [];\n      } else {\n        throw new Error('Cannot find required field ' + expectKey);\n      }\n    }\n    return x;\n  }\n  get fieldsAsObject() {\n    const fields = {};\n    for (const [name, ty] of this._fields) {\n      fields[idlLabelToId(name)] = ty;\n    }\n    return fields;\n  }\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `record {${fields.join('; ')}}`;\n  }\n  display() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n  valueToString(x) {\n    const values = this._fields.map(([key]) => x[key]);\n    const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass extends RecordClass {\n  get typeName() {\n    return IdlTypeName.TupleClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.TupleClass;\n  }\n  constructor(_components) {\n    const x = {};\n    _components.forEach((e, i) => x['_' + i + '_'] = e);\n    super(x);\n    this._components = _components;\n  }\n  accept(v, d) {\n    return v.visitTuple(this, this._components, d);\n  }\n  covariant(x) {\n    // `>=` because tuples can be covariant when encoded.\n    if (Array.isArray(x) && x.length >= this._fields.length && this._components.every((t, i) => {\n      try {\n        return t.covariant(x[i]);\n      } catch (e) {\n        throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n      }\n    })) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n  decodeValue(b, t) {\n    const tuple = this.checkType(t);\n    if (!(tuple instanceof TupleClass)) {\n      throw new Error('not a tuple type');\n    }\n    if (tuple._components.length < this._components.length) {\n      throw new Error('tuple mismatch');\n    }\n    const res = [];\n    for (const [i, wireType] of tuple._components.entries()) {\n      if (i >= this._components.length) {\n        // skip value\n        wireType.decodeValue(b, wireType);\n      } else {\n        res.push(this._components[i].decodeValue(b, wireType));\n      }\n    }\n    return res;\n  }\n  display() {\n    const fields = this._components.map(value => value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n  valueToString(values) {\n    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType {\n  get typeName() {\n    return IdlTypeName.VariantClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.VariantClass;\n  }\n  constructor(fields = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n  accept(v, d) {\n    return v.visitVariant(this, this._fields, d);\n  }\n  covariant(x) {\n    if (typeof x === 'object' && Object.entries(x).length === 1 && this._fields.every(([k, v]) => {\n      try {\n        // eslint-disable-next-line\n        return !x.hasOwnProperty(k) || v.covariant(x[k]);\n      } catch (e) {\n        throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n      }\n    })) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    for (let i = 0; i < this._fields.length; i++) {\n      const [name, type] = this._fields[i];\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const idx = lebEncode(i);\n        const buf = type.encodeValue(x[name]);\n        return concat(idx, buf);\n      }\n    }\n    throw Error('Variant has no data: ' + x);\n  }\n  _buildTypeTableImpl(typeTable) {\n    this._fields.forEach(([, type]) => {\n      type.buildTypeTable(typeTable);\n    });\n    const opCode = slebEncode(IDLTypeIds.Variant);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)));\n    typeTable.add(this, concat(opCode, len, ...fields));\n  }\n  decodeValue(b, t) {\n    const variant = this.checkType(t);\n    if (!(variant instanceof VariantClass)) {\n      throw new Error('Not a variant type');\n    }\n    const idx = Number(lebDecode(b));\n    if (idx >= variant._fields.length) {\n      throw Error('Invalid variant index: ' + idx);\n    }\n    const [wireHash, wireType] = variant._fields[idx];\n    for (const [key, expectType] of this._fields) {\n      if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n        const value = expectType.decodeValue(b, wireType);\n        return {\n          [key]: value\n        };\n      }\n    }\n    throw new Error('Cannot find field hash ' + wireHash);\n  }\n  get name() {\n    const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n    return `variant {${fields.join('; ')}}`;\n  }\n  display() {\n    const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));\n    return `variant {${fields.join('; ')}}`;\n  }\n  valueToString(x) {\n    for (const [name, type] of this._fields) {\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const value = type.valueToString(x[name]);\n        if (value === 'null') {\n          return `variant {${name}}`;\n        } else {\n          return `variant {${name}=${value}}`;\n        }\n      }\n    }\n    throw new Error('Variant has no data: ' + x);\n  }\n  get alternativesAsObject() {\n    const alternatives = {};\n    for (const [name, ty] of this._fields) {\n      alternatives[idlLabelToId(name)] = ty;\n    }\n    return alternatives;\n  }\n}\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass extends ConstructType {\n  constructor() {\n    super(...arguments);\n    this._id = RecClass._counter++;\n  }\n  get typeName() {\n    return IdlTypeName.RecClass;\n  }\n  static {\n    this._counter = 0;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.RecClass;\n  }\n  accept(v, d) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return v.visitRec(this, this._type, d);\n  }\n  fill(t) {\n    this._type = t;\n  }\n  getType() {\n    return this._type;\n  }\n  covariant(x) {\n    if (this._type ? this._type.covariant(x) : false) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.encodeValue(x);\n  }\n  _buildTypeTableImpl(typeTable) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    typeTable.add(this, new Uint8Array([]));\n    this._type.buildTypeTable(typeTable);\n    typeTable.merge(this, this._type.name);\n  }\n  decodeValue(b, t) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.decodeValue(b, t);\n  }\n  get name() {\n    return `rec_${this._id}`;\n  }\n  display() {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return `μ${this.name}.${this._type.name}`;\n  }\n  valueToString(x) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.valueToString(x);\n  }\n}\nfunction decodePrincipalId(b) {\n  const x = safeReadUint8(b);\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n  const len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType {\n  get typeName() {\n    return IdlTypeName.PrincipalClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.PrincipalClass;\n  }\n  accept(v, d) {\n    return v.visitPrincipal(this, d);\n  }\n  covariant(x) {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n  encodeType() {\n    return slebEncode(IDLTypeIds.Principal);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    return decodePrincipalId(b);\n  }\n  get name() {\n    return 'principal';\n  }\n  valueToString(x) {\n    return `${this.name} \"${x.toText()}\"`;\n  }\n}\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass extends ConstructType {\n  get typeName() {\n    return IdlTypeName.FuncClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.FuncClass;\n  }\n  static argsToString(types, v) {\n    if (types.length !== v.length) {\n      throw new Error('arity mismatch');\n    }\n    return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n  }\n  constructor(argTypes, retTypes, annotations = []) {\n    super();\n    this.argTypes = argTypes;\n    this.retTypes = retTypes;\n    this.annotations = annotations;\n  }\n  accept(v, d) {\n    return v.visitFunc(this, d);\n  }\n  covariant(x) {\n    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue([principal, methodName]) {\n    const buf = principal.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    const canister = concat(new Uint8Array([1]), len, buf);\n    const method = new TextEncoder().encode(methodName);\n    const methodLen = lebEncode(method.byteLength);\n    return concat(new Uint8Array([1]), canister, methodLen, method);\n  }\n  _buildTypeTableImpl(T) {\n    this.argTypes.forEach(arg => arg.buildTypeTable(T));\n    this.retTypes.forEach(arg => arg.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Func);\n    const argLen = lebEncode(this.argTypes.length);\n    const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n    const retLen = lebEncode(this.retTypes.length);\n    const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n    const annLen = lebEncode(this.annotations.length);\n    const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n  }\n  decodeValue(b, t) {\n    const tt = t instanceof RecClass ? t.getType() ?? t : t;\n    if (!subtype(tt, this)) {\n      throw new Error(`Cannot decode function reference at type ${this.display()} from wire type ${tt.display()}`);\n    }\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n      throw new Error('Cannot decode function reference');\n    }\n    const canister = decodePrincipalId(b);\n    const mLen = Number(lebDecode(b));\n    const buf = safeRead(b, mLen);\n    const decoder = new TextDecoder('utf8', {\n      fatal: true\n    });\n    const method = decoder.decode(buf);\n    return [canister, method];\n  }\n  get name() {\n    const args = this.argTypes.map(arg => arg.name).join(', ');\n    const rets = this.retTypes.map(arg => arg.name).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) -> (${rets})${annon}`;\n  }\n  valueToString([principal, str]) {\n    return `func \"${principal.toText()}\".${str}`;\n  }\n  display() {\n    const args = this.argTypes.map(arg => arg.display()).join(', ');\n    const rets = this.retTypes.map(arg => arg.display()).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) → (${rets})${annon}`;\n  }\n  encodeAnnotation(ann) {\n    if (ann === 'query') {\n      return new Uint8Array([1]);\n    } else if (ann === 'oneway') {\n      return new Uint8Array([2]);\n    } else if (ann === 'composite_query') {\n      return new Uint8Array([3]);\n    } else {\n      throw new Error('Illegal function annotation');\n    }\n  }\n}\nexport class ServiceClass extends ConstructType {\n  get typeName() {\n    return IdlTypeName.ServiceClass;\n  }\n  static [Symbol.hasInstance](instance) {\n    return instance.typeName === IdlTypeName.ServiceClass;\n  }\n  constructor(fields) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => {\n      if (a[0] < b[0]) {\n        return -1;\n      }\n      if (a[0] > b[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  accept(v, d) {\n    return v.visitService(this, d);\n  }\n  covariant(x) {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.length);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n  _buildTypeTableImpl(T) {\n    this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Service);\n    const len = lebEncode(this._fields.length);\n    const meths = this._fields.map(([label, func]) => {\n      const labelBuf = new TextEncoder().encode(label);\n      const labelLen = lebEncode(labelBuf.length);\n      return concat(labelLen, labelBuf, func.encodeType(T));\n    });\n    T.add(this, concat(opCode, len, ...meths));\n  }\n  decodeValue(b, t) {\n    const tt = t instanceof RecClass ? t.getType() ?? t : t;\n    if (!subtype(tt, this)) {\n      throw new Error(`Cannot decode service reference at type ${this.display()} from wire type ${tt.display()}`);\n    }\n    return decodePrincipalId(b);\n  }\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `service {${fields.join('; ')}}`;\n  }\n  valueToString(x) {\n    return `service \"${x.toText()}\"`;\n  }\n  fieldsAsObject() {\n    const fields = {};\n    for (const [name, ty] of this._fields) {\n      fields[name] = ty;\n    }\n    return fields;\n  }\n}\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x) {\n  const str = JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);\n  return str && str.length > toReadableString_max ? str.substring(0, toReadableString_max - 3) + '...' : str;\n}\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {Uint8Array} serialised value\n */\nexport function encode(argTypes, args) {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n  const typeTable = new TypeTable();\n  argTypes.forEach(t => t.buildTypeTable(typeTable));\n  const magic = new TextEncoder().encode(magicNumber);\n  const table = typeTable.encode();\n  const len = lebEncode(args.length);\n  const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n  const vals = concat(...zipWith(argTypes, args, (t, x) => {\n    try {\n      t.covariant(x);\n    } catch (e) {\n      const err = new Error(e.message + '\\n\\n');\n      throw err;\n    }\n    return t.encodeValue(x);\n  }));\n  return concat(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes, bytes) {\n  const b = new Pipe(bytes);\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n  const magicBuffer = safeRead(b, magicNumber.length);\n  const magic = new TextDecoder().decode(magicBuffer);\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n  function readTypeTable(pipe) {\n    const typeTable = [];\n    const len = Number(lebDecode(pipe));\n    for (let i = 0; i < len; i++) {\n      const ty = Number(slebDecode(pipe));\n      switch (ty) {\n        case IDLTypeIds.Opt:\n        case IDLTypeIds.Vector:\n          {\n            const t = Number(slebDecode(pipe));\n            typeTable.push([ty, t]);\n            break;\n          }\n        case IDLTypeIds.Record:\n        case IDLTypeIds.Variant:\n          {\n            const fields = [];\n            let objectLength = Number(lebDecode(pipe));\n            let prevHash;\n            while (objectLength--) {\n              const hash = Number(lebDecode(pipe));\n              if (hash >= Math.pow(2, 32)) {\n                throw new Error('field id out of 32-bit range');\n              }\n              if (typeof prevHash === 'number' && prevHash >= hash) {\n                throw new Error('field id collision or not sorted');\n              }\n              prevHash = hash;\n              const t = Number(slebDecode(pipe));\n              fields.push([hash, t]);\n            }\n            typeTable.push([ty, fields]);\n            break;\n          }\n        case IDLTypeIds.Func:\n          {\n            const args = [];\n            let argLength = Number(lebDecode(pipe));\n            while (argLength--) {\n              args.push(Number(slebDecode(pipe)));\n            }\n            const returnValues = [];\n            let returnValuesLength = Number(lebDecode(pipe));\n            while (returnValuesLength--) {\n              returnValues.push(Number(slebDecode(pipe)));\n            }\n            const annotations = [];\n            let annotationLength = Number(lebDecode(pipe));\n            while (annotationLength--) {\n              const annotation = Number(lebDecode(pipe));\n              switch (annotation) {\n                case 1:\n                  {\n                    annotations.push('query');\n                    break;\n                  }\n                case 2:\n                  {\n                    annotations.push('oneway');\n                    break;\n                  }\n                case 3:\n                  {\n                    annotations.push('composite_query');\n                    break;\n                  }\n                default:\n                  throw new Error('unknown annotation');\n              }\n            }\n            typeTable.push([ty, [args, returnValues, annotations]]);\n            break;\n          }\n        case IDLTypeIds.Service:\n          {\n            let servLength = Number(lebDecode(pipe));\n            const methods = [];\n            while (servLength--) {\n              const nameLength = Number(lebDecode(pipe));\n              const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));\n              const funcType = slebDecode(pipe);\n              methods.push([funcName, funcType]);\n            }\n            typeTable.push([ty, methods]);\n            break;\n          }\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n    const rawList = [];\n    const length = Number(lebDecode(pipe));\n    for (let i = 0; i < length; i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n    return [typeTable, rawList];\n  }\n  const [rawTable, rawTypes] = readTypeTable(b);\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n  const table = rawTable.map(_ => Rec());\n  function getType(t) {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n        case -2:\n          return Bool;\n        case -3:\n          return Nat;\n        case -4:\n          return Int;\n        case -5:\n          return Nat8;\n        case -6:\n          return Nat16;\n        case -7:\n          return Nat32;\n        case -8:\n          return Nat64;\n        case -9:\n          return Int8;\n        case -10:\n          return Int16;\n        case -11:\n          return Int32;\n        case -12:\n          return Int64;\n        case -13:\n          return Float32;\n        case -14:\n          return Float64;\n        case -15:\n          return Text;\n        case -16:\n          return Reserved;\n        case -17:\n          return Empty;\n        case -24:\n          return Principal;\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n    return table[t];\n  }\n  function buildType(entry) {\n    switch (entry[0]) {\n      case IDLTypeIds.Vector:\n        {\n          const ty = getType(entry[1]);\n          return Vec(ty);\n        }\n      case IDLTypeIds.Opt:\n        {\n          const ty = getType(entry[1]);\n          return Opt(ty);\n        }\n      case IDLTypeIds.Record:\n        {\n          const fields = {};\n          for (const [hash, ty] of entry[1]) {\n            const name = `_${hash}_`;\n            fields[name] = getType(ty);\n          }\n          const record = Record(fields);\n          const tuple = record.tryAsTuple();\n          if (Array.isArray(tuple)) {\n            return Tuple(...tuple);\n          } else {\n            return record;\n          }\n        }\n      case IDLTypeIds.Variant:\n        {\n          const fields = {};\n          for (const [hash, ty] of entry[1]) {\n            const name = `_${hash}_`;\n            fields[name] = getType(ty);\n          }\n          return Variant(fields);\n        }\n      case IDLTypeIds.Func:\n        {\n          const [args, returnValues, annotations] = entry[1];\n          return Func(args.map(t => getType(t)), returnValues.map(t => getType(t)), annotations);\n        }\n      case IDLTypeIds.Service:\n        {\n          const rec = {};\n          const methods = entry[1];\n          for (const [name, typeRef] of methods) {\n            let type = getType(typeRef);\n            if (type instanceof RecClass) {\n              // unpack reference type\n              type = type.getType();\n            }\n            if (!(type instanceof FuncClass)) {\n              throw new Error('Illegal service definition: services can only contain functions');\n            }\n            rec[name] = type;\n          }\n          return Service(rec);\n        }\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n  rawTable.forEach((entry, i) => {\n    // Process function type first, so that we can construct the correct service type\n    if (entry[0] === IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  rawTable.forEach((entry, i) => {\n    if (entry[0] !== IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  resetSubtypeCache();\n  const types = rawTypes.map(t => getType(t));\n  try {\n    const output = retTypes.map((t, i) => {\n      return t.decodeValue(b, types[i]);\n    });\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n      types[ind].decodeValue(b, types[ind]);\n    }\n    if (b.byteLength > 0) {\n      throw new Error('decode: Left-over bytes');\n    }\n    return output;\n  } finally {\n    resetSubtypeCache();\n  }\n}\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nexport const Unknown = new UnknownClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\nexport const Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple(...types) {\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec(t) {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt(t) {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t) {\n  return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields) {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec() {\n  return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func(args, ret, annotations = []) {\n  return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service(t) {\n  return new ServiceClass(t);\n}\n/**\n * The list of relations between types we assume to hold. Uses the types .name property as key\n */\nclass Relations {\n  constructor(relations = new Map()) {\n    this.rels = relations;\n  }\n  copy() {\n    const copy = new Map();\n    for (const [key, value] of this.rels.entries()) {\n      const valCopy = new Map(value);\n      copy.set(key, valCopy);\n    }\n    return new Relations(copy);\n  }\n  /// Returns whether we know for sure that a relation holds or doesn't (`true` or `false`), or\n  /// if we don't know yet (`undefined`)\n  known(t1, t2) {\n    return this.rels.get(t1.name)?.get(t2.name);\n  }\n  addNegative(t1, t2) {\n    this.addNames(t1.name, t2.name, false);\n  }\n  add(t1, t2) {\n    this.addNames(t1.name, t2.name, true);\n  }\n  display() {\n    let result = '';\n    for (const [t1, v] of this.rels) {\n      for (const [t2, known] of v) {\n        const subty = known ? ':<' : '!<:';\n        result += `${t1} ${subty} ${t2}\\n`;\n      }\n    }\n    return result;\n  }\n  addNames(t1, t2, isSubtype) {\n    const t1Map = this.rels.get(t1);\n    if (t1Map == undefined) {\n      const newMap = new Map();\n      newMap.set(t2, isSubtype);\n      this.rels.set(t1, newMap);\n    } else {\n      t1Map.set(t2, isSubtype);\n    }\n  }\n}\n/// `subtypeCache` holds subtyping relations we've previously computed while decoding a message\nlet subtypeCache = new Relations();\n/** Resets the global subtyping cache */\nexport function resetSubtypeCache() {\n  subtypeCache = new Relations();\n}\nfunction eqFunctionAnnotations(t1, t2) {\n  const t1Annotations = new Set(t1.annotations);\n  const t2Annotations = new Set(t2.annotations);\n  if (t1Annotations.size !== t2Annotations.size) {\n    return false;\n  }\n  for (const a of t1Annotations) {\n    if (!t2Annotations.has(a)) return false;\n  }\n  return true;\n}\nfunction canBeOmmitted(t) {\n  return t instanceof OptClass || t instanceof NullClass || t instanceof ReservedClass;\n}\n/**\n * Subtyping on Candid types t1 <: t2 (Exported for testing)\n * @param t1 The potential subtype\n * @param t2 The potential supertype\n */\nexport function subtype(t1, t2) {\n  const relations = subtypeCache.copy();\n  const isSubtype = subtype_(relations, t1, t2);\n  if (isSubtype) {\n    subtypeCache.add(t1, t2);\n  } else {\n    subtypeCache.addNegative(t1, t2);\n  }\n  return isSubtype;\n}\nfunction subtype_(relations, t1, t2) {\n  if (t1.name === t2.name) return true;\n  const known = relations.known(t1, t2);\n  if (known !== undefined) return known;\n  relations.add(t1, t2);\n  if (t2 instanceof ReservedClass) return true;\n  if (t1 instanceof EmptyClass) return true;\n  if (t1 instanceof NatClass && t2 instanceof IntClass) return true;\n  if (t1 instanceof VecClass && t2 instanceof VecClass) return subtype_(relations, t1._type, t2._type);\n  if (t2 instanceof OptClass) return true;\n  if (t1 instanceof RecordClass && t2 instanceof RecordClass) {\n    const t1Object = t1.fieldsAsObject;\n    for (const [label, ty2] of t2._fields) {\n      const ty1 = t1Object[idlLabelToId(label)];\n      if (!ty1) {\n        if (!canBeOmmitted(ty2)) return false;\n      } else {\n        if (!subtype_(relations, ty1, ty2)) return false;\n      }\n    }\n    return true;\n  }\n  if (t1 instanceof FuncClass && t2 instanceof FuncClass) {\n    if (!eqFunctionAnnotations(t1, t2)) return false;\n    for (let i = 0; i < t1.argTypes.length; i++) {\n      const argTy1 = t1.argTypes[i];\n      if (i < t2.argTypes.length) {\n        if (!subtype_(relations, t2.argTypes[i], argTy1)) return false;\n      } else {\n        if (!canBeOmmitted(argTy1)) return false;\n      }\n    }\n    for (let i = 0; i < t2.retTypes.length; i++) {\n      const retTy2 = t2.retTypes[i];\n      if (i < t1.retTypes.length) {\n        if (!subtype_(relations, t1.retTypes[i], retTy2)) return false;\n      } else {\n        if (!canBeOmmitted(retTy2)) return false;\n      }\n    }\n    return true;\n  }\n  if (t1 instanceof VariantClass && t2 instanceof VariantClass) {\n    const t2Object = t2.alternativesAsObject;\n    for (const [label, ty1] of t1._fields) {\n      const ty2 = t2Object[idlLabelToId(label)];\n      if (!ty2) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n  if (t1 instanceof ServiceClass && t2 instanceof ServiceClass) {\n    const t1Object = t1.fieldsAsObject();\n    for (const [name, ty2] of t2._fields) {\n      const ty1 = t1Object[name];\n      if (!ty1) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n  if (t1 instanceof RecClass) {\n    return subtype_(relations, t1.getType(), t2);\n  }\n  if (t2 instanceof RecClass) {\n    return subtype_(relations, t1, t2.getType());\n  }\n  return false;\n}","map":{"version":3,"names":["Principal","PrincipalId","concat","PipeArrayBuffer","Pipe","uint8ToDataView","idlLabelToId","lebDecode","lebEncode","readIntLE","readUIntLE","safeRead","safeReadUint8","slebDecode","slebEncode","writeIntLE","writeUIntLE","iexp2","IDLTypeIds","magicNumber","toReadableString_max","zipWith","xs","ys","f","map","x","i","TypeTable","constructor","_typs","_idx","Map","has","obj","name","add","type","buf","idx","length","set","push","merge","knot","get","knotIdx","undefined","Error","splice","delete","encode","len","indexOf","typeName","Visitor","visitType","_t","_data","visitPrimitive","t","data","visitEmpty","visitBool","visitNull","visitReserved","visitText","visitNumber","visitInt","visitNat","visitFloat","visitFixedInt","visitFixedNat","visitPrincipal","visitConstruct","visitVec","_ty","visitOpt","visitRecord","_fields","visitTuple","components","fields","ty","visitVariant","visitRec","visitFunc","visitService","IdlTypeName","Type","display","valueToString","toReadableString","buildTypeTable","typeTable","_buildTypeTableImpl","PrimitiveType","checkType","_typeTable","ConstructType","RecClass","getType","encodeType","EmptyClass","Symbol","hasInstance","instance","accept","v","d","covariant","encodeValue","Empty","decodeValue","UnknownClass","b","decodedValue","Object","typeFunc","defineProperty","value","writable","enumerable","configurable","BoolClass","Uint8Array","Bool","NullClass","Null","_b","ReservedClass","_x","Reserved","TextClass","TextEncoder","byteLength","Text","Number","decoder","TextDecoder","fatal","decode","IntClass","isInteger","Int","toString","NatClass","BigInt","Nat","FloatClass","_bits","ArrayBuffer","view","DataView","setFloat32","setFloat64","opcode","Float32","Float64","bytes","getFloat32","getFloat64","FixedIntClass","min","max","ok","offset","Math","log2","num","FixedNatClass","VecClass","_type","_blobOptimization","bits","isView","BYTES_PER_ELEMENT","Array","isArray","every","e","message","Int16Array","Uint16Array","buffer","setInt16","setUint16","Int32Array","Uint32Array","setInt32","setUint32","BigInt64Array","BigUint64Array","setBigInt64","setBigUint64","byteOffset","write","encoded","opCode","Vector","vec","read","u16","u32","Int8Array","result","getInt16","getInt32","getBigInt64","rets","elements","join","OptClass","Opt","wireType","checkpoint","save","restore","RecordClass","TupleClass","entries","sort","a","tryAsTuple","res","key","k","hasOwnProperty","values","bufs","c","T","forEach","_","Record","record","expectedRecordIdx","actualRecordIdx","hash","expectKey","expectType","expectedId","actualId","slice","fieldsAsObject","_components","tuple","VariantClass","Variant","variant","wireHash","alternativesAsObject","alternatives","_id","_counter","fill","decodePrincipalId","fromUint8Array","PrincipalClass","_isPrincipal","toUint8Array","toText","FuncClass","argsToString","types","argTypes","retTypes","annotations","principal","methodName","canister","method","methodLen","arg","Func","argLen","args","retLen","annLen","anns","encodeAnnotation","tt","subtype","mLen","annon","str","ann","ServiceClass","func","Service","meths","label","labelBuf","labelLen","JSON","stringify","_key","substring","magic","table","typs","vals","err","magicBuffer","readTypeTable","pipe","objectLength","prevHash","pow","argLength","returnValues","returnValuesLength","annotationLength","annotation","servLength","methods","nameLength","funcName","funcType","rawList","rawTable","rawTypes","Rec","Nat8","Nat16","Nat32","Nat64","Int8","Int16","Int32","Int64","buildType","entry","Vec","Tuple","rec","typeRef","resetSubtypeCache","output","ind","Unknown","ret","Relations","relations","rels","copy","valCopy","known","t1","t2","addNegative","addNames","subty","isSubtype","t1Map","newMap","subtypeCache","eqFunctionAnnotations","t1Annotations","Set","t2Annotations","size","canBeOmmitted","subtype_","t1Object","ty2","ty1","argTy1","retTy2","t2Object"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\candid\\src\\idl.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { type JsonValue } from './types.ts';\nimport { concat, PipeArrayBuffer as Pipe, uint8ToDataView } from './utils/buffer.ts';\nimport { idlLabelToId } from './utils/hash.ts';\nimport {\n  lebDecode,\n  lebEncode,\n  readIntLE,\n  readUIntLE,\n  safeRead,\n  safeReadUint8,\n  slebDecode,\n  slebEncode,\n  writeIntLE,\n  writeUIntLE,\n} from './utils/leb128.ts';\nimport { iexp2 } from './utils/bigint-math.ts';\n\n/**\n * This module provides a combinator library to create serializers/deserializers\n * between JavaScript values and IDL used by canisters on the Internet Computer,\n * as documented at https://github.com/dfinity/candid/blob/119703ba342d2fef6ab4972d2541b9fe36ae8e36/spec/Candid.md\n */\n\nenum IDLTypeIds {\n  Null = -1,\n  Bool = -2,\n  Nat = -3,\n  Int = -4,\n  Float32 = -13,\n  Float64 = -14,\n  Text = -15,\n  Reserved = -16,\n  Empty = -17,\n  Opt = -18,\n  Vector = -19,\n  Record = -20,\n  Variant = -21,\n  Func = -22,\n  Service = -23,\n  Principal = -24,\n}\n\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\n\nfunction zipWith<TX, TY, TR>(xs: TX[], ys: TY[], f: (a: TX, b: TY) => TR): TR[] {\n  return xs.map((x, i) => f(x, ys[i]));\n}\n\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n  // List of types. Needs to be an array as the index needs to be stable.\n  private _typs: Uint8Array[] = [];\n  private _idx = new Map<string, number>();\n\n  public has(obj: ConstructType) {\n    return this._idx.has(obj.name);\n  }\n\n  public add<T>(type: ConstructType<T>, buf: Uint8Array) {\n    const idx = this._typs.length;\n    this._idx.set(type.name, idx);\n    this._typs.push(buf);\n  }\n\n  public merge<T>(obj: ConstructType<T>, knot: string) {\n    const idx = this._idx.get(obj.name);\n    const knotIdx = this._idx.get(knot);\n    if (idx === undefined) {\n      throw new Error('Missing type index for ' + obj);\n    }\n    if (knotIdx === undefined) {\n      throw new Error('Missing type index for ' + knot);\n    }\n    this._typs[idx] = this._typs[knotIdx];\n\n    // Delete the type.\n    this._typs.splice(knotIdx, 1);\n    this._idx.delete(knot);\n  }\n\n  public encode(): Uint8Array {\n    const len = lebEncode(this._typs.length);\n    const buf = concat(...this._typs);\n    return concat(len, buf);\n  }\n\n  public indexOf(typeName: string): Uint8Array {\n    if (!this._idx.has(typeName)) {\n      throw new Error('Missing type index for ' + typeName);\n    }\n    return slebEncode(this._idx.get(typeName) || 0);\n  }\n}\n\nexport abstract class Visitor<D, R> {\n  public visitType<T>(_t: Type<T>, _data: D): R {\n    throw new Error('Not implemented');\n  }\n  public visitPrimitive<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitEmpty(t: EmptyClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitBool(t: BoolClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNull(t: NullClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitReserved(t: ReservedClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitText(t: TextClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNumber<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitInt(t: IntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitNat(t: NatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFloat(t: FloatClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitFixedInt(t: FixedIntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFixedNat(t: FixedNatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitPrincipal(t: PrincipalClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n\n  public visitConstruct<T>(t: ConstructType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitVec<T>(t: VecClass<T>, _ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitOpt<T>(t: OptClass<T>, _ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRecord(t: RecordClass, _fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitTuple<T extends any[]>(t: TupleClass<T>, components: Type[], data: D): R {\n    const fields: Array<[string, Type]> = components.map((ty, i) => [`_${i}_`, ty]);\n    return this.visitRecord(t, fields, data);\n  }\n  public visitVariant(t: VariantClass, _fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRec<T>(_t: RecClass<T>, ty: ConstructType<T>, data: D): R {\n    return this.visitConstruct(ty, data);\n  }\n  public visitFunc(t: FuncClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitService(t: ServiceClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n}\n\n// We try to use hard-to-accidentally-pick names to avoid potential collisions with other types.\nenum IdlTypeName {\n  EmptyClass = '__IDL_EmptyClass__',\n  UnknownClass = '__IDL_UnknownClass__',\n  BoolClass = '__IDL_BoolClass__',\n  NullClass = '__IDL_NullClass__',\n  ReservedClass = '__IDL_ReservedClass__',\n  TextClass = '__IDL_TextClass__',\n  IntClass = '__IDL_IntClass__',\n  NatClass = '__IDL_NatClass__',\n  FloatClass = '__IDL_FloatClass__',\n  FixedIntClass = '__IDL_FixedIntClass__',\n  FixedNatClass = '__IDL_FixedNatClass__',\n  VecClass = '__IDL_VecClass__',\n  OptClass = '__IDL_OptClass__',\n  RecordClass = '__IDL_RecordClass__',\n  TupleClass = '__IDL_TupleClass__',\n  VariantClass = '__IDL_VariantClass__',\n  RecClass = '__IDL_RecClass__',\n  PrincipalClass = '__IDL_PrincipalClass__',\n  FuncClass = '__IDL_FuncClass__',\n  ServiceClass = '__IDL_ServiceClass__',\n}\n\n/**\n * Represents an IDL type.\n */\nexport abstract class Type<T = any> {\n  public abstract readonly typeName: IdlTypeName;\n  public abstract readonly name: string;\n  public abstract accept<D, R>(v: Visitor<D, R>, d: D): R;\n\n  /* Display type name */\n  public display(): string {\n    return this.name;\n  }\n\n  public valueToString(x: T): string {\n    return toReadableString(x);\n  }\n\n  /* Implement `T` in the IDL spec, only needed for non-primitive types */\n  public buildTypeTable(typeTable: TypeTable): void {\n    if (!typeTable.has(this)) {\n      this._buildTypeTableImpl(typeTable);\n    }\n  }\n\n  /**\n   * Assert that JavaScript's `x` is the proper type represented by this\n   * Type.\n   */\n  public abstract covariant(x: any): x is T;\n\n  /**\n   * Encode the value. This needs to be public because it is used by\n   * encodeValue() from different types.\n   * @internal\n   */\n  public abstract encodeValue(x: T): Uint8Array;\n\n  /**\n   * Implement `I` in the IDL spec.\n   * Encode this type for the type table.\n   */\n  public abstract encodeType(typeTable: TypeTable): Uint8Array;\n\n  public abstract checkType(t: Type): Type;\n\n  public abstract decodeValue(x: Pipe, t: Type): T;\n\n  protected abstract _buildTypeTableImpl(typeTable: TypeTable): void;\n}\n\nexport abstract class PrimitiveType<T = any> extends Type<T> {\n  public checkType(t: Type): Type {\n    if (this.name !== t.name) {\n      throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    return t;\n  }\n\n  public _buildTypeTableImpl(_typeTable: TypeTable): void {\n    // No type table encoding for Primitive types.\n    return;\n  }\n}\n\nexport abstract class ConstructType<T = any> extends Type<T> {\n  public checkType(t: Type): ConstructType<T> {\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      }\n      return ty;\n    }\n    throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n  }\n  public encodeType(typeTable: TypeTable) {\n    return typeTable.indexOf(this.name);\n  }\n}\n\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType<never> {\n  get typeName() {\n    return IdlTypeName.EmptyClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is EmptyClass {\n    return instance.typeName === IdlTypeName.EmptyClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitEmpty(this, d);\n  }\n\n  public covariant(x: any): x is never {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Empty cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Empty cannot appear as a value');\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Empty);\n  }\n\n  public decodeValue(): never {\n    throw new Error('Empty cannot appear as an output');\n  }\n\n  get name() {\n    return 'empty';\n  }\n}\n\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nexport class UnknownClass extends Type {\n  get typeName() {\n    return IdlTypeName.UnknownClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is UnknownClass {\n    return instance.typeName === IdlTypeName.UnknownClass;\n  }\n\n  public checkType(_t: Type): Type {\n    throw new Error('Method not implemented for unknown.');\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    throw v.visitType(this, d);\n  }\n\n  public covariant(x: any): x is any {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Unknown cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Unknown cannot appear as a value');\n  }\n\n  public encodeType(): never {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  public decodeValue(b: Pipe, t: Type): any {\n    let decodedValue = t.decodeValue(b, t);\n\n    if (Object(decodedValue) !== decodedValue) {\n      // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n      // The type() function is important for primitives because otherwise we cannot tell apart the\n      // different number types.\n      decodedValue = Object(decodedValue);\n    }\n\n    let typeFunc;\n    if (t instanceof RecClass) {\n      typeFunc = () => t.getType();\n    } else {\n      typeFunc = () => t;\n    }\n    // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n    // 'type' which means it would be serialized if the value would be candid encoded again.\n    // This in turn leads to problems if the decoded value is a variant because these values are\n    // only allowed to have a single property.\n    Object.defineProperty(decodedValue, 'type', {\n      value: typeFunc,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n    return decodedValue;\n  }\n\n  protected _buildTypeTableImpl(): void {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  get name() {\n    return 'Unknown';\n  }\n}\n\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType<boolean> {\n  get typeName() {\n    return IdlTypeName.BoolClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is BoolClass {\n    return instance.typeName === IdlTypeName.BoolClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitBool(this, d);\n  }\n\n  public covariant(x: any): x is boolean {\n    if (typeof x === 'boolean') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: boolean): Uint8Array {\n    return new Uint8Array([x ? 1 : 0]);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Bool);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    switch (safeReadUint8(b)) {\n      case 0:\n        return false;\n      case 1:\n        return true;\n      default:\n        throw new Error('Boolean value out of range');\n    }\n  }\n\n  get name() {\n    return 'bool';\n  }\n}\n\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType<null> {\n  get typeName() {\n    return IdlTypeName.NullClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is NullClass {\n    return instance.typeName === IdlTypeName.NullClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNull(this, d);\n  }\n\n  public covariant(x: any): x is null {\n    if (x === null) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): Uint8Array {\n    return new Uint8Array(0);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Null);\n  }\n\n  public decodeValue(_b: Pipe, t: Type) {\n    this.checkType(t);\n    return null;\n  }\n\n  get name() {\n    return 'null';\n  }\n}\n\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType<any> {\n  get typeName() {\n    return IdlTypeName.ReservedClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is ReservedClass {\n    return instance.typeName === IdlTypeName.ReservedClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitReserved(this, d);\n  }\n\n  public covariant(_x: any): _x is any {\n    return true;\n  }\n\n  public encodeValue(): Uint8Array {\n    return new Uint8Array(0);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Reserved);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (t.name !== this.name) {\n      t.decodeValue(b, t);\n    }\n    return null;\n  }\n\n  get name() {\n    return 'reserved';\n  }\n}\n\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType<string> {\n  get typeName() {\n    return IdlTypeName.TextClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is TextClass {\n    return instance.typeName === IdlTypeName.TextClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitText(this, d);\n  }\n\n  public covariant(x: any): x is string {\n    if (typeof x === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: string) {\n    const buf = new TextEncoder().encode(x);\n    const len = lebEncode(buf.byteLength);\n    return concat(len, buf);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Text);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const len = lebDecode(b);\n    const buf = safeRead(b, Number(len));\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    return decoder.decode(buf);\n  }\n\n  get name() {\n    return 'text';\n  }\n\n  public valueToString(x: string) {\n    return '\"' + x + '\"';\n  }\n}\n\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType<bigint> {\n  get typeName() {\n    return IdlTypeName.IntClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is IntClass {\n    return instance.typeName === IdlTypeName.IntClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' || Number.isInteger(x)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number): Uint8Array {\n    return slebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Int);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return slebDecode(b);\n  }\n\n  get name() {\n    return 'int';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType<bigint> {\n  get typeName() {\n    return IdlTypeName.NatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is NatClass {\n    return instance.typeName === IdlTypeName.NatClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number): Uint8Array {\n    return lebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Nat);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return lebDecode(b);\n  }\n\n  get name() {\n    return 'nat';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType<number> {\n  get typeName() {\n    return IdlTypeName.FloatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FloatClass {\n    return instance.typeName === IdlTypeName.FloatClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFloat(this, d);\n  }\n\n  public covariant(x: any): x is number {\n    if (typeof x === 'number' || x instanceof Number) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: number) {\n    const buf = new ArrayBuffer(this._bits / 8);\n    const view = new DataView(buf);\n    if (this._bits === 32) {\n      view.setFloat32(0, x, true);\n    } else {\n      view.setFloat64(0, x, true);\n    }\n    return new Uint8Array(buf);\n  }\n\n  public encodeType(): Uint8Array {\n    const opcode = this._bits === 32 ? IDLTypeIds.Float32 : IDLTypeIds.Float64;\n    return slebEncode(opcode);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const bytes = safeRead(b, this._bits / 8);\n    const view = uint8ToDataView(bytes);\n    if (this._bits === 32) {\n      return view.getFloat32(0, true);\n    } else {\n      return view.getFloat64(0, true);\n    }\n  }\n\n  get name() {\n    return 'float' + this._bits;\n  }\n\n  public valueToString(x: number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType<bigint | number> {\n  get typeName() {\n    return IdlTypeName.FixedIntClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FixedIntClass {\n    return instance.typeName === IdlTypeName.FixedIntClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const min = iexp2(this._bits - 1) * BigInt(-1);\n    const max = iexp2(this._bits - 1) - BigInt(1);\n    let ok = false;\n    if (typeof x === 'bigint') {\n      ok = x >= min && x <= max;\n    } else if (Number.isInteger(x)) {\n      const v = BigInt(x);\n      ok = v >= min && v <= max;\n    } else {\n      ok = false;\n    }\n\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-9 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `int${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType<bigint | number> {\n  get typeName() {\n    return IdlTypeName.FixedNatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FixedNatClass {\n    return instance.typeName === IdlTypeName.FixedNatClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const max = iexp2(this._bits);\n    let ok = false;\n    if (typeof x === 'bigint' && x >= BigInt(0)) {\n      ok = x < max;\n    } else if (Number.isInteger(x) && x >= 0) {\n      const v = BigInt(x);\n      ok = v < max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeUIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-5 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readUIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `nat${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nexport class VecClass<T> extends ConstructType<T[]> {\n  get typeName() {\n    return IdlTypeName.VecClass;\n  }\n\n  static [Symbol.hasInstance]<T>(instance: any): instance is VecClass<T> {\n    return instance.typeName === IdlTypeName.VecClass;\n  }\n\n  // If true, this vector is really a blob and we can just use memcpy.\n  //\n  // NOTE:\n  // With support of encoding/dencoding of TypedArrays, this optimization is\n  // only used when plain array of bytes are passed as encoding input in order\n  // to be backward compatible.\n  private _blobOptimization = false;\n\n  constructor(public _type: Type<T>) {\n    super();\n    if (_type instanceof FixedNatClass && _type._bits === 8) {\n      this._blobOptimization = true;\n    }\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVec(this, this._type, d);\n  }\n\n  public covariant(x: any): x is T[] {\n    // Special case for ArrayBuffer\n    const bits =\n      this._type instanceof FixedNatClass\n        ? this._type._bits\n        : this._type instanceof FixedIntClass\n          ? this._type._bits\n          : 0;\n\n    if (\n      (ArrayBuffer.isView(x) && bits == (x as any).BYTES_PER_ELEMENT * 8) ||\n      (Array.isArray(x) &&\n        x.every((v, idx) => {\n          try {\n            return this._type.covariant(v);\n          } catch (e: any) {\n            throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n          }\n        }))\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T[]): Uint8Array {\n    const len = lebEncode(x.length);\n    if (this._blobOptimization) {\n      return concat(len, new Uint8Array(x as unknown as number[]));\n    }\n\n    if (ArrayBuffer.isView(x)) {\n      // Handle TypedArrays with endianness concerns\n      if (x instanceof Int16Array || x instanceof Uint16Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 2));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int16Array) {\n            buffer.setInt16(i * 2, x[i], true); // true = little-endian\n          } else {\n            buffer.setUint16(i * 2, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof Int32Array || x instanceof Uint32Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 4));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int32Array) {\n            buffer.setInt32(i * 4, x[i], true);\n          } else {\n            buffer.setUint32(i * 4, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof BigInt64Array || x instanceof BigUint64Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 8));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof BigInt64Array) {\n            buffer.setBigInt64(i * 8, x[i], true);\n          } else {\n            buffer.setBigUint64(i * 8, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else {\n        // For Uint8Array, Int8Array, etc. that don't have endianness concerns\n        return concat(len, new Uint8Array(x.buffer, x.byteOffset, x.byteLength));\n      }\n    }\n    const buf = new Pipe(new Uint8Array(len.byteLength + x.length), 0);\n    buf.write(len);\n    for (const d of x) {\n      const encoded = this._type.encodeValue(d);\n      buf.write(new Uint8Array(encoded));\n    }\n    return buf.buffer;\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Vector);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): T[] {\n    const vec = this.checkType(t);\n    if (!(vec instanceof VecClass)) {\n      throw new Error('Not a vector type');\n    }\n    const len = Number(lebDecode(b));\n\n    if (this._type instanceof FixedNatClass) {\n      if (this._type._bits == 8) {\n        return new Uint8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Check if we need to swap bytes for endianness\n        const u16 = new Uint16Array(bytes.buffer, bytes.byteOffset, len);\n        return u16 as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const u32 = new Uint32Array(bytes.buffer, bytes.byteOffset, len);\n        return u32 as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        return new BigUint64Array(b.read(len * 8).buffer) as unknown as T[];\n      }\n    }\n\n    if (this._type instanceof FixedIntClass) {\n      if (this._type._bits == 8) {\n        return new Int8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Create a DataView to properly handle endianness\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        // Create result array with correct endianness\n        const result = new Int16Array(len);\n        for (let i = 0; i < len; i++) {\n          // Read each value as little-endian (Candid wire format is little-endian)\n          result[i] = view.getInt16(i * 2, true);\n        }\n        return result as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        const result = new Int32Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getInt32(i * 4, true);\n        }\n        return result as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        const bytes = b.read(len * 8);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        const result = new BigInt64Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getBigInt64(i * 8, true);\n        }\n        return result as unknown as T[];\n      }\n    }\n\n    const rets: T[] = [];\n    for (let i = 0; i < len; i++) {\n      rets.push(this._type.decodeValue(b, vec._type));\n    }\n    return rets;\n  }\n\n  get name() {\n    return `vec ${this._type.name}`;\n  }\n\n  public display() {\n    return `vec ${this._type.display()}`;\n  }\n\n  public valueToString(x: T[]) {\n    const elements = x.map(e => this._type.valueToString(e));\n    return 'vec {' + elements.join('; ') + '}';\n  }\n}\n\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass<T> extends ConstructType<[T] | []> {\n  get typeName() {\n    return IdlTypeName.OptClass;\n  }\n\n  static [Symbol.hasInstance]<T>(instance: any): instance is OptClass<T> {\n    return instance.typeName === IdlTypeName.OptClass;\n  }\n\n  constructor(public _type: Type<T>) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitOpt(this, this._type, d);\n  }\n\n  public covariant(x: any): x is [T] | [] {\n    try {\n      if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n        return true;\n    } catch (e: any) {\n      throw new Error(\n        `Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`,\n      );\n    }\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: [T] | []): Uint8Array {\n    if (x.length === 0) {\n      return new Uint8Array([0]);\n    } else {\n      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n    }\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Opt);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [T] | [] {\n    if (t instanceof NullClass) {\n      return [];\n    }\n\n    if (t instanceof ReservedClass) {\n      return [];\n    }\n\n    let wireType = t;\n    // unfold wireType, if needed\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      } else wireType = ty;\n    }\n\n    if (wireType instanceof OptClass) {\n      switch (safeReadUint8(b)) {\n        case 0:\n          return [];\n        case 1: {\n          // Save the current state of the Pipe `b` to allow rollback in case of an error\n          const checkpoint = b.save();\n          try {\n            // Attempt to decode a value using the `_type` of the current instance\n            const v = this._type.decodeValue(b, wireType._type);\n            return [v];\n          } catch (e: any) {\n            // If an error occurs during decoding, restore the Pipe `b` to its previous state\n            b.restore(checkpoint);\n            // Skip the value at the current wire type to advance the Pipe `b` position\n            wireType._type.decodeValue(b, wireType._type);\n            // Return an empty array to indicate a `none` value\n            return [];\n          }\n        }\n        default:\n          throw new Error('Not an option value');\n      }\n    } else if (\n      // this check corresponds to `not (null <: <t>)` in the spec\n      this._type instanceof NullClass ||\n      this._type instanceof OptClass ||\n      this._type instanceof ReservedClass\n    ) {\n      // null <: <t> :\n      // skip value at wire type (to advance b) and return \"null\", i.e. []\n      wireType.decodeValue(b, wireType);\n      return [];\n    } else {\n      // not (null <: t) :\n      // try constituent type\n      const checkpoint = b.save();\n      try {\n        const v = this._type.decodeValue(b, t);\n        return [v];\n      } catch (e: any) {\n        // decoding failed, but this is opt, so return \"null\", i.e. []\n        b.restore(checkpoint);\n        // skip value at wire type (to advance b)\n        wireType.decodeValue(b, t);\n        // return \"null\"\n        return [];\n      }\n    }\n  }\n\n  get name() {\n    return `opt ${this._type.name}`;\n  }\n\n  public display() {\n    return `opt ${this._type.display()}`;\n  }\n\n  public valueToString(x: [T] | []) {\n    if (x.length === 0) {\n      return 'null';\n    } else {\n      return `opt ${this._type.valueToString(x[0])}`;\n    }\n  }\n}\n\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType<Record<string, any>> {\n  get typeName() {\n    return IdlTypeName.RecordClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is RecordClass {\n    // TupleClass extends RecordClass, so we need to check both here\n    return (\n      instance.typeName === IdlTypeName.RecordClass || instance.typeName === IdlTypeName.TupleClass\n    );\n  }\n\n  public readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitRecord(this, this._fields, d);\n  }\n\n  public tryAsTuple(): Type[] | null {\n    const res: Type[] = [];\n    for (let i = 0; i < this._fields.length; i++) {\n      const [key, type] = this._fields[i];\n      if (key !== `_${i}_`) {\n        return null;\n      }\n      res.push(type);\n    }\n    return res;\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      this._fields.every(([k, t]) => {\n        // eslint-disable-next-line\n        if (!x.hasOwnProperty(k)) {\n          throw new Error(`Record is missing key \"${k}\".`);\n        }\n        try {\n          return t.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>): Uint8Array {\n    const values = this._fields.map(([key]) => x[key]);\n    const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Record);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(T)),\n    );\n\n    T.add(this, concat(opCode, len, concat(...fields)));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const record = this.checkType(t);\n    if (!(record instanceof RecordClass)) {\n      throw new Error('Not a record type');\n    }\n    const x: Record<string, any> = {};\n\n    let expectedRecordIdx = 0;\n    let actualRecordIdx = 0;\n    while (actualRecordIdx < record._fields.length) {\n      const [hash, type] = record._fields[actualRecordIdx];\n\n      if (expectedRecordIdx >= this._fields.length) {\n        // skip unexpected left over fields present on the wire\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n        continue;\n      }\n\n      const [expectKey, expectType] = this._fields[expectedRecordIdx];\n      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);\n      const actualId = idlLabelToId(hash);\n      if (expectedId === actualId) {\n        // the current field on the wire matches the expected field\n        x[expectKey] = expectType.decodeValue(b, type);\n        expectedRecordIdx++;\n        actualRecordIdx++;\n      } else if (actualId > expectedId) {\n        // The expected field does not exist on the wire\n        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n          x[expectKey] = [];\n          expectedRecordIdx++;\n        } else {\n          throw new Error('Cannot find required field ' + expectKey);\n        }\n      } else {\n        // The field on the wire does not exist in the output type, so we can skip it\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n      }\n    }\n\n    // initialize left over expected optional fields\n    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n        // TODO this assumes null value in opt is represented as []\n        x[expectKey] = [];\n      } else {\n        throw new Error('Cannot find required field ' + expectKey);\n      }\n    }\n    return x;\n  }\n\n  get fieldsAsObject(): Record<number, Type> {\n    const fields: Record<number, Type> = {};\n    for (const [name, ty] of this._fields) {\n      fields[idlLabelToId(name)] = ty;\n    }\n    return fields;\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    const values = this._fields.map(([key]) => x[key]);\n    const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass<T extends any[]> extends RecordClass {\n  get typeName() {\n    return IdlTypeName.TupleClass;\n  }\n\n  static [Symbol.hasInstance]<T extends any[]>(instance: any): instance is TupleClass<T> {\n    return instance.typeName === IdlTypeName.TupleClass;\n  }\n\n  protected readonly _components: Type[];\n\n  constructor(_components: Type[]) {\n    const x: Record<string, any> = {};\n    _components.forEach((e, i) => (x['_' + i + '_'] = e));\n    super(x);\n    this._components = _components;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitTuple(this, this._components, d);\n  }\n\n  public covariant(x: any): x is T {\n    // `>=` because tuples can be covariant when encoded.\n\n    if (\n      Array.isArray(x) &&\n      x.length >= this._fields.length &&\n      this._components.every((t, i) => {\n        try {\n          return t.covariant(x[i]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: any[]): Uint8Array {\n    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public decodeValue(b: Pipe, t: Type): T {\n    const tuple = this.checkType(t);\n    if (!(tuple instanceof TupleClass)) {\n      throw new Error('not a tuple type');\n    }\n    if (tuple._components.length < this._components.length) {\n      throw new Error('tuple mismatch');\n    }\n    const res = [];\n    for (const [i, wireType] of tuple._components.entries()) {\n      if (i >= this._components.length) {\n        // skip value\n        wireType.decodeValue(b, wireType);\n      } else {\n        res.push(this._components[i].decodeValue(b, wireType));\n      }\n    }\n    return res as T;\n  }\n\n  public display() {\n    const fields = this._components.map(value => value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(values: any[]) {\n    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType<Record<string, any>> {\n  get typeName() {\n    return IdlTypeName.VariantClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is VariantClass {\n    return instance.typeName === IdlTypeName.VariantClass;\n  }\n\n  public readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVariant(this, this._fields, d);\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      Object.entries(x).length === 1 &&\n      this._fields.every(([k, v]) => {\n        try {\n          // eslint-disable-next-line\n          return !x.hasOwnProperty(k) || v.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>) {\n    for (let i = 0; i < this._fields.length; i++) {\n      const [name, type] = this._fields[i];\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const idx = lebEncode(i);\n        const buf = type.encodeValue(x[name]);\n\n        return concat(idx, buf);\n      }\n    }\n    throw Error('Variant has no data: ' + x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._fields.forEach(([, type]) => {\n      type.buildTypeTable(typeTable);\n    });\n    const opCode = slebEncode(IDLTypeIds.Variant);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)),\n    );\n    typeTable.add(this, concat(opCode, len, ...fields));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const variant = this.checkType(t);\n    if (!(variant instanceof VariantClass)) {\n      throw new Error('Not a variant type');\n    }\n    const idx = Number(lebDecode(b));\n    if (idx >= variant._fields.length) {\n      throw Error('Invalid variant index: ' + idx);\n    }\n    const [wireHash, wireType] = variant._fields[idx];\n    for (const [key, expectType] of this._fields) {\n      if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n        const value = expectType.decodeValue(b, wireType);\n        return { [key]: value };\n      }\n    }\n    throw new Error('Cannot find field hash ' + wireHash);\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(\n      ([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`),\n    );\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    for (const [name, type] of this._fields) {\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const value = type.valueToString(x[name]);\n        if (value === 'null') {\n          return `variant {${name}}`;\n        } else {\n          return `variant {${name}=${value}}`;\n        }\n      }\n    }\n    throw new Error('Variant has no data: ' + x);\n  }\n\n  get alternativesAsObject(): Record<number, Type> {\n    const alternatives: Record<number, Type> = {};\n    for (const [name, ty] of this._fields) {\n      alternatives[idlLabelToId(name)] = ty;\n    }\n    return alternatives;\n  }\n}\n\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass<T = any> extends ConstructType<T> {\n  get typeName() {\n    return IdlTypeName.RecClass;\n  }\n\n  private static _counter = 0;\n  private _id = RecClass._counter++;\n  private _type: ConstructType<T> | undefined;\n\n  static [Symbol.hasInstance](instance: any): instance is RecClass {\n    return instance.typeName === IdlTypeName.RecClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return v.visitRec(this, this._type, d);\n  }\n\n  public fill(t: ConstructType<T>) {\n    this._type = t;\n  }\n\n  public getType() {\n    return this._type;\n  }\n\n  public covariant(x: any): x is T {\n    if (this._type ? this._type.covariant(x) : false) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.encodeValue(x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    typeTable.add(this, new Uint8Array([]));\n    this._type.buildTypeTable(typeTable);\n    typeTable.merge(this, this._type.name);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.decodeValue(b, t);\n  }\n\n  get name() {\n    return `rec_${this._id}`;\n  }\n\n  public display() {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return `μ${this.name}.${this._type.name}`;\n  }\n\n  public valueToString(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.valueToString(x);\n  }\n}\n\nfunction decodePrincipalId(b: Pipe): PrincipalId {\n  const x = safeReadUint8(b);\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n\n  const len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType<PrincipalId> {\n  get typeName() {\n    return IdlTypeName.PrincipalClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is PrincipalClass {\n    return instance.typeName === IdlTypeName.PrincipalClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitPrincipal(this, d);\n  }\n\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): Uint8Array {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Principal);\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    this.checkType(t);\n    return decodePrincipalId(b);\n  }\n\n  get name() {\n    return 'principal';\n  }\n  public valueToString(x: PrincipalId) {\n    return `${this.name} \"${x.toText()}\"`;\n  }\n}\n\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass extends ConstructType<[PrincipalId, string]> {\n  get typeName() {\n    return IdlTypeName.FuncClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FuncClass {\n    return instance.typeName === IdlTypeName.FuncClass;\n  }\n\n  public static argsToString(types: Type[], v: any[]) {\n    if (types.length !== v.length) {\n      throw new Error('arity mismatch');\n    }\n    return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n  }\n\n  constructor(\n    public argTypes: Type[],\n    public retTypes: Type[],\n    public annotations: string[] = [],\n  ) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFunc(this, d);\n  }\n  public covariant(x: any): x is [PrincipalId, string] {\n    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n      return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue([principal, methodName]: [PrincipalId, string]) {\n    const buf = principal.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    const canister = concat(new Uint8Array([1]), len, buf);\n\n    const method = new TextEncoder().encode(methodName);\n    const methodLen = lebEncode(method.byteLength);\n    return concat(new Uint8Array([1]), canister, methodLen, method);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this.argTypes.forEach(arg => arg.buildTypeTable(T));\n    this.retTypes.forEach(arg => arg.buildTypeTable(T));\n\n    const opCode = slebEncode(IDLTypeIds.Func);\n    const argLen = lebEncode(this.argTypes.length);\n    const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n    const retLen = lebEncode(this.retTypes.length);\n    const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n    const annLen = lebEncode(this.annotations.length);\n    const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n\n    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [PrincipalId, string] {\n    const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n    if (!subtype(tt, this)) {\n      throw new Error(\n        `Cannot decode function reference at type ${this.display()} from wire type ${tt.display()}`,\n      );\n    }\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n      throw new Error('Cannot decode function reference');\n    }\n    const canister = decodePrincipalId(b);\n\n    const mLen = Number(lebDecode(b));\n    const buf = safeRead(b, mLen);\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    const method = decoder.decode(buf);\n\n    return [canister, method];\n  }\n\n  get name() {\n    const args = this.argTypes.map(arg => arg.name).join(', ');\n    const rets = this.retTypes.map(arg => arg.name).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) -> (${rets})${annon}`;\n  }\n\n  public valueToString([principal, str]: [PrincipalId, string]) {\n    return `func \"${principal.toText()}\".${str}`;\n  }\n\n  public display(): string {\n    const args = this.argTypes.map(arg => arg.display()).join(', ');\n    const rets = this.retTypes.map(arg => arg.display()).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) → (${rets})${annon}`;\n  }\n\n  private encodeAnnotation(ann: string): Uint8Array {\n    if (ann === 'query') {\n      return new Uint8Array([1]);\n    } else if (ann === 'oneway') {\n      return new Uint8Array([2]);\n    } else if (ann === 'composite_query') {\n      return new Uint8Array([3]);\n    } else {\n      throw new Error('Illegal function annotation');\n    }\n  }\n}\n\nexport class ServiceClass extends ConstructType<PrincipalId> {\n  get typeName() {\n    return IdlTypeName.ServiceClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is ServiceClass {\n    return instance.typeName === IdlTypeName.ServiceClass;\n  }\n\n  public readonly _fields: Array<[string, FuncClass]>;\n  constructor(fields: Record<string, FuncClass>) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => {\n      if (a[0] < b[0]) {\n        return -1;\n      }\n      if (a[0] > b[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitService(this, d);\n  }\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): Uint8Array {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.length);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Service);\n    const len = lebEncode(this._fields.length);\n    const meths = this._fields.map(([label, func]) => {\n      const labelBuf = new TextEncoder().encode(label);\n      const labelLen = lebEncode(labelBuf.length);\n      return concat(labelLen, labelBuf, func.encodeType(T));\n    });\n\n    T.add(this, concat(opCode, len, ...meths));\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n    if (!subtype(tt, this)) {\n      throw new Error(\n        `Cannot decode service reference at type ${this.display()} from wire type ${tt.display()}`,\n      );\n    }\n    return decodePrincipalId(b);\n  }\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `service {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: PrincipalId) {\n    return `service \"${x.toText()}\"`;\n  }\n\n  public fieldsAsObject() {\n    const fields: Record<string, Type> = {};\n    for (const [name, ty] of this._fields) {\n      fields[name] = ty;\n    }\n    return fields;\n  }\n}\n\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x: unknown): string {\n  const str = JSON.stringify(x, (_key, value) =>\n    typeof value === 'bigint' ? `BigInt(${value})` : value,\n  );\n\n  return str && str.length > toReadableString_max\n    ? str.substring(0, toReadableString_max - 3) + '...'\n    : str;\n}\n\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {Uint8Array} serialised value\n */\nexport function encode(argTypes: Array<Type<any>>, args: any[]): Uint8Array {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n\n  const typeTable = new TypeTable();\n  argTypes.forEach(t => t.buildTypeTable(typeTable));\n\n  const magic = new TextEncoder().encode(magicNumber);\n  const table = typeTable.encode();\n  const len = lebEncode(args.length);\n  const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n  const vals = concat(\n    ...zipWith(argTypes, args, (t, x) => {\n      try {\n        t.covariant(x);\n      } catch (e: any) {\n        const err = new Error(e.message + '\\n\\n');\n        throw err;\n      }\n\n      return t.encodeValue(x);\n    }),\n  );\n\n  return concat(magic, table, len, typs, vals);\n}\n\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes: Type[], bytes: Uint8Array): JsonValue[] {\n  const b = new Pipe(bytes);\n\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n  const magicBuffer = safeRead(b, magicNumber.length);\n  const magic = new TextDecoder().decode(magicBuffer);\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n\n  function readTypeTable(pipe: Pipe): [Array<[IDLTypeIds, any]>, number[]] {\n    const typeTable: Array<[IDLTypeIds, any]> = [];\n    const len = Number(lebDecode(pipe));\n\n    for (let i = 0; i < len; i++) {\n      const ty = Number(slebDecode(pipe));\n      switch (ty) {\n        case IDLTypeIds.Opt:\n        case IDLTypeIds.Vector: {\n          const t = Number(slebDecode(pipe));\n          typeTable.push([ty, t]);\n          break;\n        }\n        case IDLTypeIds.Record:\n        case IDLTypeIds.Variant: {\n          const fields = [];\n          let objectLength = Number(lebDecode(pipe));\n          let prevHash;\n          while (objectLength--) {\n            const hash = Number(lebDecode(pipe));\n            if (hash >= Math.pow(2, 32)) {\n              throw new Error('field id out of 32-bit range');\n            }\n            if (typeof prevHash === 'number' && prevHash >= hash) {\n              throw new Error('field id collision or not sorted');\n            }\n            prevHash = hash;\n            const t = Number(slebDecode(pipe));\n            fields.push([hash, t]);\n          }\n          typeTable.push([ty, fields]);\n          break;\n        }\n        case IDLTypeIds.Func: {\n          const args = [];\n          let argLength = Number(lebDecode(pipe));\n          while (argLength--) {\n            args.push(Number(slebDecode(pipe)));\n          }\n          const returnValues = [];\n          let returnValuesLength = Number(lebDecode(pipe));\n          while (returnValuesLength--) {\n            returnValues.push(Number(slebDecode(pipe)));\n          }\n          const annotations = [];\n          let annotationLength = Number(lebDecode(pipe));\n          while (annotationLength--) {\n            const annotation = Number(lebDecode(pipe));\n            switch (annotation) {\n              case 1: {\n                annotations.push('query');\n                break;\n              }\n              case 2: {\n                annotations.push('oneway');\n                break;\n              }\n              case 3: {\n                annotations.push('composite_query');\n                break;\n              }\n              default:\n                throw new Error('unknown annotation');\n            }\n          }\n          typeTable.push([ty, [args, returnValues, annotations]]);\n          break;\n        }\n        case IDLTypeIds.Service: {\n          let servLength = Number(lebDecode(pipe));\n          const methods = [];\n          while (servLength--) {\n            const nameLength = Number(lebDecode(pipe));\n            const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));\n            const funcType = slebDecode(pipe);\n            methods.push([funcName, funcType]);\n          }\n          typeTable.push([ty, methods]);\n          break;\n        }\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n\n    const rawList: number[] = [];\n    const length = Number(lebDecode(pipe));\n    for (let i = 0; i < length; i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n    return [typeTable, rawList];\n  }\n  const [rawTable, rawTypes] = readTypeTable(b);\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n\n  const table: RecClass[] = rawTable.map(_ => Rec());\n  function getType(t: number): Type {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n        case -2:\n          return Bool;\n        case -3:\n          return Nat;\n        case -4:\n          return Int;\n        case -5:\n          return Nat8;\n        case -6:\n          return Nat16;\n        case -7:\n          return Nat32;\n        case -8:\n          return Nat64;\n        case -9:\n          return Int8;\n        case -10:\n          return Int16;\n        case -11:\n          return Int32;\n        case -12:\n          return Int64;\n        case -13:\n          return Float32;\n        case -14:\n          return Float64;\n        case -15:\n          return Text;\n        case -16:\n          return Reserved;\n        case -17:\n          return Empty;\n        case -24:\n          return Principal;\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n    return table[t];\n  }\n  function buildType(entry: [IDLTypeIds, any]): Type {\n    switch (entry[0]) {\n      case IDLTypeIds.Vector: {\n        const ty = getType(entry[1]);\n        return Vec(ty);\n      }\n      case IDLTypeIds.Opt: {\n        const ty = getType(entry[1]);\n        return Opt(ty);\n      }\n      case IDLTypeIds.Record: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        const record = Record(fields);\n        const tuple = record.tryAsTuple();\n        if (Array.isArray(tuple)) {\n          return Tuple(...tuple);\n        } else {\n          return record;\n        }\n      }\n      case IDLTypeIds.Variant: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        return Variant(fields);\n      }\n      case IDLTypeIds.Func: {\n        const [args, returnValues, annotations] = entry[1];\n        return Func(\n          args.map((t: number) => getType(t)),\n          returnValues.map((t: number) => getType(t)),\n          annotations,\n        );\n      }\n      case IDLTypeIds.Service: {\n        const rec: Record<string, FuncClass> = {};\n        const methods = entry[1] as [[string, number]];\n        for (const [name, typeRef] of methods) {\n          let type: Type | undefined = getType(typeRef);\n\n          if (type instanceof RecClass) {\n            // unpack reference type\n            type = type.getType();\n          }\n          if (!(type instanceof FuncClass)) {\n            throw new Error('Illegal service definition: services can only contain functions');\n          }\n          rec[name] = type;\n        }\n        return Service(rec);\n      }\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n\n  rawTable.forEach((entry, i) => {\n    // Process function type first, so that we can construct the correct service type\n    if (entry[0] === IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  rawTable.forEach((entry, i) => {\n    if (entry[0] !== IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n\n  resetSubtypeCache();\n  const types = rawTypes.map(t => getType(t));\n  try {\n    const output = retTypes.map((t, i) => {\n      return t.decodeValue(b, types[i]);\n    });\n\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n      types[ind].decodeValue(b, types[ind]);\n    }\n\n    if (b.byteLength > 0) {\n      throw new Error('decode: Left-over bytes');\n    }\n\n    return output;\n  } finally {\n    resetSubtypeCache();\n  }\n}\n\n/**\n * An Interface Factory, normally provided by a Candid code generation.\n */\nexport type InterfaceFactory = (idl: {\n  IDL: {\n    Empty: EmptyClass;\n    Reserved: ReservedClass;\n    Unknown: UnknownClass;\n    Bool: BoolClass;\n    Null: NullClass;\n    Text: TextClass;\n    Int: IntClass;\n    Nat: NatClass;\n\n    Float32: FloatClass;\n    Float64: FloatClass;\n\n    Int8: FixedIntClass;\n    Int16: FixedIntClass;\n    Int32: FixedIntClass;\n    Int64: FixedIntClass;\n\n    Nat8: FixedNatClass;\n    Nat16: FixedNatClass;\n    Nat32: FixedNatClass;\n    Nat64: FixedNatClass;\n\n    Principal: PrincipalClass;\n\n    Tuple: typeof Tuple;\n    Vec: typeof Vec;\n    Opt: typeof Opt;\n    Record: typeof Record;\n    Variant: typeof Variant;\n    Rec: typeof Rec;\n    Func: typeof Func;\n\n    Service(t: Record<string, FuncClass>): ServiceClass;\n  };\n}) => ServiceClass;\n\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nexport const Unknown = new UnknownClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\n\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\n\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\n\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\n\nexport const Principal = new PrincipalClass();\n\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple<T extends any[]>(...types: T): TupleClass<T> {\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec<T>(t: Type<T>): VecClass<T> {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt<T>(t: Type<T>): OptClass<T> {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t: Record<string, Type>): RecordClass {\n  return new RecordClass(t);\n}\n\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields: Record<string, Type>): VariantClass {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec(): RecClass {\n  return new RecClass();\n}\n\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func(args: Type[], ret: Type[], annotations: string[] = []): FuncClass {\n  return new FuncClass(args, ret, annotations);\n}\n\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service(t: Record<string, FuncClass>): ServiceClass {\n  return new ServiceClass(t);\n}\n\n/**\n * The list of relations between types we assume to hold. Uses the types .name property as key\n */\nclass Relations {\n  private rels: Map<string, Map<string, boolean>>;\n\n  constructor(relations = new Map()) {\n    this.rels = relations;\n  }\n\n  copy(): Relations {\n    const copy = new Map();\n    for (const [key, value] of this.rels.entries()) {\n      const valCopy = new Map(value);\n      copy.set(key, valCopy);\n    }\n    return new Relations(copy);\n  }\n\n  /// Returns whether we know for sure that a relation holds or doesn't (`true` or `false`), or\n  /// if we don't know yet (`undefined`)\n  known(t1: Type, t2: Type): boolean | undefined {\n    return this.rels.get(t1.name)?.get(t2.name);\n  }\n\n  addNegative(t1: Type, t2: Type) {\n    this.addNames(t1.name, t2.name, false);\n  }\n\n  add(t1: Type, t2: Type) {\n    this.addNames(t1.name, t2.name, true);\n  }\n\n  display(): string {\n    let result = '';\n    for (const [t1, v] of this.rels) {\n      for (const [t2, known] of v) {\n        const subty = known ? ':<' : '!<:';\n        result += `${t1} ${subty} ${t2}\\n`;\n      }\n    }\n    return result;\n  }\n\n  private addNames(t1: string, t2: string, isSubtype: boolean) {\n    const t1Map = this.rels.get(t1);\n    if (t1Map == undefined) {\n      const newMap = new Map();\n      newMap.set(t2, isSubtype);\n      this.rels.set(t1, newMap);\n    } else {\n      t1Map.set(t2, isSubtype);\n    }\n  }\n}\n\n/// `subtypeCache` holds subtyping relations we've previously computed while decoding a message\nlet subtypeCache: Relations = new Relations();\n\n/** Resets the global subtyping cache */\nexport function resetSubtypeCache() {\n  subtypeCache = new Relations();\n}\n\nfunction eqFunctionAnnotations(t1: FuncClass, t2: FuncClass): boolean {\n  const t1Annotations = new Set(t1.annotations);\n  const t2Annotations = new Set(t2.annotations);\n  if (t1Annotations.size !== t2Annotations.size) {\n    return false;\n  }\n  for (const a of t1Annotations) {\n    if (!t2Annotations.has(a)) return false;\n  }\n  return true;\n}\n\nfunction canBeOmmitted(t: Type) {\n  return t instanceof OptClass || t instanceof NullClass || t instanceof ReservedClass;\n}\n\n/**\n * Subtyping on Candid types t1 <: t2 (Exported for testing)\n * @param t1 The potential subtype\n * @param t2 The potential supertype\n */\nexport function subtype(t1: Type, t2: Type): boolean {\n  const relations = subtypeCache.copy();\n  const isSubtype = subtype_(relations, t1, t2);\n  if (isSubtype) {\n    subtypeCache.add(t1, t2);\n  } else {\n    subtypeCache.addNegative(t1, t2);\n  }\n  return isSubtype;\n}\n\nfunction subtype_(relations: Relations, t1: Type, t2: Type): boolean {\n  if (t1.name === t2.name) return true;\n  const known = relations.known(t1, t2);\n  if (known !== undefined) return known;\n  relations.add(t1, t2);\n\n  if (t2 instanceof ReservedClass) return true;\n  if (t1 instanceof EmptyClass) return true;\n  if (t1 instanceof NatClass && t2 instanceof IntClass) return true;\n  if (t1 instanceof VecClass && t2 instanceof VecClass)\n    return subtype_(relations, t1._type, t2._type);\n  if (t2 instanceof OptClass) return true;\n  if (t1 instanceof RecordClass && t2 instanceof RecordClass) {\n    const t1Object = t1.fieldsAsObject;\n    for (const [label, ty2] of t2._fields) {\n      const ty1 = t1Object[idlLabelToId(label)];\n      if (!ty1) {\n        if (!canBeOmmitted(ty2)) return false;\n      } else {\n        if (!subtype_(relations, ty1, ty2)) return false;\n      }\n    }\n    return true;\n  }\n\n  if (t1 instanceof FuncClass && t2 instanceof FuncClass) {\n    if (!eqFunctionAnnotations(t1, t2)) return false;\n    for (let i = 0; i < t1.argTypes.length; i++) {\n      const argTy1 = t1.argTypes[i];\n      if (i < t2.argTypes.length) {\n        if (!subtype_(relations, t2.argTypes[i], argTy1)) return false;\n      } else {\n        if (!canBeOmmitted(argTy1)) return false;\n      }\n    }\n    for (let i = 0; i < t2.retTypes.length; i++) {\n      const retTy2 = t2.retTypes[i];\n      if (i < t1.retTypes.length) {\n        if (!subtype_(relations, t1.retTypes[i], retTy2)) return false;\n      } else {\n        if (!canBeOmmitted(retTy2)) return false;\n      }\n    }\n    return true;\n  }\n\n  if (t1 instanceof VariantClass && t2 instanceof VariantClass) {\n    const t2Object = t2.alternativesAsObject;\n    for (const [label, ty1] of t1._fields) {\n      const ty2 = t2Object[idlLabelToId(label)];\n      if (!ty2) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n\n  if (t1 instanceof ServiceClass && t2 instanceof ServiceClass) {\n    const t1Object = t1.fieldsAsObject();\n    for (const [name, ty2] of t2._fields) {\n      const ty1 = t1Object[name];\n      if (!ty1) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n\n  if (t1 instanceof RecClass) {\n    return subtype_(relations, t1.getType()!, t2);\n  }\n  if (t2 instanceof RecClass) {\n    return subtype_(relations, t1, t2.getType()!);\n  }\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}