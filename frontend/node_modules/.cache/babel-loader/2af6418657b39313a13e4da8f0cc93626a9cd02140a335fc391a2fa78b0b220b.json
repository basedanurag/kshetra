{"ast":null,"code":"import { Principal } from '@dfinity/principal';\nimport { HashTreeDecodeErrorCode, CreateHttpAgentErrorCode, ExternalError, HttpDefaultFetchErrorCode, IdentityInvalidErrorCode, IngressExpiryInvalidErrorCode, InputError, LookupErrorCode, MalformedPublicKeyErrorCode, MalformedSignatureErrorCode, MissingRootKeyErrorCode, MissingSignatureErrorCode, ProtocolError, QuerySignatureVerificationFailedErrorCode, TimeoutWaitingForResponseErrorCode, TrustError, UnexpectedErrorCode, UnknownError, HttpErrorCode, HttpV3ApiNotSupportedErrorCode, TransportError, HttpFetchErrorCode, AgentError, MalformedLookupFoundValueErrorCode, CertificateOutdatedErrorCode } from \"../../errors.js\";\nimport { AnonymousIdentity } from \"../../auth.js\";\nimport * as cbor from \"../../cbor.js\";\nimport { hashOfMap, requestIdOf } from \"../../request_id.js\";\nimport { QueryResponseStatus } from \"../api.js\";\nimport { Expiry, httpHeadersTransform, makeNonceTransform } from \"./transforms.js\";\nimport { Endpoint, makeNonce, ReadRequestType, SubmitRequestType } from \"./types.js\";\nimport { request as canisterStatusRequest } from \"../../canisterStatus/index.js\";\nimport { lookup_path, LookupPathStatus } from \"../../certificate.js\";\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { ExpirableMap } from \"../../utils/expirableMap.js\";\nimport { Ed25519PublicKey } from \"../../public_key.js\";\nimport { ObservableLog } from \"../../observable.js\";\nimport { ExponentialBackoff } from \"../../polling/backoff.js\";\nimport { decodeTime } from \"../../utils/leb.js\";\nimport { concatBytes, hexToBytes } from '@noble/hashes/utils';\nimport { uint8Equals, uint8FromBufLike } from \"../../utils/buffer.js\";\nimport { IC_RESPONSE_DOMAIN_SEPARATOR } from \"../../constants.js\";\nexport * from \"./transforms.js\";\nexport { makeNonce } from \"./types.js\";\nexport var RequestStatusResponseStatus;\n(function (RequestStatusResponseStatus) {\n  RequestStatusResponseStatus[\"Received\"] = \"received\";\n  RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n  RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n  RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n  RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n  RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));\nconst MINUTE_TO_MSECS = 60 * 1_000;\nconst MSECS_TO_NANOSECONDS = 1_000_000;\n// Root public key for the IC, encoded as hex\nexport const IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' + 'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' + '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' + 'b01291091c5f87b98883463f98091a0baaae';\nexport const MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\nconst HTTP_STATUS_OK = 200;\nconst HTTP_STATUS_ACCEPTED = 202;\nconst HTTP_STATUS_NOT_FOUND = 404;\nfunction getDefaultFetch() {\n  let defaultFetch;\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw ExternalError.fromCode(new HttpDefaultFetchErrorCode('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.'));\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw ExternalError.fromCode(new HttpDefaultFetchErrorCode('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.'));\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw ExternalError.fromCode(new HttpDefaultFetchErrorCode('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.'));\n}\nfunction determineHost(configuredHost) {\n  let host;\n  if (configuredHost !== undefined) {\n    if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n      host = new URL(window.location.protocol + '//' + configuredHost);\n    } else {\n      host = new URL(configuredHost);\n    }\n  } else {\n    // Mainnet, local, and remote environments will have the api route available\n    const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n    const remoteHosts = ['.github.dev', '.gitpod.io'];\n    const location = typeof window !== 'undefined' ? window.location : undefined;\n    const hostname = location?.hostname;\n    let knownHost;\n    if (hostname && typeof hostname === 'string') {\n      if (remoteHosts.some(host => hostname.endsWith(host))) {\n        knownHost = hostname;\n      } else {\n        knownHost = knownHosts.find(host => hostname.endsWith(host));\n      }\n    }\n    if (location && knownHost) {\n      // If the user is on a boundary-node provided host, we can use the same host for the agent\n      host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);\n    } else {\n      host = new URL('https://icp-api.io');\n    }\n  }\n  return host.toString();\n}\n/**\n * A HTTP agent allows users to interact with a client of the internet computer\nusing the available methods. It exposes an API that closely follows the\npublic view of the internet computer, and is not intended to be exposed\ndirectly to the majority of users due to its low-level interface.\n * There is a pipeline to apply transformations to the request before sending\nit to the client. This is to decouple signature, nonce generation and\nother computations so that this class can stay as simple as possible while\nallowing extensions.\n */\nexport class HttpAgent {\n  #rootKeyPromise;\n  #shouldFetchRootKey;\n  #timeDiffMsecs;\n  #syncTimePromise;\n  #shouldSyncTime;\n  #identity;\n  #fetch;\n  #fetchOptions;\n  #callOptions;\n  #credentials;\n  #retryTimes; // Retry requests N times before erroring by default\n  #backoffStrategy;\n  #maxIngressExpiryInMinutes;\n  get #maxIngressExpiryInMs() {\n    return this.#maxIngressExpiryInMinutes * MINUTE_TO_MSECS;\n  }\n  #queryPipeline;\n  #updatePipeline;\n  #subnetKeys;\n  #verifyQuerySignatures;\n  /**\n   * @param options - Options for the HttpAgent\n   * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead\n   */\n  constructor(options = {}) {\n    this.#rootKeyPromise = null;\n    this.#shouldFetchRootKey = false;\n    this.#timeDiffMsecs = 0;\n    this.#syncTimePromise = null;\n    this.#shouldSyncTime = false;\n    // Public signature to help with type checking.\n    this._isAgent = true;\n    this.config = {};\n    this.log = new ObservableLog();\n    this.#queryPipeline = [];\n    this.#updatePipeline = [];\n    this.#subnetKeys = new ExpirableMap({\n      expirationTime: 5 * 60 * 1000 // 5 minutes\n    });\n    this.#verifyQuerySignatures = true;\n    /**\n     * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n     * @param queryResponse - The response from the query\n     * @param subnetStatus - The subnet status, including all node keys\n     * @returns ApiQueryResponse\n     */\n    this.#verifyQueryResponse = (queryResponse, subnetStatus) => {\n      if (this.#verifyQuerySignatures === false) {\n        // This should not be called if the user has disabled verification\n        return queryResponse;\n      }\n      if (!subnetStatus) {\n        throw TrustError.fromCode(new MissingSignatureErrorCode());\n      }\n      const {\n        status,\n        signatures = [],\n        requestId\n      } = queryResponse;\n      for (const sig of signatures) {\n        const {\n          timestamp,\n          identity\n        } = sig;\n        const nodeId = Principal.fromUint8Array(identity).toText();\n        // Hash is constructed differently depending on the status\n        let hash;\n        if (status === QueryResponseStatus.Replied) {\n          const {\n            reply\n          } = queryResponse;\n          hash = hashOfMap({\n            status: status,\n            reply: reply,\n            timestamp: BigInt(timestamp),\n            request_id: requestId\n          });\n        } else if (status === QueryResponseStatus.Rejected) {\n          const {\n            reject_code,\n            reject_message,\n            error_code\n          } = queryResponse;\n          hash = hashOfMap({\n            status: status,\n            reject_code: reject_code,\n            reject_message: reject_message,\n            error_code: error_code,\n            timestamp: BigInt(timestamp),\n            request_id: requestId\n          });\n        } else {\n          throw UnknownError.fromCode(new UnexpectedErrorCode(`Unknown status: ${status}`));\n        }\n        const separatorWithHash = concatBytes(IC_RESPONSE_DOMAIN_SEPARATOR, hash);\n        // FIX: check for match without verifying N times\n        const pubKey = subnetStatus.nodeKeys.get(nodeId);\n        if (!pubKey) {\n          throw ProtocolError.fromCode(new MalformedPublicKeyErrorCode());\n        }\n        const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;\n        const valid = ed25519.verify(sig.signature, separatorWithHash, rawKey);\n        if (valid) return queryResponse;\n        throw TrustError.fromCode(new QuerySignatureVerificationFailedErrorCode(nodeId));\n      }\n      return queryResponse;\n    };\n    this.config = options;\n    this.#fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n    this.#fetchOptions = options.fetchOptions;\n    this.#callOptions = options.callOptions;\n    this.#shouldFetchRootKey = options.shouldFetchRootKey ?? false;\n    this.#shouldSyncTime = options.shouldSyncTime ?? false;\n    // Use provided root key, otherwise fall back to IC_ROOT_KEY for mainnet or null if the key needs to be fetched\n    if (options.rootKey) {\n      this.rootKey = options.rootKey;\n    } else if (this.#shouldFetchRootKey) {\n      this.rootKey = null;\n    } else {\n      this.rootKey = hexToBytes(IC_ROOT_KEY);\n    }\n    const host = determineHost(options.host);\n    this.host = new URL(host);\n    if (options.verifyQuerySignatures !== undefined) {\n      this.#verifyQuerySignatures = options.verifyQuerySignatures;\n    }\n    // Default is 3\n    this.#retryTimes = options.retryTimes ?? 3;\n    // Delay strategy for retries. Default is exponential backoff\n    const defaultBackoffFactory = () => new ExponentialBackoff({\n      maxIterations: this.#retryTimes\n    });\n    this.#backoffStrategy = options.backoffStrategy || defaultBackoffFactory;\n    // Rewrite to avoid redirects\n    if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this.host.hostname = IC0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this.host.hostname = ICP0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this.host.hostname = ICP_API_DOMAIN;\n    }\n    if (options.credentials) {\n      const {\n        name,\n        password\n      } = options.credentials;\n      this.#credentials = `${name}${password ? ':' + password : ''}`;\n    }\n    this.#identity = Promise.resolve(options.identity || new AnonymousIdentity());\n    if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes > 5) {\n      throw InputError.fromCode(new IngressExpiryInvalidErrorCode('The maximum ingress expiry time is 5 minutes.', options.ingressExpiryInMinutes));\n    }\n    if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes <= 0) {\n      throw InputError.fromCode(new IngressExpiryInvalidErrorCode('Ingress expiry time must be greater than 0.', options.ingressExpiryInMinutes));\n    }\n    this.#maxIngressExpiryInMinutes = options.ingressExpiryInMinutes || 5;\n    // Add a nonce transform to ensure calls are unique\n    this.addTransform('update', makeNonceTransform(makeNonce));\n    if (options.useQueryNonces) {\n      this.addTransform('query', makeNonceTransform(makeNonce));\n    }\n    if (options.logToConsole) {\n      this.log.subscribe(log => {\n        if (log.level === 'error') {\n          console.error(log.message);\n        } else if (log.level === 'warn') {\n          console.warn(log.message);\n        } else {\n          console.log(log.message);\n        }\n      });\n    }\n  }\n  static createSync(options = {}) {\n    return new this({\n      ...options\n    });\n  }\n  static async create(options = {}) {\n    const agent = HttpAgent.createSync(options);\n    await agent.#asyncGuard();\n    return agent;\n  }\n  static async from(agent) {\n    try {\n      if ('config' in agent) {\n        return await HttpAgent.create(agent.config);\n      }\n      return await HttpAgent.create({\n        fetch: agent._fetch,\n        fetchOptions: agent._fetchOptions,\n        callOptions: agent._callOptions,\n        host: agent._host.toString(),\n        identity: agent._identity ?? undefined\n      });\n    } catch {\n      throw InputError.fromCode(new CreateHttpAgentErrorCode());\n    }\n  }\n  isLocal() {\n    const hostname = this.host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n  }\n  addTransform(type, fn, priority = fn.priority || 0) {\n    if (type === 'update') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#updatePipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#updatePipeline.splice(i >= 0 ? i : this.#updatePipeline.length, 0, Object.assign(fn, {\n        priority\n      }));\n    } else if (type === 'query') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#queryPipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#queryPipeline.splice(i >= 0 ? i : this.#queryPipeline.length, 0, Object.assign(fn, {\n        priority\n      }));\n    }\n  }\n  async getPrincipal() {\n    if (!this.#identity) {\n      throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n    }\n    return (await this.#identity).getPrincipal();\n  }\n  /**\n   * Makes a call to a canister method.\n   * @param canisterId - The ID of the canister to call. Can be a Principal or a string.\n   * @param options - Options for the call.\n   * @param options.methodName - The name of the method to call.\n   * @param options.arg - The argument to pass to the method, as a Uint8Array.\n   * @param options.effectiveCanisterId - (Optional) The effective canister ID, if different from the target canister ID.\n   * @param options.callSync - (Optional) Whether to use synchronous call mode. Defaults to true.\n   * @param options.nonce - (Optional) A unique nonce for the request. If provided, it will override any nonce set by transforms.\n   * @param identity - (Optional) The identity to use for the call. If not provided, the agent's current identity will be used.\n   * @returns A promise that resolves to the response of the call, including the request ID and response details.\n   */\n  async call(canisterId, options, identity) {\n    // TODO - restore this value\n    const callSync = options.callSync ?? true;\n    const id = await (identity ?? this.#identity);\n    if (!id) {\n      throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId ? Principal.from(options.effectiveCanisterId) : canister;\n    await this.#asyncGuard(ecid);\n    const sender = id.getPrincipal();\n    const ingress_expiry = calculateIngressExpiry(this.#maxIngressExpiryInMinutes, this.#timeDiffMsecs);\n    const submit = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry\n    };\n    let transformedRequest = await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? {\n            Authorization: 'Basic ' + btoa(this.#credentials)\n          } : {})\n        }\n      },\n      endpoint: Endpoint.Call,\n      body: submit\n    });\n    // Determine the nonce to use for the request\n    let nonce;\n    // Check if a nonce is provided in the options and convert it to the correct type\n    if (options?.nonce) {\n      nonce = toNonce(options.nonce);\n    }\n    // If no nonce is provided in the options, check the transformedRequest body\n    else if (transformedRequest.body.nonce) {\n      nonce = toNonce(transformedRequest.body.nonce);\n    }\n    // If no nonce is found, set it to undefined\n    else {\n      nonce = undefined;\n    }\n    // Assign the determined nonce to the submit object\n    submit.nonce = nonce;\n    /**\n     * Converts a Uint8Array to a Nonce type.\n     * @param buf - The buffer to convert.\n     * @returns The buffer as a Nonce.\n     */\n    function toNonce(buf) {\n      return Object.assign(buf, {\n        __nonce__: undefined\n      });\n    }\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n    const body = cbor.encode(transformedRequest.body);\n    const backoff = this.#backoffStrategy();\n    const requestId = requestIdOf(submit);\n    try {\n      // Attempt v3 sync call\n      const requestSync = () => {\n        this.log.print(`fetching \"/api/v3/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n        return this.#fetch('' + new URL(`/api/v3/canister/${ecid.toText()}/call`, this.host), {\n          ...this.#callOptions,\n          ...transformedRequest.request,\n          body\n        });\n      };\n      const requestAsync = () => {\n        this.log.print(`fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n        return this.#fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), {\n          ...this.#callOptions,\n          ...transformedRequest.request,\n          body\n        });\n      };\n      const requestFn = callSync ? requestSync : requestAsync;\n      const {\n        responseBodyBytes,\n        ...response\n      } = await this.#requestAndRetry({\n        requestFn,\n        backoff,\n        tries: 0\n      });\n      const responseBody = responseBodyBytes.byteLength > 0 ? cbor.decode(responseBodyBytes) : null;\n      return {\n        requestId,\n        response: {\n          ...response,\n          body: responseBody\n        },\n        requestDetails: submit\n      };\n    } catch (error) {\n      let callError;\n      if (error instanceof AgentError) {\n        // If the error is due to the v3 api not being supported, fall back to v2\n        if (error.hasCode(HttpV3ApiNotSupportedErrorCode)) {\n          this.log.warn('v3 api not supported. Fall back to v2');\n          return this.call(canisterId, {\n            ...options,\n            // disable v3 api\n            callSync: false\n          }, identity);\n        } else if (error.hasCode(IngressExpiryInvalidErrorCode)) {\n          // if there is an ingress expiry error, sync time with the network and try again\n          await this.syncTime(canister);\n          return this.call(canister, options, identity);\n        } else {\n          // override the error code to include the request details\n          error.code.requestContext = {\n            requestId,\n            senderPubKey: transformedRequest.body.sender_pubkey,\n            senderSignature: transformedRequest.body.sender_sig,\n            ingressExpiry: transformedRequest.body.content.ingress_expiry\n          };\n          callError = error;\n        }\n      } else {\n        callError = UnknownError.fromCode(new UnexpectedErrorCode(error));\n      }\n      this.log.error(`Error while making call: ${callError.message}`, callError);\n      throw callError;\n    }\n  }\n  async #requestAndRetryQuery(args) {\n    const {\n      ecid,\n      transformedRequest,\n      body,\n      requestId,\n      backoff,\n      tries\n    } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n      tries,\n      backoff,\n      delay\n    });\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw UnknownError.fromCode(new TimeoutWaitingForResponseErrorCode(`Backoff strategy exhausted after ${tries} attempts.`, requestId));\n    }\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response;\n    // Make the request and retry if it throws an error\n    try {\n      this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`, transformedRequest);\n      const fetchResponse = await this.#fetch('' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host), {\n        ...this.#fetchOptions,\n        ...transformedRequest.request,\n        body\n      });\n      if (fetchResponse.status === HTTP_STATUS_OK) {\n        const queryResponse = cbor.decode(uint8FromBufLike(await fetchResponse.arrayBuffer()));\n        response = {\n          ...queryResponse,\n          httpDetails: {\n            ok: fetchResponse.ok,\n            status: fetchResponse.status,\n            statusText: fetchResponse.statusText,\n            headers: httpHeadersTransform(fetchResponse.headers)\n          },\n          requestId\n        };\n      } else {\n        throw ProtocolError.fromCode(new HttpErrorCode(fetchResponse.status, fetchResponse.statusText, httpHeadersTransform(fetchResponse.headers), await fetchResponse.text()));\n      }\n    } catch (error) {\n      if (tries < this.#retryTimes) {\n        this.log.warn(`Caught exception while attempting to make query:\\n` + `  ${error}\\n` + `  Retrying query.`);\n        return await this.#requestAndRetryQuery({\n          ...args,\n          tries: tries + 1\n        });\n      }\n      if (error instanceof AgentError) {\n        // if it's an error that we have thrown, just throw it as is\n        throw error;\n      }\n      // if it's an error that we have not thrown, wrap it in a TransportError\n      throw TransportError.fromCode(new HttpFetchErrorCode(error));\n    }\n    // Skip timestamp verification if the user has set verifyQuerySignatures to false\n    if (!this.#verifyQuerySignatures) {\n      return response;\n    }\n    const signatureTimestampNs = response.signatures?.[0]?.timestamp;\n    if (!signatureTimestampNs) {\n      throw ProtocolError.fromCode(new MalformedSignatureErrorCode('Timestamp not found in query response. This suggests a malformed or malicious response.'));\n    }\n    const signatureTimestampMs = Number(BigInt(signatureTimestampNs) / BigInt(MSECS_TO_NANOSECONDS));\n    const currentTimestampInMs = Date.now() + this.#timeDiffMsecs;\n    // We don't need `Math.abs` here because we allow signatures in the future\n    if (currentTimestampInMs - signatureTimestampMs > this.#maxIngressExpiryInMs) {\n      if (tries < this.#retryTimes) {\n        this.log.warn('Timestamp is older than the max ingress expiry. Retrying query.', {\n          requestId,\n          signatureTimestampMs\n        });\n        return await this.#requestAndRetryQuery({\n          ...args,\n          tries: tries + 1\n        });\n      }\n      throw TrustError.fromCode(new CertificateOutdatedErrorCode(this.#maxIngressExpiryInMinutes, requestId, tries));\n    }\n    return response;\n  }\n  /**\n   * Makes a request and retries if it fails.\n   * @param args - The arguments for the request.\n   * @param args.requestFn - A function that returns a Promise resolving to a Response.\n   * @param args.backoff - The backoff strategy to use for retries.\n   * @param args.tries - The number of retry attempts made so far.\n   * @returns The response from the request, if the status is 200 or 202.\n   * See the https://internetcomputer.org/docs/references/ic-interface-spec#http-interface for details on the response statuses.\n   * @throws {ProtocolError} if the response status is not 200 or 202, and the retry limit has been reached.\n   * @throws {TransportError} if the request fails, and the retry limit has been reached.\n   */\n  async #requestAndRetry(args) {\n    const {\n      requestFn,\n      backoff,\n      tries\n    } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw ProtocolError.fromCode(new TimeoutWaitingForResponseErrorCode(`Retry strategy exhausted after ${tries} attempts.`));\n    }\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response;\n    let responseBodyBytes = new Uint8Array();\n    try {\n      response = await requestFn();\n      // According to the spec, only 200 responses have a non-empty body\n      if (response.status === HTTP_STATUS_OK) {\n        // Consume the response body, to ensure that the response is not closed unexpectedly\n        responseBodyBytes = uint8FromBufLike(await response.clone().arrayBuffer());\n      }\n    } catch (error) {\n      if (tries < this.#retryTimes) {\n        this.log.warn(`Caught exception while attempting to make request:\\n` + `  ${error}\\n` + `  Retrying request.`);\n        // Delay the request by the configured backoff strategy\n        return await this.#requestAndRetry({\n          requestFn,\n          backoff,\n          tries: tries + 1\n        });\n      }\n      throw TransportError.fromCode(new HttpFetchErrorCode(error));\n    }\n    const headers = httpHeadersTransform(response.headers);\n    if (response.status === HTTP_STATUS_OK || response.status === HTTP_STATUS_ACCEPTED) {\n      return {\n        ok: response.ok,\n        // should always be true\n        status: response.status,\n        statusText: response.statusText,\n        responseBodyBytes,\n        headers\n      };\n    }\n    const responseText = await response.text();\n    if (response.status === HTTP_STATUS_NOT_FOUND && response.url.includes('api/v3')) {\n      throw ProtocolError.fromCode(new HttpV3ApiNotSupportedErrorCode());\n    }\n    // The error message comes from https://github.com/dfinity/ic/blob/23d5990bfc5277c32e54f0087b5a38fa412171e1/rs/validator/src/ingress_validation.rs#L233\n    if (responseText.startsWith('Invalid request expiry: ')) {\n      throw InputError.fromCode(new IngressExpiryInvalidErrorCode(responseText, this.#maxIngressExpiryInMinutes));\n    }\n    if (tries < this.#retryTimes) {\n      return await this.#requestAndRetry({\n        requestFn,\n        backoff,\n        tries: tries + 1\n      });\n    }\n    throw ProtocolError.fromCode(new HttpErrorCode(response.status, response.statusText, headers, responseText));\n  }\n  async query(canisterId, fields, identity) {\n    const backoff = this.#backoffStrategy();\n    const ecid = fields.effectiveCanisterId ? Principal.from(fields.effectiveCanisterId) : Principal.from(canisterId);\n    await this.#asyncGuard(ecid);\n    this.log.print(`ecid ${ecid.toString()}`);\n    this.log.print(`canisterId ${canisterId.toString()}`);\n    let transformedRequest;\n    const id = await (identity ?? this.#identity);\n    if (!id) {\n      throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n    }\n    const canister = Principal.from(canisterId);\n    const sender = id.getPrincipal();\n    const ingressExpiry = calculateIngressExpiry(this.#maxIngressExpiryInMinutes, this.#timeDiffMsecs);\n    const request = {\n      request_type: ReadRequestType.Query,\n      canister_id: canister,\n      method_name: fields.methodName,\n      arg: fields.arg,\n      sender,\n      ingress_expiry: ingressExpiry\n    };\n    const requestId = requestIdOf(request);\n    transformedRequest = await this._transform({\n      request: {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? {\n            Authorization: 'Basic ' + btoa(this.#credentials)\n          } : {})\n        }\n      },\n      endpoint: Endpoint.Query,\n      body: request\n    });\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n    const body = cbor.encode(transformedRequest.body);\n    const args = {\n      canister: canister.toText(),\n      ecid,\n      transformedRequest,\n      body,\n      requestId,\n      backoff,\n      tries: 0\n    };\n    const makeQuery = async () => {\n      return {\n        requestDetails: request,\n        query: await this.#requestAndRetryQuery(args)\n      };\n    };\n    const getSubnetStatus = async () => {\n      if (!this.#verifyQuerySignatures) {\n        return undefined;\n      }\n      const subnetStatus = this.#subnetKeys.get(ecid.toString());\n      if (subnetStatus) {\n        return subnetStatus;\n      }\n      await this.fetchSubnetKeys(ecid.toString());\n      return this.#subnetKeys.get(ecid.toString());\n    };\n    // Attempt to make the query i=retryTimes times\n    // Make query and fetch subnet keys in parallel\n    try {\n      const [queryResult, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n      const {\n        requestDetails,\n        query\n      } = queryResult;\n      const queryWithDetails = {\n        ...query,\n        requestDetails\n      };\n      this.log.print('Query response:', queryWithDetails);\n      // Skip verification if the user has disabled it\n      if (!this.#verifyQuerySignatures) {\n        return queryWithDetails;\n      }\n      try {\n        return this.#verifyQueryResponse(queryWithDetails, subnetStatus);\n      } catch {\n        // In case the node signatures have changed, refresh the subnet keys and try again\n        this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n        this.#subnetKeys.delete(canisterId.toString());\n        await this.fetchSubnetKeys(ecid.toString());\n        const updatedSubnetStatus = this.#subnetKeys.get(canisterId.toString());\n        if (!updatedSubnetStatus) {\n          throw TrustError.fromCode(new MissingSignatureErrorCode());\n        }\n        return this.#verifyQueryResponse(queryWithDetails, updatedSubnetStatus);\n      }\n    } catch (error) {\n      let queryError;\n      if (error instanceof AgentError) {\n        // override the error code to include the request details\n        error.code.requestContext = {\n          requestId,\n          senderPubKey: transformedRequest.body.sender_pubkey,\n          senderSignature: transformedRequest.body.sender_sig,\n          ingressExpiry: transformedRequest.body.content.ingress_expiry\n        };\n        queryError = error;\n      } else {\n        queryError = UnknownError.fromCode(new UnexpectedErrorCode(error));\n      }\n      this.log.error(`Error while making query: ${queryError.message}`, queryError);\n      throw queryError;\n    }\n  }\n  /**\n   * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n   * @param queryResponse - The response from the query\n   * @param subnetStatus - The subnet status, including all node keys\n   * @returns ApiQueryResponse\n   */\n  #verifyQueryResponse;\n  async createReadStateRequest(fields, identity) {\n    await this.#asyncGuard();\n    const id = await (identity ?? this.#identity);\n    if (!id) {\n      throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n    }\n    const sender = id.getPrincipal();\n    const transformedRequest = await this._transform({\n      request: {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? {\n            Authorization: 'Basic ' + btoa(this.#credentials)\n          } : {})\n        }\n      },\n      endpoint: Endpoint.ReadState,\n      body: {\n        request_type: ReadRequestType.ReadState,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: calculateIngressExpiry(this.#maxIngressExpiryInMinutes, this.#timeDiffMsecs)\n      }\n    });\n    // Apply transform for identity.\n    return id.transformRequest(transformedRequest);\n  }\n  async readState(canisterId, fields, _identity,\n  // eslint-disable-next-line\n  request) {\n    await this.#rootKeyGuard();\n    const canister = Principal.from(canisterId);\n    function getRequestId(options) {\n      for (const path of options.paths) {\n        const [pathName, value] = path;\n        const request_status = new TextEncoder().encode('request_status');\n        if (uint8Equals(pathName, request_status)) {\n          return value;\n        }\n      }\n    }\n    let transformedRequest;\n    let requestId;\n    // If a pre-signed request is provided, use it\n    if (request) {\n      // This is a pre-signed request\n      transformedRequest = request;\n      requestId = requestIdOf(transformedRequest);\n    } else {\n      // This is fields, we need to create a request\n      requestId = getRequestId(fields);\n      // Always create a fresh request with the current identity\n      const identity = await this.#identity;\n      if (!identity) {\n        throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n      }\n      transformedRequest = await this.createReadStateRequest(fields, identity);\n    }\n    this.log.print(`fetching \"/api/v2/canister/${canister}/read_state\" with request:`, transformedRequest);\n    const backoff = this.#backoffStrategy();\n    try {\n      const {\n        responseBodyBytes\n      } = await this.#requestAndRetry({\n        requestFn: () => this.#fetch('' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host), {\n          ...this.#fetchOptions,\n          ...transformedRequest.request,\n          body: cbor.encode(transformedRequest.body)\n        }),\n        backoff,\n        tries: 0\n      });\n      const decodedResponse = cbor.decode(responseBodyBytes);\n      this.log.print('Read state response:', decodedResponse);\n      return decodedResponse;\n    } catch (error) {\n      let readStateError;\n      if (error instanceof AgentError) {\n        // override the error code to include the request details\n        error.code.requestContext = {\n          requestId,\n          senderPubKey: transformedRequest.body.sender_pubkey,\n          senderSignature: transformedRequest.body.sender_sig,\n          ingressExpiry: transformedRequest.body.content.ingress_expiry\n        };\n        readStateError = error;\n      } else {\n        readStateError = UnknownError.fromCode(new UnexpectedErrorCode(error));\n      }\n      this.log.error(`Error while making read state: ${readStateError.message}`, readStateError);\n      throw readStateError;\n    }\n  }\n  parseTimeFromResponse(response) {\n    let tree;\n    if (response.certificate) {\n      const decoded = cbor.decode(response.certificate);\n      if (decoded && 'tree' in decoded) {\n        tree = decoded.tree;\n      } else {\n        throw ProtocolError.fromCode(new HashTreeDecodeErrorCode('Could not decode time from response'));\n      }\n      const timeLookup = lookup_path(['time'], tree);\n      if (timeLookup.status !== LookupPathStatus.Found) {\n        throw ProtocolError.fromCode(new LookupErrorCode('Time was not found in the response or was not in its expected format.', timeLookup.status));\n      }\n      if (!(timeLookup.value instanceof Uint8Array) && !ArrayBuffer.isView(timeLookup)) {\n        throw ProtocolError.fromCode(new MalformedLookupFoundValueErrorCode('Time was not in its expected format.'));\n      }\n      const date = decodeTime(timeLookup.value);\n      this.log.print('Time from response:', date);\n      this.log.print('Time from response in milliseconds:', Number(date));\n      return Number(date);\n    } else {\n      this.log.warn('No certificate found in response');\n    }\n    return 0;\n  }\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {Principal} canisterIdOverride - Pass a canister ID if you need to sync the time with a particular subnet. Uses the ICP ledger canister by default.\n   */\n  async syncTime(canisterIdOverride) {\n    this.#syncTimePromise = this.#syncTimePromise ?? (async () => {\n      await this.#rootKeyGuard();\n      const callTime = Date.now();\n      try {\n        if (!canisterIdOverride) {\n          this.log.print('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');\n        }\n        // Fall back with canisterId of the ICP Ledger\n        const canisterId = canisterIdOverride ?? Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai');\n        const anonymousAgent = HttpAgent.createSync({\n          identity: new AnonymousIdentity(),\n          host: this.host.toString(),\n          fetch: this.#fetch,\n          retryTimes: 0,\n          rootKey: this.rootKey ?? undefined\n        });\n        const replicaTimes = await Promise.all(Array(3).fill(null).map(async () => {\n          const status = await canisterStatusRequest({\n            canisterId,\n            agent: anonymousAgent,\n            paths: ['time']\n          });\n          const date = status.get('time');\n          if (date instanceof Date) {\n            return date.getTime();\n          }\n        }, []));\n        const maxReplicaTime = replicaTimes.reduce((max, current) => {\n          return typeof current === 'number' && current > max ? current : max;\n        }, 0);\n        if (maxReplicaTime > BigInt(0)) {\n          this.#timeDiffMsecs = Number(maxReplicaTime) - Number(callTime);\n          this.log.notify({\n            message: `Syncing time: offset of ${this.#timeDiffMsecs}`,\n            level: 'info'\n          });\n        }\n      } catch (error) {\n        const syncTimeError = error instanceof AgentError ? error : UnknownError.fromCode(new UnexpectedErrorCode(error));\n        this.log.error('Caught exception while attempting to sync time', syncTimeError);\n        throw syncTimeError;\n      }\n    })();\n    await this.#syncTimePromise.finally(() => {\n      this.#syncTimePromise = null;\n    });\n  }\n  async status() {\n    const headers = this.#credentials ? {\n      Authorization: 'Basic ' + btoa(this.#credentials)\n    } : {};\n    this.log.print(`fetching \"/api/v2/status\"`);\n    const backoff = this.#backoffStrategy();\n    const {\n      responseBodyBytes\n    } = await this.#requestAndRetry({\n      backoff,\n      requestFn: () => this.#fetch('' + new URL(`/api/v2/status`, this.host), {\n        headers,\n        ...this.#fetchOptions\n      }),\n      tries: 0\n    });\n    return cbor.decode(responseBodyBytes);\n  }\n  async fetchRootKey() {\n    // Wait for already pending promise to avoid duplicate calls\n    this.#rootKeyPromise = this.#rootKeyPromise ?? (async () => {\n      const value = await this.status();\n      // Hex-encoded version of the replica root key\n      this.rootKey = value.root_key;\n      return this.rootKey;\n    })();\n    // clear rootkey promise and return result\n    return await this.#rootKeyPromise.finally(() => {\n      this.#rootKeyPromise = null;\n    });\n  }\n  async #asyncGuard(canisterIdOverride) {\n    await Promise.all([this.#rootKeyGuard(), this.#syncTimeGuard(canisterIdOverride)]);\n  }\n  async #rootKeyGuard() {\n    if (this.rootKey) {\n      return;\n    } else if (this.rootKey === null && this.host.toString() !== 'https://icp-api.io' && this.#shouldFetchRootKey) {\n      await this.fetchRootKey();\n    } else {\n      throw ExternalError.fromCode(new MissingRootKeyErrorCode(this.#shouldFetchRootKey));\n    }\n  }\n  async #syncTimeGuard(canisterIdOverride) {\n    if (this.#shouldSyncTime && this.#timeDiffMsecs === 0) {\n      await this.syncTime(canisterIdOverride);\n    }\n  }\n  invalidateIdentity() {\n    this.#identity = null;\n  }\n  replaceIdentity(identity) {\n    this.#identity = Promise.resolve(identity);\n  }\n  async fetchSubnetKeys(canisterId) {\n    const effectiveCanisterId = Principal.from(canisterId);\n    await this.#asyncGuard(effectiveCanisterId);\n    const response = await canisterStatusRequest({\n      canisterId: effectiveCanisterId,\n      paths: ['subnet'],\n      agent: this\n    });\n    const subnetResponse = response.get('subnet');\n    if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n      this.#subnetKeys.set(effectiveCanisterId.toText(), subnetResponse);\n      return subnetResponse;\n    }\n    // If the subnet status is not returned, return undefined\n    return undefined;\n  }\n  _transform(request) {\n    let p = Promise.resolve(request);\n    if (request.endpoint === Endpoint.Call) {\n      for (const fn of this.#updatePipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    } else {\n      for (const fn of this.#queryPipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    }\n    return p;\n  }\n}\n/**\n * Calculates the ingress expiry time based on the maximum allowed expiry in minutes and the time difference in milliseconds.\n * @param maxIngressExpiryInMinutes - The maximum ingress expiry time in minutes.\n * @param timeDiffMsecs - The time difference in milliseconds to adjust the expiry.\n * @returns The calculated ingress expiry as an Expiry object.\n */\nexport function calculateIngressExpiry(maxIngressExpiryInMinutes, timeDiffMsecs) {\n  return Expiry.fromDeltaInMilliseconds(maxIngressExpiryInMinutes * MINUTE_TO_MSECS + timeDiffMsecs);\n}","map":{"version":3,"names":["Principal","HashTreeDecodeErrorCode","CreateHttpAgentErrorCode","ExternalError","HttpDefaultFetchErrorCode","IdentityInvalidErrorCode","IngressExpiryInvalidErrorCode","InputError","LookupErrorCode","MalformedPublicKeyErrorCode","MalformedSignatureErrorCode","MissingRootKeyErrorCode","MissingSignatureErrorCode","ProtocolError","QuerySignatureVerificationFailedErrorCode","TimeoutWaitingForResponseErrorCode","TrustError","UnexpectedErrorCode","UnknownError","HttpErrorCode","HttpV3ApiNotSupportedErrorCode","TransportError","HttpFetchErrorCode","AgentError","MalformedLookupFoundValueErrorCode","CertificateOutdatedErrorCode","AnonymousIdentity","cbor","hashOfMap","requestIdOf","QueryResponseStatus","Expiry","httpHeadersTransform","makeNonceTransform","Endpoint","makeNonce","ReadRequestType","SubmitRequestType","request","canisterStatusRequest","lookup_path","LookupPathStatus","ed25519","ExpirableMap","Ed25519PublicKey","ObservableLog","ExponentialBackoff","decodeTime","concatBytes","hexToBytes","uint8Equals","uint8FromBufLike","IC_RESPONSE_DOMAIN_SEPARATOR","RequestStatusResponseStatus","MINUTE_TO_MSECS","MSECS_TO_NANOSECONDS","IC_ROOT_KEY","MANAGEMENT_CANISTER_ID","IC0_DOMAIN","IC0_SUB_DOMAIN","ICP0_DOMAIN","ICP0_SUB_DOMAIN","ICP_API_DOMAIN","ICP_API_SUB_DOMAIN","HTTP_STATUS_OK","HTTP_STATUS_ACCEPTED","HTTP_STATUS_NOT_FOUND","getDefaultFetch","defaultFetch","window","fetch","bind","fromCode","global","self","determineHost","configuredHost","host","undefined","match","URL","location","protocol","knownHosts","remoteHosts","hostname","knownHost","some","endsWith","find","port","toString","HttpAgent","rootKeyPromise","shouldFetchRootKey","timeDiffMsecs","syncTimePromise","shouldSyncTime","identity","fetchOptions","callOptions","credentials","retryTimes","backoffStrategy","maxIngressExpiryInMinutes","maxIngressExpiryInMs","#maxIngressExpiryInMs","queryPipeline","updatePipeline","subnetKeys","verifyQuerySignatures","constructor","options","_isAgent","config","log","expirationTime","verifyQueryResponse","queryResponse","subnetStatus","status","signatures","requestId","sig","timestamp","nodeId","fromUint8Array","toText","hash","Replied","reply","BigInt","request_id","Rejected","reject_code","reject_message","error_code","separatorWithHash","pubKey","nodeKeys","get","rawKey","fromDer","valid","verify","signature","rootKey","defaultBackoffFactory","maxIterations","name","password","Promise","resolve","ingressExpiryInMinutes","addTransform","useQueryNonces","logToConsole","subscribe","level","console","error","message","warn","createSync","create","agent","asyncGuard","from","_fetch","_fetchOptions","_callOptions","_host","_identity","isLocal","type","fn","priority","i","findIndex","x","splice","length","Object","assign","getPrincipal","call","canisterId","callSync","id","canister","ecid","effectiveCanisterId","sender","ingress_expiry","calculateIngressExpiry","submit","request_type","Call","canister_id","method_name","methodName","arg","transformedRequest","_transform","body","method","headers","Authorization","btoa","endpoint","nonce","toNonce","buf","__nonce__","transformRequest","encode","backoff","requestSync","print","requestAsync","requestFn","responseBodyBytes","response","requestAndRetry","tries","responseBody","byteLength","decode","requestDetails","callError","hasCode","syncTime","code","requestContext","senderPubKey","sender_pubkey","senderSignature","sender_sig","ingressExpiry","content","requestAndRetryQuery","#requestAndRetryQuery","args","delay","next","setTimeout","fetchResponse","arrayBuffer","httpDetails","ok","statusText","text","signatureTimestampNs","signatureTimestampMs","Number","currentTimestampInMs","Date","now","#requestAndRetry","Uint8Array","clone","responseText","url","includes","startsWith","query","fields","Query","makeQuery","getSubnetStatus","fetchSubnetKeys","queryResult","all","queryWithDetails","delete","updatedSubnetStatus","queryError","createReadStateRequest","ReadState","paths","readState","rootKeyGuard","getRequestId","path","pathName","value","request_status","TextEncoder","decodedResponse","readStateError","parseTimeFromResponse","tree","certificate","decoded","timeLookup","Found","ArrayBuffer","isView","date","canisterIdOverride","callTime","anonymousAgent","replicaTimes","Array","fill","map","getTime","maxReplicaTime","reduce","max","current","notify","syncTimeError","finally","fetchRootKey","root_key","#asyncGuard","syncTimeGuard","#rootKeyGuard","#syncTimeGuard","invalidateIdentity","replaceIdentity","subnetResponse","set","p","then","r","r2","fromDeltaInMilliseconds"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\agent\\http\\index.ts"],"sourcesContent":["import { type JsonObject } from '@dfinity/candid';\nimport { Principal } from '@dfinity/principal';\nimport {\n  HashTreeDecodeErrorCode,\n  CreateHttpAgentErrorCode,\n  ExternalError,\n  HttpDefaultFetchErrorCode,\n  IdentityInvalidErrorCode,\n  IngressExpiryInvalidErrorCode,\n  InputError,\n  LookupErrorCode,\n  MalformedPublicKeyErrorCode,\n  MalformedSignatureErrorCode,\n  MissingRootKeyErrorCode,\n  MissingSignatureErrorCode,\n  ProtocolError,\n  QuerySignatureVerificationFailedErrorCode,\n  TimeoutWaitingForResponseErrorCode,\n  TrustError,\n  UnexpectedErrorCode,\n  UnknownError,\n  HttpErrorCode,\n  HttpV3ApiNotSupportedErrorCode,\n  TransportError,\n  HttpFetchErrorCode,\n  AgentError,\n  MalformedLookupFoundValueErrorCode,\n  CertificateOutdatedErrorCode,\n} from '../../errors.ts';\nimport { AnonymousIdentity, type Identity } from '../../auth.ts';\nimport * as cbor from '../../cbor.ts';\nimport { type RequestId, hashOfMap, requestIdOf } from '../../request_id.ts';\nimport {\n  QueryResponseStatus,\n  type Agent,\n  type ApiQueryResponse,\n  type QueryFields,\n  type QueryResponse,\n  type ReadStateOptions,\n  type ReadStateResponse,\n  type SubmitResponse,\n} from '../api.ts';\nimport { Expiry, httpHeadersTransform, makeNonceTransform } from './transforms.ts';\nimport {\n  type CallRequest,\n  Endpoint,\n  type HttpAgentRequest,\n  type HttpAgentRequestTransformFn,\n  type HttpAgentSubmitRequest,\n  makeNonce,\n  type Nonce,\n  type QueryRequest,\n  ReadRequestType,\n  SubmitRequestType,\n  type ReadStateRequest,\n  type HttpHeaderField,\n} from './types.ts';\nimport { type SubnetStatus, request as canisterStatusRequest } from '../../canisterStatus/index.ts';\nimport { type HashTree, lookup_path, LookupPathStatus } from '../../certificate.ts';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { ExpirableMap } from '../../utils/expirableMap.ts';\nimport { Ed25519PublicKey } from '../../public_key.ts';\nimport { ObservableLog } from '../../observable.ts';\nimport {\n  type BackoffStrategy,\n  type BackoffStrategyFactory,\n  ExponentialBackoff,\n} from '../../polling/backoff.ts';\nimport { decodeTime } from '../../utils/leb.ts';\nimport { concatBytes, hexToBytes } from '@noble/hashes/utils';\nimport { uint8Equals, uint8FromBufLike } from '../../utils/buffer.ts';\nimport { IC_RESPONSE_DOMAIN_SEPARATOR } from '../../constants.ts';\nexport * from './transforms.ts';\nexport { type Nonce, makeNonce } from './types.ts';\n\nexport enum RequestStatusResponseStatus {\n  Received = 'received',\n  Processing = 'processing',\n  Replied = 'replied',\n  Rejected = 'rejected',\n  Unknown = 'unknown',\n  Done = 'done',\n}\n\nconst MINUTE_TO_MSECS = 60 * 1_000;\nconst MSECS_TO_NANOSECONDS = 1_000_000;\n\n// Root public key for the IC, encoded as hex\nexport const IC_ROOT_KEY =\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n  'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n  '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n  'b01291091c5f87b98883463f98091a0baaae';\n\nexport const MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\n\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\n\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\n\nconst HTTP_STATUS_OK = 200;\nconst HTTP_STATUS_ACCEPTED = 202;\nconst HTTP_STATUS_NOT_FOUND = 404;\n\n// HttpAgent options that can be used at construction.\nexport interface HttpAgentOptions {\n  // A surrogate to the global fetch function. Useful for testing.\n  fetch?: typeof fetch;\n\n  // Additional options to pass along to fetch. Will not override fields that\n  // the agent already needs to set\n  // Should follow the RequestInit interface, but we intentially support non-standard fields\n  fetchOptions?: Record<string, unknown>;\n\n  // Additional options to pass along to fetch for the call API.\n  callOptions?: Record<string, unknown>;\n\n  // The host to use for the client. By default, uses the same host as\n  // the current page.\n  host?: string;\n\n  // The principal used to send messages. This cannot be empty at the request\n  // time (will throw).\n  identity?: Identity | Promise<Identity>;\n\n  /**\n   * The maximum time a request can be delayed before being rejected.\n   * @default 5 minutes\n   */\n  ingressExpiryInMinutes?: number;\n\n  credentials?: {\n    name: string;\n    password?: string;\n  };\n  /**\n   * Adds a unique {@link Nonce} with each query.\n   * Enabling will prevent queries from being answered with a cached response.\n   * @example\n   * const agent = new HttpAgent({ useQueryNonces: true });\n   * agent.addTransform(makeNonceTransform(makeNonce);\n   * @default false\n   */\n  useQueryNonces?: boolean;\n  /**\n   * Number of times to retry requests before throwing an error\n   * @default 3\n   */\n  retryTimes?: number;\n  /**\n   * The strategy to use for backoff when retrying requests\n   */\n  backoffStrategy?: BackoffStrategyFactory;\n  /**\n   * Whether the agent should verify signatures signed by node keys on query responses. Increases security, but adds overhead and must make a separate request to cache the node keys for the canister's subnet.\n   * @default true\n   */\n  verifyQuerySignatures?: boolean;\n  /**\n   * Whether to log to the console. Defaults to false.\n   */\n  logToConsole?: boolean;\n\n  /**\n   * Alternate root key to use for verifying certificates. If not provided, the default IC root key will be used.\n   */\n  rootKey?: Uint8Array;\n\n  /**\n   * Whether or not the root key should be automatically fetched during construction. Defaults to false.\n   */\n  shouldFetchRootKey?: boolean;\n\n  /**\n   * Whether or not to sync the time with the network during construction. Defaults to false.\n   */\n  shouldSyncTime?: boolean;\n}\n\nfunction getDefaultFetch(): typeof fetch {\n  let defaultFetch;\n\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw ExternalError.fromCode(\n        new HttpDefaultFetchErrorCode(\n          'Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.',\n        ),\n      );\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw ExternalError.fromCode(\n        new HttpDefaultFetchErrorCode(\n          'Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.',\n        ),\n      );\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw ExternalError.fromCode(\n    new HttpDefaultFetchErrorCode(\n      'Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.',\n    ),\n  );\n}\n\nfunction determineHost(configuredHost: string | undefined): string {\n  let host: URL;\n  if (configuredHost !== undefined) {\n    if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n      host = new URL(window.location.protocol + '//' + configuredHost);\n    } else {\n      host = new URL(configuredHost);\n    }\n  } else {\n    // Mainnet, local, and remote environments will have the api route available\n    const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n    const remoteHosts = ['.github.dev', '.gitpod.io'];\n    const location = typeof window !== 'undefined' ? window.location : undefined;\n    const hostname = location?.hostname;\n    let knownHost;\n    if (hostname && typeof hostname === 'string') {\n      if (remoteHosts.some(host => hostname.endsWith(host))) {\n        knownHost = hostname;\n      } else {\n        knownHost = knownHosts.find(host => hostname.endsWith(host));\n      }\n    }\n\n    if (location && knownHost) {\n      // If the user is on a boundary-node provided host, we can use the same host for the agent\n      host = new URL(\n        `${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`,\n      );\n    } else {\n      host = new URL('https://icp-api.io');\n    }\n  }\n  return host.toString();\n}\n\ninterface V1HttpAgentInterface {\n  _identity: Promise<Identity> | null;\n  readonly _fetch: typeof fetch;\n  readonly _fetchOptions?: Record<string, unknown>;\n  readonly _callOptions?: Record<string, unknown>;\n\n  readonly _host: URL;\n  readonly _credentials: string | undefined;\n  readonly _retryTimes: number; // Retry requests N times before erroring by default\n  _isAgent: true;\n}\n\n/** \n * A HTTP agent allows users to interact with a client of the internet computer\nusing the available methods. It exposes an API that closely follows the\npublic view of the internet computer, and is not intended to be exposed\ndirectly to the majority of users due to its low-level interface.\n * There is a pipeline to apply transformations to the request before sending\nit to the client. This is to decouple signature, nonce generation and\nother computations so that this class can stay as simple as possible while\nallowing extensions.\n */\nexport class HttpAgent implements Agent {\n  public rootKey: Uint8Array | null;\n  #rootKeyPromise: Promise<Uint8Array> | null = null;\n  readonly #shouldFetchRootKey: boolean = false;\n\n  #timeDiffMsecs = 0;\n  #syncTimePromise: Promise<void> | null = null;\n  readonly #shouldSyncTime: boolean = false;\n\n  #identity: Promise<Identity> | null;\n  readonly #fetch: typeof fetch;\n  readonly #fetchOptions?: Record<string, unknown>;\n  readonly #callOptions?: Record<string, unknown>;\n  readonly host: URL;\n  readonly #credentials: string | undefined;\n  readonly #retryTimes; // Retry requests N times before erroring by default\n  #backoffStrategy: BackoffStrategyFactory;\n  readonly #maxIngressExpiryInMinutes: number;\n  get #maxIngressExpiryInMs(): number {\n    return this.#maxIngressExpiryInMinutes * MINUTE_TO_MSECS;\n  }\n\n  // Public signature to help with type checking.\n  public readonly _isAgent = true;\n  public config: HttpAgentOptions = {};\n\n  public log: ObservableLog = new ObservableLog();\n\n  #queryPipeline: HttpAgentRequestTransformFn[] = [];\n  #updatePipeline: HttpAgentRequestTransformFn[] = [];\n\n  #subnetKeys: ExpirableMap<string, SubnetStatus> = new ExpirableMap({\n    expirationTime: 5 * 60 * 1000, // 5 minutes\n  });\n  #verifyQuerySignatures = true;\n\n  /**\n   * @param options - Options for the HttpAgent\n   * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead\n   */\n  constructor(options: HttpAgentOptions = {}) {\n    this.config = options;\n    this.#fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n    this.#fetchOptions = options.fetchOptions;\n    this.#callOptions = options.callOptions;\n    this.#shouldFetchRootKey = options.shouldFetchRootKey ?? false;\n    this.#shouldSyncTime = options.shouldSyncTime ?? false;\n\n    // Use provided root key, otherwise fall back to IC_ROOT_KEY for mainnet or null if the key needs to be fetched\n    if (options.rootKey) {\n      this.rootKey = options.rootKey;\n    } else if (this.#shouldFetchRootKey) {\n      this.rootKey = null;\n    } else {\n      this.rootKey = hexToBytes(IC_ROOT_KEY);\n    }\n\n    const host = determineHost(options.host);\n    this.host = new URL(host);\n\n    if (options.verifyQuerySignatures !== undefined) {\n      this.#verifyQuerySignatures = options.verifyQuerySignatures;\n    }\n    // Default is 3\n    this.#retryTimes = options.retryTimes ?? 3;\n    // Delay strategy for retries. Default is exponential backoff\n    const defaultBackoffFactory = () =>\n      new ExponentialBackoff({\n        maxIterations: this.#retryTimes,\n      });\n    this.#backoffStrategy = options.backoffStrategy || defaultBackoffFactory;\n    // Rewrite to avoid redirects\n    if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this.host.hostname = IC0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this.host.hostname = ICP0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this.host.hostname = ICP_API_DOMAIN;\n    }\n\n    if (options.credentials) {\n      const { name, password } = options.credentials;\n      this.#credentials = `${name}${password ? ':' + password : ''}`;\n    }\n    this.#identity = Promise.resolve(options.identity || new AnonymousIdentity());\n\n    if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes > 5) {\n      throw InputError.fromCode(\n        new IngressExpiryInvalidErrorCode(\n          'The maximum ingress expiry time is 5 minutes.',\n          options.ingressExpiryInMinutes,\n        ),\n      );\n    }\n    if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes <= 0) {\n      throw InputError.fromCode(\n        new IngressExpiryInvalidErrorCode(\n          'Ingress expiry time must be greater than 0.',\n          options.ingressExpiryInMinutes,\n        ),\n      );\n    }\n\n    this.#maxIngressExpiryInMinutes = options.ingressExpiryInMinutes || 5;\n\n    // Add a nonce transform to ensure calls are unique\n    this.addTransform('update', makeNonceTransform(makeNonce));\n    if (options.useQueryNonces) {\n      this.addTransform('query', makeNonceTransform(makeNonce));\n    }\n    if (options.logToConsole) {\n      this.log.subscribe(log => {\n        if (log.level === 'error') {\n          console.error(log.message);\n        } else if (log.level === 'warn') {\n          console.warn(log.message);\n        } else {\n          console.log(log.message);\n        }\n      });\n    }\n  }\n\n  public static createSync(options: HttpAgentOptions = {}): HttpAgent {\n    return new this({ ...options });\n  }\n\n  public static async create(options: HttpAgentOptions = {}): Promise<HttpAgent> {\n    const agent = HttpAgent.createSync(options);\n    await agent.#asyncGuard();\n    return agent;\n  }\n\n  public static async from(\n    agent: Pick<HttpAgent, 'config'> | V1HttpAgentInterface,\n  ): Promise<HttpAgent> {\n    try {\n      if ('config' in agent) {\n        return await HttpAgent.create(agent.config);\n      }\n      return await HttpAgent.create({\n        fetch: agent._fetch,\n        fetchOptions: agent._fetchOptions,\n        callOptions: agent._callOptions,\n        host: agent._host.toString(),\n        identity: agent._identity ?? undefined,\n      });\n    } catch {\n      throw InputError.fromCode(new CreateHttpAgentErrorCode());\n    }\n  }\n\n  public isLocal(): boolean {\n    const hostname = this.host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n  }\n\n  public addTransform(\n    type: 'update' | 'query',\n    fn: HttpAgentRequestTransformFn,\n    priority = fn.priority || 0,\n  ): void {\n    if (type === 'update') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#updatePipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#updatePipeline.splice(\n        i >= 0 ? i : this.#updatePipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    } else if (type === 'query') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#queryPipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#queryPipeline.splice(\n        i >= 0 ? i : this.#queryPipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    }\n  }\n\n  public async getPrincipal(): Promise<Principal> {\n    if (!this.#identity) {\n      throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n    }\n    return (await this.#identity).getPrincipal();\n  }\n\n  /**\n   * Makes a call to a canister method.\n   * @param canisterId - The ID of the canister to call. Can be a Principal or a string.\n   * @param options - Options for the call.\n   * @param options.methodName - The name of the method to call.\n   * @param options.arg - The argument to pass to the method, as a Uint8Array.\n   * @param options.effectiveCanisterId - (Optional) The effective canister ID, if different from the target canister ID.\n   * @param options.callSync - (Optional) Whether to use synchronous call mode. Defaults to true.\n   * @param options.nonce - (Optional) A unique nonce for the request. If provided, it will override any nonce set by transforms.\n   * @param identity - (Optional) The identity to use for the call. If not provided, the agent's current identity will be used.\n   * @returns A promise that resolves to the response of the call, including the request ID and response details.\n   */\n  public async call(\n    canisterId: Principal | string,\n    options: {\n      methodName: string;\n      arg: Uint8Array;\n      effectiveCanisterId?: Principal | string;\n      callSync?: boolean;\n      nonce?: Uint8Array | Nonce;\n    },\n    identity?: Identity | Promise<Identity>,\n  ): Promise<SubmitResponse> {\n    // TODO - restore this value\n    const callSync = options.callSync ?? true;\n    const id = await (identity ?? this.#identity);\n    if (!id) {\n      throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId\n      ? Principal.from(options.effectiveCanisterId)\n      : canister;\n    await this.#asyncGuard(ecid);\n\n    const sender = id.getPrincipal();\n\n    const ingress_expiry = calculateIngressExpiry(\n      this.#maxIngressExpiryInMinutes,\n      this.#timeDiffMsecs,\n    );\n\n    const submit: CallRequest = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry,\n    };\n\n    let transformedRequest = (await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.Call,\n      body: submit,\n    })) as HttpAgentSubmitRequest;\n\n    // Determine the nonce to use for the request\n    let nonce: Nonce | undefined;\n\n    // Check if a nonce is provided in the options and convert it to the correct type\n    if (options?.nonce) {\n      nonce = toNonce(options.nonce);\n    }\n    // If no nonce is provided in the options, check the transformedRequest body\n    else if (transformedRequest.body.nonce) {\n      nonce = toNonce(transformedRequest.body.nonce);\n    }\n    // If no nonce is found, set it to undefined\n    else {\n      nonce = undefined;\n    }\n\n    // Assign the determined nonce to the submit object\n    submit.nonce = nonce;\n\n    /**\n     * Converts a Uint8Array to a Nonce type.\n     * @param buf - The buffer to convert.\n     * @returns The buffer as a Nonce.\n     */\n    function toNonce(buf: Uint8Array): Nonce {\n      return Object.assign(buf, { __nonce__: undefined });\n    }\n\n    // Apply transform for identity.\n    transformedRequest = (await id.transformRequest(transformedRequest)) as HttpAgentSubmitRequest;\n\n    const body = cbor.encode(transformedRequest.body);\n    const backoff = this.#backoffStrategy();\n    const requestId = requestIdOf(submit);\n    try {\n      // Attempt v3 sync call\n      const requestSync = () => {\n        this.log.print(\n          `fetching \"/api/v3/canister/${ecid.toText()}/call\" with request:`,\n          transformedRequest,\n        );\n        return this.#fetch('' + new URL(`/api/v3/canister/${ecid.toText()}/call`, this.host), {\n          ...this.#callOptions,\n          ...transformedRequest.request,\n          body,\n        });\n      };\n\n      const requestAsync = () => {\n        this.log.print(\n          `fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`,\n          transformedRequest,\n        );\n        return this.#fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), {\n          ...this.#callOptions,\n          ...transformedRequest.request,\n          body,\n        });\n      };\n\n      const requestFn = callSync ? requestSync : requestAsync;\n      const { responseBodyBytes, ...response } = await this.#requestAndRetry({\n        requestFn,\n        backoff,\n        tries: 0,\n      });\n\n      const responseBody = (\n        responseBodyBytes.byteLength > 0 ? cbor.decode(responseBodyBytes) : null\n      ) as SubmitResponse['response']['body'];\n\n      return {\n        requestId,\n        response: {\n          ...response,\n          body: responseBody,\n        },\n        requestDetails: submit,\n      };\n    } catch (error) {\n      let callError: AgentError;\n      if (error instanceof AgentError) {\n        // If the error is due to the v3 api not being supported, fall back to v2\n        if (error.hasCode(HttpV3ApiNotSupportedErrorCode)) {\n          this.log.warn('v3 api not supported. Fall back to v2');\n          return this.call(\n            canisterId,\n            {\n              ...options,\n              // disable v3 api\n              callSync: false,\n            },\n            identity,\n          );\n        } else if (error.hasCode(IngressExpiryInvalidErrorCode)) {\n          // if there is an ingress expiry error, sync time with the network and try again\n          await this.syncTime(canister);\n          return this.call(canister, options, identity);\n        } else {\n          // override the error code to include the request details\n          error.code.requestContext = {\n            requestId,\n            senderPubKey: transformedRequest.body.sender_pubkey,\n            senderSignature: transformedRequest.body.sender_sig,\n            ingressExpiry: transformedRequest.body.content.ingress_expiry,\n          };\n          callError = error;\n        }\n      } else {\n        callError = UnknownError.fromCode(new UnexpectedErrorCode(error));\n      }\n      this.log.error(`Error while making call: ${callError.message}`, callError);\n      throw callError;\n    }\n  }\n\n  async #requestAndRetryQuery(args: {\n    ecid: Principal;\n    transformedRequest: HttpAgentRequest;\n    body: Uint8Array;\n    requestId: RequestId;\n    backoff: BackoffStrategy;\n    tries: number;\n  }): Promise<ApiQueryResponse> {\n    const { ecid, transformedRequest, body, requestId, backoff, tries } = args;\n\n    const delay = tries === 0 ? 0 : backoff.next();\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n      tries,\n      backoff,\n      delay,\n    });\n\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw UnknownError.fromCode(\n        new TimeoutWaitingForResponseErrorCode(\n          `Backoff strategy exhausted after ${tries} attempts.`,\n          requestId,\n        ),\n      );\n    }\n\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response: ApiQueryResponse;\n    // Make the request and retry if it throws an error\n    try {\n      this.log.print(\n        `fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`,\n        transformedRequest,\n      );\n      const fetchResponse = await this.#fetch(\n        '' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host),\n        {\n          ...this.#fetchOptions,\n          ...transformedRequest.request,\n          body,\n        },\n      );\n      if (fetchResponse.status === HTTP_STATUS_OK) {\n        const queryResponse: QueryResponse = cbor.decode(\n          uint8FromBufLike(await fetchResponse.arrayBuffer()),\n        );\n        response = {\n          ...queryResponse,\n          httpDetails: {\n            ok: fetchResponse.ok,\n            status: fetchResponse.status,\n            statusText: fetchResponse.statusText,\n            headers: httpHeadersTransform(fetchResponse.headers),\n          },\n          requestId,\n        };\n      } else {\n        throw ProtocolError.fromCode(\n          new HttpErrorCode(\n            fetchResponse.status,\n            fetchResponse.statusText,\n            httpHeadersTransform(fetchResponse.headers),\n            await fetchResponse.text(),\n          ),\n        );\n      }\n    } catch (error) {\n      if (tries < this.#retryTimes) {\n        this.log.warn(\n          `Caught exception while attempting to make query:\\n` +\n            `  ${error}\\n` +\n            `  Retrying query.`,\n        );\n        return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n      }\n      if (error instanceof AgentError) {\n        // if it's an error that we have thrown, just throw it as is\n        throw error;\n      }\n      // if it's an error that we have not thrown, wrap it in a TransportError\n      throw TransportError.fromCode(new HttpFetchErrorCode(error));\n    }\n\n    // Skip timestamp verification if the user has set verifyQuerySignatures to false\n    if (!this.#verifyQuerySignatures) {\n      return response;\n    }\n\n    const signatureTimestampNs = response.signatures?.[0]?.timestamp;\n    if (!signatureTimestampNs) {\n      throw ProtocolError.fromCode(\n        new MalformedSignatureErrorCode(\n          'Timestamp not found in query response. This suggests a malformed or malicious response.',\n        ),\n      );\n    }\n\n    const signatureTimestampMs = Number(\n      BigInt(signatureTimestampNs) / BigInt(MSECS_TO_NANOSECONDS),\n    );\n    const currentTimestampInMs = Date.now() + this.#timeDiffMsecs;\n\n    // We don't need `Math.abs` here because we allow signatures in the future\n    if (currentTimestampInMs - signatureTimestampMs > this.#maxIngressExpiryInMs) {\n      if (tries < this.#retryTimes) {\n        this.log.warn('Timestamp is older than the max ingress expiry. Retrying query.', {\n          requestId,\n          signatureTimestampMs,\n        });\n        return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n      }\n      throw TrustError.fromCode(\n        new CertificateOutdatedErrorCode(this.#maxIngressExpiryInMinutes, requestId, tries),\n      );\n    }\n\n    return response;\n  }\n\n  /**\n   * Makes a request and retries if it fails.\n   * @param args - The arguments for the request.\n   * @param args.requestFn - A function that returns a Promise resolving to a Response.\n   * @param args.backoff - The backoff strategy to use for retries.\n   * @param args.tries - The number of retry attempts made so far.\n   * @returns The response from the request, if the status is 200 or 202.\n   * See the https://internetcomputer.org/docs/references/ic-interface-spec#http-interface for details on the response statuses.\n   * @throws {ProtocolError} if the response status is not 200 or 202, and the retry limit has been reached.\n   * @throws {TransportError} if the request fails, and the retry limit has been reached.\n   */\n  async #requestAndRetry(args: {\n    requestFn: () => Promise<Response>;\n    backoff: BackoffStrategy;\n    tries: number;\n  }): Promise<{\n    ok: boolean;\n    status: number;\n    statusText: string;\n    responseBodyBytes: Uint8Array;\n    headers: HttpHeaderField[];\n  }> {\n    const { requestFn, backoff, tries } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw ProtocolError.fromCode(\n        new TimeoutWaitingForResponseErrorCode(`Retry strategy exhausted after ${tries} attempts.`),\n      );\n    }\n\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n\n    let response: Response;\n    let responseBodyBytes = new Uint8Array();\n    try {\n      response = await requestFn();\n      // According to the spec, only 200 responses have a non-empty body\n      if (response.status === HTTP_STATUS_OK) {\n        // Consume the response body, to ensure that the response is not closed unexpectedly\n        responseBodyBytes = uint8FromBufLike(await response.clone().arrayBuffer());\n      }\n    } catch (error) {\n      if (tries < this.#retryTimes) {\n        this.log.warn(\n          `Caught exception while attempting to make request:\\n` +\n            `  ${error}\\n` +\n            `  Retrying request.`,\n        );\n        // Delay the request by the configured backoff strategy\n        return await this.#requestAndRetry({ requestFn, backoff, tries: tries + 1 });\n      }\n      throw TransportError.fromCode(new HttpFetchErrorCode(error));\n    }\n\n    const headers = httpHeadersTransform(response.headers);\n\n    if (response.status === HTTP_STATUS_OK || response.status === HTTP_STATUS_ACCEPTED) {\n      return {\n        ok: response.ok, // should always be true\n        status: response.status,\n        statusText: response.statusText,\n        responseBodyBytes,\n        headers,\n      };\n    }\n\n    const responseText = await response.text();\n\n    if (response.status === HTTP_STATUS_NOT_FOUND && response.url.includes('api/v3')) {\n      throw ProtocolError.fromCode(new HttpV3ApiNotSupportedErrorCode());\n    }\n\n    // The error message comes from https://github.com/dfinity/ic/blob/23d5990bfc5277c32e54f0087b5a38fa412171e1/rs/validator/src/ingress_validation.rs#L233\n    if (responseText.startsWith('Invalid request expiry: ')) {\n      throw InputError.fromCode(\n        new IngressExpiryInvalidErrorCode(responseText, this.#maxIngressExpiryInMinutes),\n      );\n    }\n\n    if (tries < this.#retryTimes) {\n      return await this.#requestAndRetry({ requestFn, backoff, tries: tries + 1 });\n    }\n\n    throw ProtocolError.fromCode(\n      new HttpErrorCode(response.status, response.statusText, headers, responseText),\n    );\n  }\n\n  public async query(\n    canisterId: Principal | string,\n    fields: QueryFields,\n    identity?: Identity | Promise<Identity>,\n  ): Promise<ApiQueryResponse> {\n    const backoff = this.#backoffStrategy();\n    const ecid = fields.effectiveCanisterId\n      ? Principal.from(fields.effectiveCanisterId)\n      : Principal.from(canisterId);\n    await this.#asyncGuard(ecid);\n\n    this.log.print(`ecid ${ecid.toString()}`);\n    this.log.print(`canisterId ${canisterId.toString()}`);\n\n    let transformedRequest: HttpAgentRequest | undefined;\n    const id = await (identity ?? this.#identity);\n    if (!id) {\n      throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n    }\n\n    const canister = Principal.from(canisterId);\n    const sender = id.getPrincipal();\n    const ingressExpiry = calculateIngressExpiry(\n      this.#maxIngressExpiryInMinutes,\n      this.#timeDiffMsecs,\n    );\n\n    const request: QueryRequest = {\n      request_type: ReadRequestType.Query,\n      canister_id: canister,\n      method_name: fields.methodName,\n      arg: fields.arg,\n      sender,\n      ingress_expiry: ingressExpiry,\n    };\n\n    const requestId = requestIdOf(request);\n\n    transformedRequest = await this._transform({\n      request: {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.Query,\n      body: request,\n    });\n\n    // Apply transform for identity.\n    transformedRequest = (await id.transformRequest(transformedRequest)) as HttpAgentRequest;\n\n    const body = cbor.encode(transformedRequest.body);\n\n    const args = {\n      canister: canister.toText(),\n      ecid,\n      transformedRequest,\n      body,\n      requestId,\n      backoff,\n      tries: 0,\n    };\n    const makeQuery = async () => {\n      return {\n        requestDetails: request,\n        query: await this.#requestAndRetryQuery(args),\n      };\n    };\n\n    const getSubnetStatus = async (): Promise<SubnetStatus | undefined> => {\n      if (!this.#verifyQuerySignatures) {\n        return undefined;\n      }\n      const subnetStatus = this.#subnetKeys.get(ecid.toString());\n      if (subnetStatus) {\n        return subnetStatus;\n      }\n      await this.fetchSubnetKeys(ecid.toString());\n      return this.#subnetKeys.get(ecid.toString());\n    };\n\n    // Attempt to make the query i=retryTimes times\n    // Make query and fetch subnet keys in parallel\n    try {\n      const [queryResult, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n      const { requestDetails, query } = queryResult;\n\n      const queryWithDetails = {\n        ...query,\n        requestDetails,\n      };\n\n      this.log.print('Query response:', queryWithDetails);\n      // Skip verification if the user has disabled it\n      if (!this.#verifyQuerySignatures) {\n        return queryWithDetails;\n      }\n\n      try {\n        return this.#verifyQueryResponse(queryWithDetails, subnetStatus);\n      } catch {\n        // In case the node signatures have changed, refresh the subnet keys and try again\n        this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n        this.#subnetKeys.delete(canisterId.toString());\n        await this.fetchSubnetKeys(ecid.toString());\n\n        const updatedSubnetStatus = this.#subnetKeys.get(canisterId.toString());\n        if (!updatedSubnetStatus) {\n          throw TrustError.fromCode(new MissingSignatureErrorCode());\n        }\n        return this.#verifyQueryResponse(queryWithDetails, updatedSubnetStatus);\n      }\n    } catch (error) {\n      let queryError: AgentError;\n      if (error instanceof AgentError) {\n        // override the error code to include the request details\n        error.code.requestContext = {\n          requestId,\n          senderPubKey: transformedRequest.body.sender_pubkey,\n          senderSignature: transformedRequest.body.sender_sig,\n          ingressExpiry: transformedRequest.body.content.ingress_expiry,\n        };\n        queryError = error;\n      } else {\n        queryError = UnknownError.fromCode(new UnexpectedErrorCode(error));\n      }\n      this.log.error(`Error while making query: ${queryError.message}`, queryError);\n      throw queryError;\n    }\n  }\n\n  /**\n   * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n   * @param queryResponse - The response from the query\n   * @param subnetStatus - The subnet status, including all node keys\n   * @returns ApiQueryResponse\n   */\n  #verifyQueryResponse = (\n    queryResponse: ApiQueryResponse,\n    subnetStatus: SubnetStatus | undefined,\n  ): ApiQueryResponse => {\n    if (this.#verifyQuerySignatures === false) {\n      // This should not be called if the user has disabled verification\n      return queryResponse;\n    }\n    if (!subnetStatus) {\n      throw TrustError.fromCode(new MissingSignatureErrorCode());\n    }\n    const { status, signatures = [], requestId } = queryResponse;\n\n    for (const sig of signatures) {\n      const { timestamp, identity } = sig;\n      const nodeId = Principal.fromUint8Array(identity).toText();\n\n      // Hash is constructed differently depending on the status\n      let hash: Uint8Array;\n      if (status === QueryResponseStatus.Replied) {\n        const { reply } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reply: reply,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else if (status === QueryResponseStatus.Rejected) {\n        const { reject_code, reject_message, error_code } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reject_code: reject_code,\n          reject_message: reject_message,\n          error_code: error_code,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else {\n        throw UnknownError.fromCode(new UnexpectedErrorCode(`Unknown status: ${status}`));\n      }\n\n      const separatorWithHash = concatBytes(IC_RESPONSE_DOMAIN_SEPARATOR, hash);\n\n      // FIX: check for match without verifying N times\n      const pubKey = subnetStatus.nodeKeys.get(nodeId);\n      if (!pubKey) {\n        throw ProtocolError.fromCode(new MalformedPublicKeyErrorCode());\n      }\n      const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;\n      const valid = ed25519.verify(sig.signature, separatorWithHash, rawKey);\n      if (valid) return queryResponse;\n\n      throw TrustError.fromCode(new QuerySignatureVerificationFailedErrorCode(nodeId));\n    }\n    return queryResponse;\n  };\n\n  public async createReadStateRequest(\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    await this.#asyncGuard();\n    const id = await (identity ?? this.#identity);\n    if (!id) {\n      throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n    }\n    const sender = id.getPrincipal();\n\n    const transformedRequest = await this._transform({\n      request: {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.ReadState,\n      body: {\n        request_type: ReadRequestType.ReadState,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: calculateIngressExpiry(\n          this.#maxIngressExpiryInMinutes,\n          this.#timeDiffMsecs,\n        ),\n      },\n    });\n\n    // Apply transform for identity.\n    return id.transformRequest(transformedRequest);\n  }\n\n  public async readState(\n    canisterId: Principal | string,\n    fields: ReadStateOptions,\n    _identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line\n    request?: any,\n  ): Promise<ReadStateResponse> {\n    await this.#rootKeyGuard();\n    const canister = Principal.from(canisterId);\n\n    function getRequestId(options: ReadStateOptions): RequestId | undefined {\n      for (const path of options.paths) {\n        const [pathName, value] = path;\n        const request_status = new TextEncoder().encode('request_status');\n        if (uint8Equals(pathName, request_status)) {\n          return value as RequestId;\n        }\n      }\n    }\n\n    let transformedRequest: ReadStateRequest;\n    let requestId: RequestId | undefined;\n\n    // If a pre-signed request is provided, use it\n    if (request) {\n      // This is a pre-signed request\n      transformedRequest = request;\n      requestId = requestIdOf(transformedRequest);\n    } else {\n      // This is fields, we need to create a request\n      requestId = getRequestId(fields);\n\n      // Always create a fresh request with the current identity\n      const identity = await this.#identity;\n      if (!identity) {\n        throw ExternalError.fromCode(new IdentityInvalidErrorCode());\n      }\n      transformedRequest = await this.createReadStateRequest(fields, identity);\n    }\n\n    this.log.print(\n      `fetching \"/api/v2/canister/${canister}/read_state\" with request:`,\n      transformedRequest,\n    );\n\n    const backoff = this.#backoffStrategy();\n    try {\n      const { responseBodyBytes } = await this.#requestAndRetry({\n        requestFn: () =>\n          this.#fetch(\n            '' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host),\n            {\n              ...this.#fetchOptions,\n              ...transformedRequest.request,\n              body: cbor.encode(transformedRequest.body),\n            },\n          ),\n        backoff,\n        tries: 0,\n      });\n\n      const decodedResponse: ReadStateResponse = cbor.decode(responseBodyBytes);\n\n      this.log.print('Read state response:', decodedResponse);\n\n      return decodedResponse;\n    } catch (error) {\n      let readStateError: AgentError;\n      if (error instanceof AgentError) {\n        // override the error code to include the request details\n        error.code.requestContext = {\n          requestId,\n          senderPubKey: transformedRequest.body.sender_pubkey,\n          senderSignature: transformedRequest.body.sender_sig,\n          ingressExpiry: transformedRequest.body.content.ingress_expiry,\n        };\n        readStateError = error;\n      } else {\n        readStateError = UnknownError.fromCode(new UnexpectedErrorCode(error));\n      }\n      this.log.error(`Error while making read state: ${readStateError.message}`, readStateError);\n      throw readStateError;\n    }\n  }\n\n  public parseTimeFromResponse(response: { certificate: Uint8Array }): number {\n    let tree: HashTree;\n    if (response.certificate) {\n      const decoded = cbor.decode<{ tree: HashTree } | undefined>(response.certificate);\n      if (decoded && 'tree' in decoded) {\n        tree = decoded.tree;\n      } else {\n        throw ProtocolError.fromCode(\n          new HashTreeDecodeErrorCode('Could not decode time from response'),\n        );\n      }\n      const timeLookup = lookup_path(['time'], tree);\n      if (timeLookup.status !== LookupPathStatus.Found) {\n        throw ProtocolError.fromCode(\n          new LookupErrorCode(\n            'Time was not found in the response or was not in its expected format.',\n            timeLookup.status,\n          ),\n        );\n      }\n\n      if (!(timeLookup.value instanceof Uint8Array) && !ArrayBuffer.isView(timeLookup)) {\n        throw ProtocolError.fromCode(\n          new MalformedLookupFoundValueErrorCode('Time was not in its expected format.'),\n        );\n      }\n      const date = decodeTime(timeLookup.value);\n      this.log.print('Time from response:', date);\n      this.log.print('Time from response in milliseconds:', Number(date));\n      return Number(date);\n    } else {\n      this.log.warn('No certificate found in response');\n    }\n    return 0;\n  }\n\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {Principal} canisterIdOverride - Pass a canister ID if you need to sync the time with a particular subnet. Uses the ICP ledger canister by default.\n   */\n  public async syncTime(canisterIdOverride?: Principal): Promise<void> {\n    this.#syncTimePromise =\n      this.#syncTimePromise ??\n      (async () => {\n        await this.#rootKeyGuard();\n        const callTime = Date.now();\n        try {\n          if (!canisterIdOverride) {\n            this.log.print(\n              'Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai',\n            );\n          }\n          // Fall back with canisterId of the ICP Ledger\n          const canisterId = canisterIdOverride ?? Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai');\n\n          const anonymousAgent = HttpAgent.createSync({\n            identity: new AnonymousIdentity(),\n            host: this.host.toString(),\n            fetch: this.#fetch,\n            retryTimes: 0,\n            rootKey: this.rootKey ?? undefined,\n          });\n\n          const replicaTimes = await Promise.all(\n            Array(3)\n              .fill(null)\n              .map(async () => {\n                const status = await canisterStatusRequest({\n                  canisterId,\n                  agent: anonymousAgent,\n                  paths: ['time'],\n                });\n\n                const date = status.get('time');\n                if (date instanceof Date) {\n                  return date.getTime();\n                }\n              }, []),\n          );\n\n          const maxReplicaTime = replicaTimes.reduce<number>((max, current) => {\n            return typeof current === 'number' && current > max ? current : max;\n          }, 0);\n\n          if (maxReplicaTime > BigInt(0)) {\n            this.#timeDiffMsecs = Number(maxReplicaTime) - Number(callTime);\n            this.log.notify({\n              message: `Syncing time: offset of ${this.#timeDiffMsecs}`,\n              level: 'info',\n            });\n          }\n        } catch (error) {\n          const syncTimeError =\n            error instanceof AgentError\n              ? error\n              : UnknownError.fromCode(new UnexpectedErrorCode(error));\n          this.log.error('Caught exception while attempting to sync time', syncTimeError);\n\n          throw syncTimeError;\n        }\n      })();\n\n    await this.#syncTimePromise.finally(() => {\n      this.#syncTimePromise = null;\n    });\n  }\n\n  public async status(): Promise<JsonObject> {\n    const headers: Record<string, string> = this.#credentials\n      ? {\n          Authorization: 'Basic ' + btoa(this.#credentials),\n        }\n      : {};\n\n    this.log.print(`fetching \"/api/v2/status\"`);\n    const backoff = this.#backoffStrategy();\n    const { responseBodyBytes } = await this.#requestAndRetry({\n      backoff,\n      requestFn: () =>\n        this.#fetch('' + new URL(`/api/v2/status`, this.host), { headers, ...this.#fetchOptions }),\n      tries: 0,\n    });\n    return cbor.decode(responseBodyBytes);\n  }\n\n  public async fetchRootKey(): Promise<Uint8Array> {\n    // Wait for already pending promise to avoid duplicate calls\n    this.#rootKeyPromise =\n      this.#rootKeyPromise ??\n      (async () => {\n        const value = await this.status();\n        // Hex-encoded version of the replica root key\n        this.rootKey = (value as JsonObject & { root_key: Uint8Array }).root_key;\n        return this.rootKey;\n      })();\n\n    // clear rootkey promise and return result\n    return await this.#rootKeyPromise.finally(() => {\n      this.#rootKeyPromise = null;\n    });\n  }\n\n  async #asyncGuard(canisterIdOverride?: Principal): Promise<void> {\n    await Promise.all([this.#rootKeyGuard(), this.#syncTimeGuard(canisterIdOverride)]);\n  }\n\n  async #rootKeyGuard(): Promise<void> {\n    if (this.rootKey) {\n      return;\n    } else if (\n      this.rootKey === null &&\n      this.host.toString() !== 'https://icp-api.io' &&\n      this.#shouldFetchRootKey\n    ) {\n      await this.fetchRootKey();\n    } else {\n      throw ExternalError.fromCode(new MissingRootKeyErrorCode(this.#shouldFetchRootKey));\n    }\n  }\n\n  async #syncTimeGuard(canisterIdOverride?: Principal): Promise<void> {\n    if (this.#shouldSyncTime && this.#timeDiffMsecs === 0) {\n      await this.syncTime(canisterIdOverride);\n    }\n  }\n\n  public invalidateIdentity(): void {\n    this.#identity = null;\n  }\n\n  public replaceIdentity(identity: Identity): void {\n    this.#identity = Promise.resolve(identity);\n  }\n\n  public async fetchSubnetKeys(canisterId: Principal | string) {\n    const effectiveCanisterId: Principal = Principal.from(canisterId);\n    await this.#asyncGuard(effectiveCanisterId);\n    const response = await canisterStatusRequest({\n      canisterId: effectiveCanisterId,\n      paths: ['subnet'],\n      agent: this,\n    });\n\n    const subnetResponse = response.get('subnet');\n    if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n      this.#subnetKeys.set(effectiveCanisterId.toText(), subnetResponse as SubnetStatus);\n      return subnetResponse as SubnetStatus;\n    }\n    // If the subnet status is not returned, return undefined\n    return undefined;\n  }\n\n  protected _transform(request: HttpAgentRequest): Promise<HttpAgentRequest> {\n    let p = Promise.resolve(request);\n    if (request.endpoint === Endpoint.Call) {\n      for (const fn of this.#updatePipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    } else {\n      for (const fn of this.#queryPipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    }\n\n    return p;\n  }\n}\n\n/**\n * Calculates the ingress expiry time based on the maximum allowed expiry in minutes and the time difference in milliseconds.\n * @param maxIngressExpiryInMinutes - The maximum ingress expiry time in minutes.\n * @param timeDiffMsecs - The time difference in milliseconds to adjust the expiry.\n * @returns The calculated ingress expiry as an Expiry object.\n */\nexport function calculateIngressExpiry(\n  maxIngressExpiryInMinutes: number,\n  timeDiffMsecs: number,\n): Expiry {\n  return Expiry.fromDeltaInMilliseconds(\n    maxIngressExpiryInMinutes * MINUTE_TO_MSECS + timeDiffMsecs,\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}