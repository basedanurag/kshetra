{"ast":null,"code":"import { Principal } from '@dfinity/principal';\nimport { requestIdOf } from \"./request_id.js\";\nimport { bytesToHex, concatBytes } from '@noble/hashes/utils';\nimport { IC_REQUEST_DOMAIN_SEPARATOR } from \"./constants.js\";\n/**\n * An Identity that can sign blobs.\n */\nexport class SignIdentity {\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  getPrincipal() {\n    if (!this._principal) {\n      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n    }\n    return this._principal;\n  }\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   * @param request - internet computer request to transform\n   */\n  async transformRequest(request) {\n    const {\n      body,\n      ...fields\n    } = request;\n    const requestId = requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_pubkey: this.getPublicKey().toDer(),\n        sender_sig: await this.sign(concatBytes(IC_REQUEST_DOMAIN_SEPARATOR, requestId))\n      }\n    };\n  }\n}\nexport class AnonymousIdentity {\n  getPrincipal() {\n    return Principal.anonymous();\n  }\n  async transformRequest(request) {\n    return {\n      ...request,\n      body: {\n        content: request.body\n      }\n    };\n  }\n}\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nexport function createIdentityDescriptor(identity) {\n  const identityIndicator = 'getPublicKey' in identity ? {\n    type: 'PublicKeyIdentity',\n    publicKey: bytesToHex(identity.getPublicKey().toDer())\n  } : {\n    type: 'AnonymousIdentity'\n  };\n  return identityIndicator;\n}","map":{"version":3,"names":["Principal","requestIdOf","bytesToHex","concatBytes","IC_REQUEST_DOMAIN_SEPARATOR","SignIdentity","getPrincipal","_principal","selfAuthenticating","Uint8Array","getPublicKey","toDer","transformRequest","request","body","fields","requestId","content","sender_pubkey","sender_sig","sign","AnonymousIdentity","anonymous","createIdentityDescriptor","identity","identityIndicator","type","publicKey"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\auth.ts"],"sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { type HttpAgentRequest } from './agent/http/types.ts';\nimport { requestIdOf } from './request_id.ts';\nimport { bytesToHex, concatBytes } from '@noble/hashes/utils';\nimport { IC_REQUEST_DOMAIN_SEPARATOR } from './constants.ts';\n/**\n * A Key Pair, containing a secret and public key.\n */\nexport interface KeyPair {\n  secretKey: Uint8Array;\n  publicKey: PublicKey;\n}\n\n/**\n * A public key that is DER encoded. This is a branded Uint8Array.\n */\nexport type DerEncodedPublicKey = Uint8Array & { __derEncodedPublicKey__?: void };\n\n/**\n * A signature array buffer.\n */\nexport type Signature = Uint8Array & { __signature__: void };\n\n/**\n * A Public Key implementation.\n */\nexport interface PublicKey {\n  toDer(): DerEncodedPublicKey;\n  // rawKey, toRaw, and derKey are optional for backwards compatibility.\n  toRaw?(): Uint8Array;\n  rawKey?: Uint8Array;\n  derKey?: DerEncodedPublicKey;\n}\n\n/**\n * A General Identity object. This does not have to be a private key (for example,\n * the Anonymous identity), but it must be able to transform request.\n */\nexport interface Identity {\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  getPrincipal(): Principal;\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   */\n  transformRequest(request: HttpAgentRequest): Promise<unknown>;\n}\n\n/**\n * An Identity that can sign blobs.\n */\nexport abstract class SignIdentity implements Identity {\n  protected _principal: Principal | undefined;\n\n  /**\n   * Returns the public key that would match this identity's signature.\n   */\n  public abstract getPublicKey(): PublicKey;\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   */\n  public abstract sign(blob: Uint8Array): Promise<Signature>;\n\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  public getPrincipal(): Principal {\n    if (!this._principal) {\n      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n    }\n    return this._principal;\n  }\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   * @param request - internet computer request to transform\n   */\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_pubkey: this.getPublicKey().toDer(),\n        sender_sig: await this.sign(concatBytes(IC_REQUEST_DOMAIN_SEPARATOR, requestId)),\n      },\n    };\n  }\n}\n\nexport class AnonymousIdentity implements Identity {\n  public getPrincipal(): Principal {\n    return Principal.anonymous();\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    return {\n      ...request,\n      body: { content: request.body },\n    };\n  }\n}\n\n/*\n * We need to communicate with other agents on the page about identities,\n * but those messages may need to go across boundaries where it's not possible to\n * serialize/deserialize object prototypes easily.\n * So these are lightweight, serializable objects that contain enough information to recreate\n * SignIdentities, but don't commit to having all methods of SignIdentity.\n *\n * Use Case:\n * * DOM Events that let differently-versioned components communicate to one another about\n *   Identities, even if they're using slightly different versions of agent packages to\n *   create/interpret them.\n */\nexport interface AnonymousIdentityDescriptor {\n  type: 'AnonymousIdentity';\n}\nexport interface PublicKeyIdentityDescriptor {\n  type: 'PublicKeyIdentity';\n  publicKey: string;\n}\nexport type IdentityDescriptor = AnonymousIdentityDescriptor | PublicKeyIdentityDescriptor;\n\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nexport function createIdentityDescriptor(\n  identity: SignIdentity | AnonymousIdentity,\n): IdentityDescriptor {\n  const identityIndicator: IdentityDescriptor =\n    'getPublicKey' in identity\n      ? { type: 'PublicKeyIdentity', publicKey: bytesToHex(identity.getPublicKey().toDer()) }\n      : { type: 'AnonymousIdentity' };\n  return identityIndicator;\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,oBAAoB;AAE9C,SAASC,WAAW,QAAQ,iBAAiB;AAC7C,SAASC,UAAU,EAAEC,WAAW,QAAQ,qBAAqB;AAC7D,SAASC,2BAA2B,QAAQ,gBAAgB;AAiD5D;;;AAGA,OAAM,MAAgBC,YAAY;EAahC;;;;EAIOC,YAAYA,CAAA;IACjB,IAAI,CAAC,IAAI,CAACC,UAAU,EAAE;MACpB,IAAI,CAACA,UAAU,GAAGP,SAAS,CAACQ,kBAAkB,CAAC,IAAIC,UAAU,CAAC,IAAI,CAACC,YAAY,EAAE,CAACC,KAAK,EAAE,CAAC,CAAC;IAC7F;IACA,OAAO,IAAI,CAACJ,UAAU;EACxB;EAEA;;;;;;EAMO,MAAMK,gBAAgBA,CAACC,OAAyB;IACrD,MAAM;MAAEC,IAAI;MAAE,GAAGC;IAAM,CAAE,GAAGF,OAAO;IACnC,MAAMG,SAAS,GAAGf,WAAW,CAACa,IAAI,CAAC;IACnC,OAAO;MACL,GAAGC,MAAM;MACTD,IAAI,EAAE;QACJG,OAAO,EAAEH,IAAI;QACbI,aAAa,EAAE,IAAI,CAACR,YAAY,EAAE,CAACC,KAAK,EAAE;QAC1CQ,UAAU,EAAE,MAAM,IAAI,CAACC,IAAI,CAACjB,WAAW,CAACC,2BAA2B,EAAEY,SAAS,CAAC;;KAElF;EACH;;AAGF,OAAM,MAAOK,iBAAiB;EACrBf,YAAYA,CAAA;IACjB,OAAON,SAAS,CAACsB,SAAS,EAAE;EAC9B;EAEO,MAAMV,gBAAgBA,CAACC,OAAyB;IACrD,OAAO;MACL,GAAGA,OAAO;MACVC,IAAI,EAAE;QAAEG,OAAO,EAAEJ,OAAO,CAACC;MAAI;KAC9B;EACH;;AAwBF;;;;AAIA,OAAM,SAAUS,wBAAwBA,CACtCC,QAA0C;EAE1C,MAAMC,iBAAiB,GACrB,cAAc,IAAID,QAAQ,GACtB;IAAEE,IAAI,EAAE,mBAAmB;IAAEC,SAAS,EAAEzB,UAAU,CAACsB,QAAQ,CAACd,YAAY,EAAE,CAACC,KAAK,EAAE;EAAC,CAAE,GACrF;IAAEe,IAAI,EAAE;EAAmB,CAAE;EACnC,OAAOD,iBAAiB;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}