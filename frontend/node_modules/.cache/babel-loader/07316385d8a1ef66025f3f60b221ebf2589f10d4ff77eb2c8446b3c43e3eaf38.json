{"ast":null,"code":"import { SignIdentity, ED25519_OID, unwrapDER, wrapDER } from '@dfinity/agent';\nimport { uint8Equals, uint8FromBufLike } from '@dfinity/candid';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\nexport class Ed25519PublicKey {\n  /**\n   * Construct Ed25519PublicKey from an existing PublicKey\n   * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string\n   * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey\n   */\n  static from(maybeKey) {\n    if (typeof maybeKey === 'string') {\n      const key = hexToBytes(maybeKey);\n      return this.fromRaw(key);\n    } else if (isObject(maybeKey)) {\n      const key = maybeKey;\n      if (isObject(key) && Object.hasOwnProperty.call(key, '__derEncodedPublicKey__')) {\n        return this.fromDer(key);\n      } else if (ArrayBuffer.isView(key)) {\n        const view = key;\n        return this.fromRaw(uint8FromBufLike(view.buffer));\n      } else if (key instanceof ArrayBuffer) {\n        return this.fromRaw(uint8FromBufLike(key));\n      } else if ('rawKey' in key && key.rawKey instanceof Uint8Array) {\n        return this.fromRaw(key.rawKey);\n      } else if ('derKey' in key) {\n        return this.fromDer(key.derKey);\n      } else if ('toDer' in key) {\n        return this.fromDer(key.toDer());\n      }\n    }\n    throw new Error('Cannot construct Ed25519PublicKey from the provided key.');\n  }\n  static fromRaw(rawKey) {\n    return new Ed25519PublicKey(rawKey);\n  }\n  static fromDer(derKey) {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n  // The length of Ed25519 public keys is always 32 bytes.\n  static {\n    this.RAW_KEY_LENGTH = 32;\n  }\n  static derEncode(publicKey) {\n    const key = wrapDER(publicKey, ED25519_OID);\n    key.__derEncodedPublicKey__ = undefined;\n    return key;\n  }\n  static derDecode(key) {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n  #rawKey;\n  get rawKey() {\n    return this.#rawKey;\n  }\n  #derKey;\n  get derKey() {\n    return this.#derKey;\n  }\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  constructor(key) {\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    this.#rawKey = key;\n    this.#derKey = Ed25519PublicKey.derEncode(key);\n  }\n  toDer() {\n    return this.derKey;\n  }\n  toRaw() {\n    return this.rawKey;\n  }\n}\n/**\n * Ed25519KeyIdentity is an implementation of SignIdentity that uses Ed25519 keys. This class is used to sign and verify messages for an agent.\n */\nexport class Ed25519KeyIdentity extends SignIdentity {\n  /**\n   * Generate a new Ed25519KeyIdentity.\n   * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.\n   * @returns Ed25519KeyIdentity\n   */\n  static generate(seed) {\n    if (seed && seed.length !== 32) {\n      throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n    }\n    if (!seed) seed = ed25519.utils.randomPrivateKey();\n    // Check if the seed is all zeros\n    if (uint8Equals(seed, new Uint8Array(new Array(32).fill(0)))) {\n      console.warn('Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.');\n    }\n    const sk = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) {\n      sk[i] = seed[i];\n    }\n    const pk = ed25519.getPublicKey(sk);\n    return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n  }\n  static fromParsedJson(obj) {\n    const [publicKeyDer, privateKeyRaw] = obj;\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromDer(hexToBytes(publicKeyDer)), hexToBytes(privateKeyRaw));\n  }\n  static fromJSON(json) {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      } else {\n        throw new Error('Deserialization error: JSON must have at least 2 items.');\n      }\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n  static fromKeyPair(publicKey, privateKey) {\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n  }\n  static fromSecretKey(secretKey) {\n    const publicKey = ed25519.getPublicKey(secretKey);\n    return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n  }\n  #publicKey;\n  #privateKey;\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  constructor(publicKey, privateKey) {\n    super();\n    this.#publicKey = Ed25519PublicKey.from(publicKey);\n    this.#privateKey = privateKey;\n  }\n  /**\n   * Serialize this key to JSON.\n   */\n  toJSON() {\n    return [bytesToHex(this.#publicKey.toDer()), bytesToHex(this.#privateKey)];\n  }\n  /**\n   * Return a copy of the key pair.\n   */\n  getKeyPair() {\n    return {\n      secretKey: this.#privateKey,\n      publicKey: this.#publicKey\n    };\n  }\n  /**\n   * Return the public key.\n   */\n  getPublicKey() {\n    return this.#publicKey;\n  }\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n   */\n  async sign(challenge) {\n    // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n    const signature = ed25519.sign(challenge, this.#privateKey.slice(0, 32));\n    // add { __signature__: void; } to the signature to make it compatible with the agent\n    Object.defineProperty(signature, '__signature__', {\n      enumerable: false,\n      value: undefined\n    });\n    return signature;\n  }\n  /**\n   * Verify\n   * @param sig - signature to verify\n   * @param msg - message to verify\n   * @param pk - public key\n   * @returns - true if the signature is valid, false otherwise\n   */\n  static verify(sig, msg, pk) {\n    const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n      if (typeof x === 'string') {\n        x = hexToBytes(x);\n      }\n      return uint8FromBufLike(x);\n    });\n    return ed25519.verify(signature, message, publicKey);\n  }\n}","map":{"version":3,"names":["SignIdentity","ED25519_OID","unwrapDER","wrapDER","uint8Equals","uint8FromBufLike","ed25519","bytesToHex","hexToBytes","isObject","value","Ed25519PublicKey","from","maybeKey","key","fromRaw","Object","hasOwnProperty","call","fromDer","ArrayBuffer","isView","view","buffer","rawKey","Uint8Array","derKey","toDer","Error","derDecode","RAW_KEY_LENGTH","derEncode","publicKey","__derEncodedPublicKey__","undefined","unwrapped","length","constructor","byteLength","toRaw","Ed25519KeyIdentity","generate","seed","utils","randomPrivateKey","Array","fill","console","warn","sk","i","pk","getPublicKey","fromKeyPair","fromParsedJson","obj","publicKeyDer","privateKeyRaw","fromJSON","json","parsed","JSON","parse","isArray","stringify","privateKey","fromSecretKey","secretKey","toJSON","getKeyPair","sign","challenge","signature","slice","defineProperty","enumerable","verify","sig","msg","message","map","x"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\identity\\src\\identity\\ed25519.ts"],"sourcesContent":["import {\n  type DerEncodedPublicKey,\n  type KeyPair,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n  ED25519_OID,\n  unwrapDER,\n  wrapDER,\n} from '@dfinity/agent';\nimport { uint8Equals, uint8FromBufLike } from '@dfinity/candid';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\ndeclare type KeyLike = PublicKey | DerEncodedPublicKey | ArrayBuffer | ArrayBufferView;\n\nfunction isObject(value: unknown) {\n  return value !== null && typeof value === 'object';\n}\n\nexport class Ed25519PublicKey implements PublicKey {\n  /**\n   * Construct Ed25519PublicKey from an existing PublicKey\n   * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string\n   * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey\n   */\n  public static from(maybeKey: unknown): Ed25519PublicKey {\n    if (typeof maybeKey === 'string') {\n      const key = hexToBytes(maybeKey);\n      return this.fromRaw(key);\n    } else if (isObject(maybeKey)) {\n      const key = maybeKey as KeyLike;\n      if (isObject(key) && Object.hasOwnProperty.call(key, '__derEncodedPublicKey__')) {\n        return this.fromDer(key as DerEncodedPublicKey);\n      } else if (ArrayBuffer.isView(key)) {\n        const view = key as ArrayBufferView;\n        return this.fromRaw(uint8FromBufLike(view.buffer));\n      } else if (key instanceof ArrayBuffer) {\n        return this.fromRaw(uint8FromBufLike(key));\n      } else if ('rawKey' in key && key.rawKey instanceof Uint8Array) {\n        return this.fromRaw(key.rawKey);\n      } else if ('derKey' in key) {\n        return this.fromDer(key.derKey as DerEncodedPublicKey);\n      } else if ('toDer' in key) {\n        return this.fromDer(key.toDer());\n      }\n    }\n    throw new Error('Cannot construct Ed25519PublicKey from the provided key.');\n  }\n\n  public static fromRaw(rawKey: Uint8Array): Ed25519PublicKey {\n    return new Ed25519PublicKey(rawKey);\n  }\n\n  public static fromDer(derKey: DerEncodedPublicKey): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n\n  // The length of Ed25519 public keys is always 32 bytes.\n  private static RAW_KEY_LENGTH = 32;\n\n  private static derEncode(publicKey: Uint8Array): DerEncodedPublicKey {\n    const key = wrapDER(publicKey, ED25519_OID) as DerEncodedPublicKey;\n    key.__derEncodedPublicKey__ = undefined;\n    return key;\n  }\n\n  private static derDecode(key: DerEncodedPublicKey): Uint8Array {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n\n  #rawKey: Uint8Array;\n\n  public get rawKey(): Uint8Array {\n    return this.#rawKey;\n  }\n\n  #derKey: DerEncodedPublicKey;\n\n  public get derKey(): DerEncodedPublicKey {\n    return this.#derKey;\n  }\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  private constructor(key: Uint8Array) {\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    this.#rawKey = key;\n    this.#derKey = Ed25519PublicKey.derEncode(key);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this.derKey;\n  }\n\n  public toRaw(): Uint8Array {\n    return this.rawKey;\n  }\n}\n\n/**\n * Ed25519KeyIdentity is an implementation of SignIdentity that uses Ed25519 keys. This class is used to sign and verify messages for an agent.\n */\nexport class Ed25519KeyIdentity extends SignIdentity {\n  /**\n   * Generate a new Ed25519KeyIdentity.\n   * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.\n   * @returns Ed25519KeyIdentity\n   */\n  public static generate(seed?: Uint8Array): Ed25519KeyIdentity {\n    if (seed && seed.length !== 32) {\n      throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n    }\n    if (!seed) seed = ed25519.utils.randomPrivateKey();\n    // Check if the seed is all zeros\n    if (uint8Equals(seed, new Uint8Array(new Array(32).fill(0)))) {\n      console.warn(\n        'Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.',\n      );\n    }\n    const sk = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) {\n      sk[i] = seed[i];\n    }\n\n    const pk = ed25519.getPublicKey(sk);\n    return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n  }\n\n  public static fromParsedJson(obj: JsonnableEd25519KeyIdentity): Ed25519KeyIdentity {\n    const [publicKeyDer, privateKeyRaw] = obj;\n    return new Ed25519KeyIdentity(\n      Ed25519PublicKey.fromDer(hexToBytes(publicKeyDer) as DerEncodedPublicKey),\n      hexToBytes(privateKeyRaw),\n    );\n  }\n\n  public static fromJSON(json: string): Ed25519KeyIdentity {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      } else {\n        throw new Error('Deserialization error: JSON must have at least 2 items.');\n      }\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n\n  public static fromKeyPair(publicKey: Uint8Array, privateKey: Uint8Array): Ed25519KeyIdentity {\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n  }\n\n  public static fromSecretKey(secretKey: Uint8Array): Ed25519KeyIdentity {\n    const publicKey = ed25519.getPublicKey(secretKey);\n    return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n  }\n\n  #publicKey: Ed25519PublicKey;\n  #privateKey: Uint8Array;\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  protected constructor(publicKey: PublicKey, privateKey: Uint8Array) {\n    super();\n    this.#publicKey = Ed25519PublicKey.from(publicKey);\n    this.#privateKey = privateKey;\n  }\n\n  /**\n   * Serialize this key to JSON.\n   */\n  public toJSON(): JsonnableEd25519KeyIdentity {\n    return [bytesToHex(this.#publicKey.toDer()), bytesToHex(this.#privateKey)];\n  }\n\n  /**\n   * Return a copy of the key pair.\n   */\n  public getKeyPair(): KeyPair {\n    return {\n      secretKey: this.#privateKey,\n      publicKey: this.#publicKey,\n    };\n  }\n\n  /**\n   * Return the public key.\n   */\n  public getPublicKey(): Required<PublicKey> {\n    return this.#publicKey;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n   */\n  public async sign(challenge: Uint8Array): Promise<Signature> {\n    // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n    const signature = ed25519.sign(challenge, this.#privateKey.slice(0, 32));\n    // add { __signature__: void; } to the signature to make it compatible with the agent\n\n    Object.defineProperty(signature, '__signature__', {\n      enumerable: false,\n      value: undefined,\n    });\n\n    return signature as Signature;\n  }\n\n  /**\n   * Verify\n   * @param sig - signature to verify\n   * @param msg - message to verify\n   * @param pk - public key\n   * @returns - true if the signature is valid, false otherwise\n   */\n  public static verify(\n    sig: ArrayBuffer | Uint8Array | string,\n    msg: ArrayBuffer | Uint8Array | string,\n    pk: ArrayBuffer | Uint8Array | string,\n  ) {\n    const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n      if (typeof x === 'string') {\n        x = hexToBytes(x);\n      }\n      return uint8FromBufLike(x);\n    });\n    return ed25519.verify(signature, message, publicKey);\n  }\n}\n\ntype PublicKeyHex = string;\ntype SecretKeyHex = string;\nexport type JsonnableEd25519KeyIdentity = [PublicKeyHex, SecretKeyHex];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}