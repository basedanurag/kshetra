{"ast":null,"code":"import { AnonymousIdentity, SignIdentity } from '@dfinity/agent';\nimport { Delegation, DelegationChain, isDelegationValid, DelegationIdentity, Ed25519KeyIdentity, ECDSAKeyIdentity, PartialDelegationIdentity, PartialIdentity } from '@dfinity/identity';\nimport { Principal } from '@dfinity/principal';\nimport { IdleManager } from \"./idleManager.js\";\nimport { IdbStorage, isBrowser, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY, KEY_VECTOR, LocalStorage } from \"./storage.js\";\nexport { IdbStorage, LocalStorage, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from \"./storage.js\";\nexport { IdbKeyVal } from \"./db.js\";\nconst NANOSECONDS_PER_SECOND = BigInt(1_000_000_000);\nconst SECONDS_PER_HOUR = BigInt(3_600);\nconst NANOSECONDS_PER_HOUR = NANOSECONDS_PER_SECOND * SECONDS_PER_HOUR;\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.internetcomputer.org';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\nconst DEFAULT_MAX_TIME_TO_LIVE = BigInt(8) * NANOSECONDS_PER_HOUR;\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\nconst INTERRUPT_CHECK_INTERVAL = 500;\nexport const ERROR_USER_INTERRUPT = 'UserInterrupt';\nexport * from \"./idleManager.js\";\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nexport class AuthClient {\n  _identity;\n  _key;\n  _chain;\n  _storage;\n  idleManager;\n  _createOptions;\n  _idpWindow;\n  _eventHandler;\n  /**\n   * Create an AuthClient to manage authentication and identity\n   * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}\n   * @see {@link AuthClientCreateOptions}\n   * @param options.identity Optional Identity to use as the base\n   * @see {@link SignIdentity}\n   * @param options.storage Storage mechanism for delegation credentials\n   * @see {@link AuthClientStorage}\n   * @param options.keyType Type of key to use for the base key\n   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n   * @see {@link IdleOptions}\n   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n   * @example\n   * const authClient = await AuthClient.create({\n   *   idleOptions: {\n   *     disableIdle: true\n   *   }\n   * })\n   */\n  static async create(options = {}) {\n    const storage = options.storage ?? new IdbStorage();\n    const keyType = options.keyType ?? ECDSA_KEY_LABEL;\n    let key = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);\n      if (!maybeIdentityStorage && isBrowser) {\n        // Attempt to migrate from localstorage\n        try {\n          const fallbackLocalStorage = new LocalStorage();\n          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);\n          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);\n          // not relevant for Ed25519\n          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n            console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n            await storage.set(KEY_STORAGE_DELEGATION, localChain);\n            await storage.set(KEY_STORAGE_KEY, localKey);\n            maybeIdentityStorage = localChain;\n            // clean up\n            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);\n            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);\n          }\n        } catch (error) {\n          console.error('error while attempting to recover localstorage: ' + error);\n        }\n      }\n      if (maybeIdentityStorage) {\n        try {\n          if (typeof maybeIdentityStorage === 'object') {\n            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n              key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n            } else {\n              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n            }\n          } else if (typeof maybeIdentityStorage === 'string') {\n            // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n          }\n        } catch {\n          // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n          // serialization.\n        }\n      }\n    }\n    let identity = new AnonymousIdentity();\n    let chain = null;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);\n        if (typeof chainStorage === 'object' && chainStorage !== null) {\n          throw new Error('Delegation chain is incorrectly stored. A delegation chain should be stored as a string.');\n        }\n        if (options.identity) {\n          identity = options.identity;\n        } else if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            // If the key is a public key, then we create a PartialDelegationIdentity.\n            if ('toDer' in key) {\n              identity = PartialDelegationIdentity.fromDelegation(key, chain);\n              // otherwise, we create a DelegationIdentity.\n            } else {\n              identity = DelegationIdentity.fromDelegation(key, chain);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let idleManager;\n    if (options.idleOptions?.disableIdle) {\n      idleManager = undefined;\n    }\n    // if there is a delegation chain or provided identity, setup idleManager\n    else if (chain || options.identity) {\n      idleManager = IdleManager.create(options.idleOptions);\n    }\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      if (keyType === ED25519_KEY_LABEL) {\n        key = Ed25519KeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, JSON.stringify(key.toJSON()));\n      } else {\n        if (options.storage && keyType === ECDSA_KEY_LABEL) {\n          console.warn(`You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`);\n        }\n        key = await ECDSAKeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, key.getKeyPair());\n      }\n    }\n    return new this(identity, key, chain, storage, idleManager, options);\n  }\n  constructor(_identity, _key, _chain, _storage, idleManager, _createOptions,\n  // A handle on the IdP window.\n  _idpWindow,\n  // The event handler for processing events from the IdP.\n  _eventHandler) {\n    this._identity = _identity;\n    this._key = _key;\n    this._chain = _chain;\n    this._storage = _storage;\n    this.idleManager = idleManager;\n    this._createOptions = _createOptions;\n    this._idpWindow = _idpWindow;\n    this._eventHandler = _eventHandler;\n    this._registerDefaultIdleCallback();\n  }\n  _registerDefaultIdleCallback() {\n    const idleOptions = this._createOptions?.idleOptions;\n    /**\n     * Default behavior is to clear stored identity and reload the page.\n     * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n     */\n    if (!idleOptions?.onIdle && !idleOptions?.disableDefaultIdleCallback) {\n      this.idleManager?.registerCallback(() => {\n        this.logout();\n        location.reload();\n      });\n    }\n  }\n  async _handleSuccess(message, onSuccess) {\n    const delegations = message.delegations.map(signedDelegation => {\n      return {\n        delegation: new Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),\n        signature: signedDelegation.signature\n      };\n    });\n    const delegationChain = DelegationChain.fromDelegations(delegations, message.userPublicKey);\n    const key = this._key;\n    if (!key) {\n      return;\n    }\n    this._chain = delegationChain;\n    if ('toDer' in key) {\n      this._identity = PartialDelegationIdentity.fromDelegation(key, this._chain);\n    } else {\n      this._identity = DelegationIdentity.fromDelegation(key, this._chain);\n    }\n    this._idpWindow?.close();\n    const idleOptions = this._createOptions?.idleOptions;\n    // create the idle manager on a successful login if we haven't disabled it\n    // and it doesn't already exist.\n    if (!this.idleManager && !idleOptions?.disableIdle) {\n      this.idleManager = IdleManager.create(idleOptions);\n      this._registerDefaultIdleCallback();\n    }\n    this._removeEventListener();\n    delete this._idpWindow;\n    if (this._chain) {\n      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n    }\n    // onSuccess should be the last thing to do to avoid consumers\n    // interfering by navigating or refreshing the page\n    onSuccess?.(message);\n  }\n  getIdentity() {\n    return this._identity;\n  }\n  async isAuthenticated() {\n    return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null && isDelegationValid(this._chain);\n  }\n  /**\n   * AuthClient Login - Opens up a new window to authenticate with Internet Identity\n   * @param {AuthClientLoginOptions} options - Options for logging in, merged with the options set during creation if any. Note: we only perform a shallow merge for the `customValues` property.\n   * @param options.identityProvider Identity provider\n   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n   * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n   * @param options.windowOpenerFeatures Configures the opened authentication window\n   * @param options.onSuccess Callback once login has completed\n   * @param options.onError Callback in case authentication fails\n   * @param options.customValues Extra values to be passed in the login request during the authorize-ready phase. Note: we only perform a shallow merge for the `customValues` property.\n   * @example\n   * const authClient = await AuthClient.create();\n   * authClient.login({\n   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n   *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n   *  onSuccess: () => {\n   *    console.log('Login Successful!');\n   *  },\n   *  onError: (error) => {\n   *    console.error('Login Failed: ', error);\n   *  }\n   * });\n   */\n  async login(options) {\n    // Merge the passed options with the options set during creation\n    const loginOptions = mergeLoginOptions(this._createOptions?.loginOptions, options);\n    // Set default maxTimeToLive to 8 hours\n    const maxTimeToLive = loginOptions?.maxTimeToLive ?? DEFAULT_MAX_TIME_TO_LIVE;\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(loginOptions?.identityProvider?.toString() || IDENTITY_PROVIDER_DEFAULT);\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    this._idpWindow?.close();\n    this._removeEventListener();\n    // Add an event listener to handle responses.\n    this._eventHandler = this._getEventHandler(identityProviderUrl, {\n      maxTimeToLive,\n      ...loginOptions\n    });\n    window.addEventListener('message', this._eventHandler);\n    // Open a new window with the IDP provider.\n    this._idpWindow = window.open(identityProviderUrl.toString(), 'idpWindow', loginOptions?.windowOpenerFeatures) ?? undefined;\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = () => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (this._idpWindow) {\n        if (this._idpWindow.closed) {\n          this._handleFailure(ERROR_USER_INTERRUPT, loginOptions?.onError);\n        } else {\n          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n        }\n      }\n    };\n    checkInterruption();\n  }\n  _getEventHandler(identityProviderUrl, options) {\n    return async event => {\n      if (event.origin !== identityProviderUrl.origin) {\n        // Ignore any event that is not from the identity provider\n        return;\n      }\n      const message = event.data;\n      switch (message.kind) {\n        case 'authorize-ready':\n          {\n            // IDP is ready. Send a message to request authorization.\n            const request = {\n              kind: 'authorize-client',\n              sessionPublicKey: new Uint8Array(this._key?.getPublicKey().toDer()),\n              maxTimeToLive: options?.maxTimeToLive,\n              allowPinAuthentication: options?.allowPinAuthentication,\n              derivationOrigin: options?.derivationOrigin?.toString(),\n              // Pass any custom values to the IDP.\n              ...options?.customValues\n            };\n            this._idpWindow?.postMessage(request, identityProviderUrl.origin);\n            break;\n          }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            await this._handleSuccess(message, options?.onSuccess);\n          } catch (err) {\n            this._handleFailure(err.message, options?.onError);\n          }\n          break;\n        case 'authorize-client-failure':\n          this._handleFailure(message.text, options?.onError);\n          break;\n        default:\n          break;\n      }\n    };\n  }\n  _handleFailure(errorMessage, onError) {\n    this._idpWindow?.close();\n    onError?.(errorMessage);\n    this._removeEventListener();\n    delete this._idpWindow;\n  }\n  _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n  async logout(options = {}) {\n    await _deleteStorage(this._storage);\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._chain = null;\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\nasync function _deleteStorage(storage) {\n  await storage.remove(KEY_STORAGE_KEY);\n  await storage.remove(KEY_STORAGE_DELEGATION);\n  await storage.remove(KEY_VECTOR);\n}\nfunction mergeLoginOptions(loginOptions, otherLoginOptions) {\n  if (!loginOptions && !otherLoginOptions) {\n    return undefined;\n  }\n  const customValues = loginOptions?.customValues || otherLoginOptions?.customValues ? {\n    ...loginOptions?.customValues,\n    ...otherLoginOptions?.customValues\n  } : undefined;\n  return {\n    ...loginOptions,\n    ...otherLoginOptions,\n    customValues\n  };\n}","map":{"version":3,"names":["AnonymousIdentity","SignIdentity","Delegation","DelegationChain","isDelegationValid","DelegationIdentity","Ed25519KeyIdentity","ECDSAKeyIdentity","PartialDelegationIdentity","PartialIdentity","Principal","IdleManager","IdbStorage","isBrowser","KEY_STORAGE_DELEGATION","KEY_STORAGE_KEY","KEY_VECTOR","LocalStorage","IdbKeyVal","NANOSECONDS_PER_SECOND","BigInt","SECONDS_PER_HOUR","NANOSECONDS_PER_HOUR","IDENTITY_PROVIDER_DEFAULT","IDENTITY_PROVIDER_ENDPOINT","DEFAULT_MAX_TIME_TO_LIVE","ECDSA_KEY_LABEL","ED25519_KEY_LABEL","INTERRUPT_CHECK_INTERVAL","ERROR_USER_INTERRUPT","AuthClient","_identity","_key","_chain","_storage","idleManager","_createOptions","_idpWindow","_eventHandler","create","options","storage","keyType","key","identity","maybeIdentityStorage","get","fallbackLocalStorage","localChain","localKey","console","log","set","remove","error","fromJSON","fromKeyPair","chain","chainStorage","Error","_deleteStorage","fromDelegation","e","idleOptions","disableIdle","undefined","generate","JSON","stringify","toJSON","warn","getKeyPair","constructor","_registerDefaultIdleCallback","onIdle","disableDefaultIdleCallback","registerCallback","logout","location","reload","_handleSuccess","message","onSuccess","delegations","map","signedDelegation","delegation","pubkey","expiration","targets","signature","delegationChain","fromDelegations","userPublicKey","close","_removeEventListener","getIdentity","isAuthenticated","getPrincipal","isAnonymous","login","loginOptions","mergeLoginOptions","maxTimeToLive","identityProviderUrl","URL","identityProvider","toString","hash","_getEventHandler","window","addEventListener","open","windowOpenerFeatures","checkInterruption","closed","_handleFailure","onError","setTimeout","event","origin","data","kind","request","sessionPublicKey","Uint8Array","getPublicKey","toDer","allowPinAuthentication","derivationOrigin","customValues","postMessage","err","text","errorMessage","removeEventListener","returnTo","history","pushState","href","otherLoginOptions"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\auth-client\\src\\index.ts"],"sourcesContent":["import {\n  AnonymousIdentity,\n  type DerEncodedPublicKey,\n  type Identity,\n  type Signature,\n  SignIdentity,\n} from '@dfinity/agent';\nimport {\n  Delegation,\n  DelegationChain,\n  isDelegationValid,\n  DelegationIdentity,\n  Ed25519KeyIdentity,\n  ECDSAKeyIdentity,\n  PartialDelegationIdentity,\n  PartialIdentity,\n} from '@dfinity/identity';\nimport { Principal } from '@dfinity/principal';\nimport { IdleManager, type IdleManagerOptions } from './idleManager.ts';\nimport {\n  type AuthClientStorage,\n  IdbStorage,\n  isBrowser,\n  KEY_STORAGE_DELEGATION,\n  KEY_STORAGE_KEY,\n  KEY_VECTOR,\n  LocalStorage,\n} from './storage.ts';\n\nexport {\n  type AuthClientStorage,\n  IdbStorage,\n  LocalStorage,\n  KEY_STORAGE_DELEGATION,\n  KEY_STORAGE_KEY,\n} from './storage.ts';\nexport { IdbKeyVal, type DBCreateOptions } from './db.ts';\n\nconst NANOSECONDS_PER_SECOND = BigInt(1_000_000_000);\nconst SECONDS_PER_HOUR = BigInt(3_600);\nconst NANOSECONDS_PER_HOUR = NANOSECONDS_PER_SECOND * SECONDS_PER_HOUR;\n\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.internetcomputer.org';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\n\nconst DEFAULT_MAX_TIME_TO_LIVE = BigInt(8) * NANOSECONDS_PER_HOUR;\n\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\ntype BaseKeyType = typeof ECDSA_KEY_LABEL | typeof ED25519_KEY_LABEL;\n\nconst INTERRUPT_CHECK_INTERVAL = 500;\n\nexport const ERROR_USER_INTERRUPT = 'UserInterrupt';\n\n/**\n * List of options for creating an {@link AuthClient}.\n */\nexport interface AuthClientCreateOptions {\n  /**\n   * An {@link SignIdentity} or {@link PartialIdentity} to authenticate via delegation.\n   */\n  identity?: SignIdentity | PartialIdentity;\n  /**\n   * Optional storage with get, set, and remove. Uses {@link IdbStorage} by default.\n   * @see {@link AuthClientStorage}\n   */\n  storage?: AuthClientStorage;\n\n  /**\n   * Type to use for the base key.\n   *\n   * If you are using a custom storage provider that does not support CryptoKey storage,\n   * you should use `Ed25519` as the key type, as it can serialize to a string.\n   * @default 'ECDSA'\n   */\n  keyType?: BaseKeyType;\n\n  /**\n   * Options to handle idle timeouts\n   * @default after 10 minutes, invalidates the identity\n   */\n  idleOptions?: IdleOptions;\n\n  /**\n   * Options to handle login, passed to the login method\n   */\n  loginOptions?: AuthClientLoginOptions;\n}\n\nexport interface IdleOptions extends IdleManagerOptions {\n  /**\n   * Disables idle functionality for {@link IdleManager}\n   * @default false\n   */\n  disableIdle?: boolean;\n\n  /**\n   * Disables default idle behavior - call logout & reload window\n   * @default false\n   */\n  disableDefaultIdleCallback?: boolean;\n}\n\nexport * from './idleManager.ts';\n\nexport type OnSuccessFunc =\n  | (() => void | Promise<void>)\n  | ((message: InternetIdentityAuthResponseSuccess) => void | Promise<void>);\n\nexport type OnErrorFunc = (error?: string) => void | Promise<void>;\n\nexport interface AuthClientLoginOptions {\n  /**\n   * Identity provider\n   * @default \"https://identity.internetcomputer.org\"\n   */\n  identityProvider?: string | URL;\n  /**\n   * Expiration of the authentication in nanoseconds\n   * @default  BigInt(8) hours * BigInt(3_600_000_000_000) nanoseconds\n   */\n  maxTimeToLive?: bigint;\n  /**\n   * If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   */\n  allowPinAuthentication?: boolean;\n  /**\n   * Origin for Identity Provider to use while generating the delegated identity. For II, the derivation origin must authorize this origin by setting a record at `<derivation-origin>/.well-known/ii-alternative-origins`.\n   * @see https://github.com/dfinity/internet-identity/blob/main/docs/internet-identity-spec.adoc\n   */\n  derivationOrigin?: string | URL;\n  /**\n   * Auth Window feature config string\n   * @example \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\"\n   */\n  windowOpenerFeatures?: string;\n  /**\n   * Callback once login has completed\n   */\n  onSuccess?: OnSuccessFunc;\n  /**\n   * Callback in case authentication fails\n   */\n  onError?: OnErrorFunc;\n  /**\n   * Extra values to be passed in the login request during the authorize-ready phase\n   */\n  customValues?: Record<string, unknown>;\n}\n\ninterface InternetIdentityAuthRequest {\n  kind: 'authorize-client';\n  sessionPublicKey: Uint8Array;\n  maxTimeToLive?: bigint;\n  allowPinAuthentication?: boolean;\n  derivationOrigin?: string;\n}\n\nexport interface InternetIdentityAuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthReadyMessage {\n  kind: 'authorize-ready';\n}\n\ninterface AuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthResponseFailure {\n  kind: 'authorize-client-failure';\n  text: string;\n}\n\ntype IdentityServiceResponseMessage = AuthReadyMessage | AuthResponse;\ntype AuthResponse = AuthResponseSuccess | AuthResponseFailure;\n\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nexport class AuthClient {\n  /**\n   * Create an AuthClient to manage authentication and identity\n   * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}\n   * @see {@link AuthClientCreateOptions}\n   * @param options.identity Optional Identity to use as the base\n   * @see {@link SignIdentity}\n   * @param options.storage Storage mechanism for delegation credentials\n   * @see {@link AuthClientStorage}\n   * @param options.keyType Type of key to use for the base key\n   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n   * @see {@link IdleOptions}\n   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n   * @example\n   * const authClient = await AuthClient.create({\n   *   idleOptions: {\n   *     disableIdle: true\n   *   }\n   * })\n   */\n  public static async create(options: AuthClientCreateOptions = {}): Promise<AuthClient> {\n    const storage = options.storage ?? new IdbStorage();\n    const keyType = options.keyType ?? ECDSA_KEY_LABEL;\n\n    let key: null | SignIdentity | PartialIdentity = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);\n      if (!maybeIdentityStorage && isBrowser) {\n        // Attempt to migrate from localstorage\n        try {\n          const fallbackLocalStorage = new LocalStorage();\n          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);\n          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);\n          // not relevant for Ed25519\n          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n            console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n            await storage.set(KEY_STORAGE_DELEGATION, localChain);\n            await storage.set(KEY_STORAGE_KEY, localKey);\n\n            maybeIdentityStorage = localChain;\n            // clean up\n            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);\n            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);\n          }\n        } catch (error) {\n          console.error('error while attempting to recover localstorage: ' + error);\n        }\n      }\n      if (maybeIdentityStorage) {\n        try {\n          if (typeof maybeIdentityStorage === 'object') {\n            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n              key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n            } else {\n              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n            }\n          } else if (typeof maybeIdentityStorage === 'string') {\n            // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n          }\n        } catch {\n          // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n          // serialization.\n        }\n      }\n    }\n\n    let identity: SignIdentity | PartialIdentity = new AnonymousIdentity() as PartialIdentity;\n    let chain: null | DelegationChain = null;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);\n        if (typeof chainStorage === 'object' && chainStorage !== null) {\n          throw new Error(\n            'Delegation chain is incorrectly stored. A delegation chain should be stored as a string.',\n          );\n        }\n\n        if (options.identity) {\n          identity = options.identity;\n        } else if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            // If the key is a public key, then we create a PartialDelegationIdentity.\n            if ('toDer' in key) {\n              identity = PartialDelegationIdentity.fromDelegation(key, chain);\n              // otherwise, we create a DelegationIdentity.\n            } else {\n              identity = DelegationIdentity.fromDelegation(key, chain);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let idleManager: IdleManager | undefined;\n    if (options.idleOptions?.disableIdle) {\n      idleManager = undefined;\n    }\n    // if there is a delegation chain or provided identity, setup idleManager\n    else if (chain || options.identity) {\n      idleManager = IdleManager.create(options.idleOptions);\n    }\n\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      if (keyType === ED25519_KEY_LABEL) {\n        key = Ed25519KeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, JSON.stringify((key as Ed25519KeyIdentity).toJSON()));\n      } else {\n        if (options.storage && keyType === ECDSA_KEY_LABEL) {\n          console.warn(\n            `You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`,\n          );\n        }\n        key = await ECDSAKeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, (key as ECDSAKeyIdentity).getKeyPair());\n      }\n    }\n\n    return new this(identity, key, chain, storage, idleManager, options);\n  }\n\n  protected constructor(\n    private _identity: Identity | PartialIdentity,\n    private _key: SignIdentity | PartialIdentity,\n    private _chain: DelegationChain | null,\n    private _storage: AuthClientStorage,\n    public idleManager: IdleManager | undefined,\n    private _createOptions: AuthClientCreateOptions | undefined,\n    // A handle on the IdP window.\n    private _idpWindow?: Window,\n    // The event handler for processing events from the IdP.\n    private _eventHandler?: (event: MessageEvent) => void,\n  ) {\n    this._registerDefaultIdleCallback();\n  }\n\n  private _registerDefaultIdleCallback() {\n    const idleOptions = this._createOptions?.idleOptions;\n    /**\n     * Default behavior is to clear stored identity and reload the page.\n     * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n     */\n    if (!idleOptions?.onIdle && !idleOptions?.disableDefaultIdleCallback) {\n      this.idleManager?.registerCallback(() => {\n        this.logout();\n        location.reload();\n      });\n    }\n  }\n\n  private async _handleSuccess(\n    message: InternetIdentityAuthResponseSuccess,\n    onSuccess?: OnSuccessFunc,\n  ) {\n    const delegations = message.delegations.map(signedDelegation => {\n      return {\n        delegation: new Delegation(\n          signedDelegation.delegation.pubkey,\n          signedDelegation.delegation.expiration,\n          signedDelegation.delegation.targets,\n        ),\n        signature: signedDelegation.signature as Signature,\n      };\n    });\n\n    const delegationChain = DelegationChain.fromDelegations(\n      delegations,\n      message.userPublicKey as DerEncodedPublicKey,\n    );\n\n    const key = this._key;\n    if (!key) {\n      return;\n    }\n\n    this._chain = delegationChain;\n\n    if ('toDer' in key) {\n      this._identity = PartialDelegationIdentity.fromDelegation(key, this._chain);\n    } else {\n      this._identity = DelegationIdentity.fromDelegation(key, this._chain);\n    }\n\n    this._idpWindow?.close();\n    const idleOptions = this._createOptions?.idleOptions;\n    // create the idle manager on a successful login if we haven't disabled it\n    // and it doesn't already exist.\n    if (!this.idleManager && !idleOptions?.disableIdle) {\n      this.idleManager = IdleManager.create(idleOptions);\n      this._registerDefaultIdleCallback();\n    }\n\n    this._removeEventListener();\n    delete this._idpWindow;\n\n    if (this._chain) {\n      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n    }\n\n    // onSuccess should be the last thing to do to avoid consumers\n    // interfering by navigating or refreshing the page\n    onSuccess?.(message);\n  }\n\n  public getIdentity(): Identity {\n    return this._identity;\n  }\n\n  public async isAuthenticated(): Promise<boolean> {\n    return (\n      !this.getIdentity().getPrincipal().isAnonymous() &&\n      this._chain !== null &&\n      isDelegationValid(this._chain)\n    );\n  }\n\n  /**\n   * AuthClient Login - Opens up a new window to authenticate with Internet Identity\n   * @param {AuthClientLoginOptions} options - Options for logging in, merged with the options set during creation if any. Note: we only perform a shallow merge for the `customValues` property.\n   * @param options.identityProvider Identity provider\n   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n   * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n   * @param options.windowOpenerFeatures Configures the opened authentication window\n   * @param options.onSuccess Callback once login has completed\n   * @param options.onError Callback in case authentication fails\n   * @param options.customValues Extra values to be passed in the login request during the authorize-ready phase. Note: we only perform a shallow merge for the `customValues` property.\n   * @example\n   * const authClient = await AuthClient.create();\n   * authClient.login({\n   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n   *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n   *  onSuccess: () => {\n   *    console.log('Login Successful!');\n   *  },\n   *  onError: (error) => {\n   *    console.error('Login Failed: ', error);\n   *  }\n   * });\n   */\n  public async login(options?: AuthClientLoginOptions): Promise<void> {\n    // Merge the passed options with the options set during creation\n    const loginOptions = mergeLoginOptions(this._createOptions?.loginOptions, options);\n\n    // Set default maxTimeToLive to 8 hours\n    const maxTimeToLive = loginOptions?.maxTimeToLive ?? DEFAULT_MAX_TIME_TO_LIVE;\n\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(\n      loginOptions?.identityProvider?.toString() || IDENTITY_PROVIDER_DEFAULT,\n    );\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    this._idpWindow?.close();\n    this._removeEventListener();\n\n    // Add an event listener to handle responses.\n    this._eventHandler = this._getEventHandler(identityProviderUrl, {\n      maxTimeToLive,\n      ...loginOptions,\n    });\n    window.addEventListener('message', this._eventHandler);\n\n    // Open a new window with the IDP provider.\n    this._idpWindow =\n      window.open(\n        identityProviderUrl.toString(),\n        'idpWindow',\n        loginOptions?.windowOpenerFeatures,\n      ) ?? undefined;\n\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = (): void => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (this._idpWindow) {\n        if (this._idpWindow.closed) {\n          this._handleFailure(ERROR_USER_INTERRUPT, loginOptions?.onError);\n        } else {\n          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n        }\n      }\n    };\n    checkInterruption();\n  }\n\n  private _getEventHandler(identityProviderUrl: URL, options?: AuthClientLoginOptions) {\n    return async (event: MessageEvent) => {\n      if (event.origin !== identityProviderUrl.origin) {\n        // Ignore any event that is not from the identity provider\n        return;\n      }\n\n      const message = event.data as IdentityServiceResponseMessage;\n\n      switch (message.kind) {\n        case 'authorize-ready': {\n          // IDP is ready. Send a message to request authorization.\n          const request: InternetIdentityAuthRequest = {\n            kind: 'authorize-client',\n            sessionPublicKey: new Uint8Array(this._key?.getPublicKey().toDer()),\n            maxTimeToLive: options?.maxTimeToLive,\n            allowPinAuthentication: options?.allowPinAuthentication,\n            derivationOrigin: options?.derivationOrigin?.toString(),\n            // Pass any custom values to the IDP.\n            ...options?.customValues,\n          };\n          this._idpWindow?.postMessage(request, identityProviderUrl.origin);\n          break;\n        }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            await this._handleSuccess(message, options?.onSuccess);\n          } catch (err) {\n            this._handleFailure((err as Error).message, options?.onError);\n          }\n          break;\n        case 'authorize-client-failure':\n          this._handleFailure(message.text, options?.onError);\n          break;\n        default:\n          break;\n      }\n    };\n  }\n\n  private _handleFailure(errorMessage?: string, onError?: (error?: string) => void): void {\n    this._idpWindow?.close();\n    onError?.(errorMessage);\n    this._removeEventListener();\n    delete this._idpWindow;\n  }\n\n  private _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n\n  public async logout(options: { returnTo?: string } = {}): Promise<void> {\n    await _deleteStorage(this._storage);\n\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._chain = null;\n\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\n\nasync function _deleteStorage(storage: AuthClientStorage) {\n  await storage.remove(KEY_STORAGE_KEY);\n  await storage.remove(KEY_STORAGE_DELEGATION);\n  await storage.remove(KEY_VECTOR);\n}\n\nfunction mergeLoginOptions(\n  loginOptions: AuthClientLoginOptions | undefined,\n  otherLoginOptions: AuthClientLoginOptions | undefined,\n): AuthClientLoginOptions | undefined {\n  if (!loginOptions && !otherLoginOptions) {\n    return undefined;\n  }\n\n  const customValues =\n    loginOptions?.customValues || otherLoginOptions?.customValues\n      ? {\n          ...loginOptions?.customValues,\n          ...otherLoginOptions?.customValues,\n        }\n      : undefined;\n\n  return {\n    ...loginOptions,\n    ...otherLoginOptions,\n    customValues,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}