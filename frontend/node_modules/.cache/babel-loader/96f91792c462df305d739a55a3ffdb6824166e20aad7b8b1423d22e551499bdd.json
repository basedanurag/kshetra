{"ast":null,"code":"import { SignIdentity, wrapDER, DER_COSE_OID, Cbor } from '@dfinity/agent';\nimport { bytesToHex, hexToBytes, randomBytes, bytesToUtf8 } from '@noble/hashes/utils';\nimport { uint8FromBufLike } from '@dfinity/candid';\nfunction _coseToDerEncodedBlob(cose) {\n  return wrapDER(cose, DER_COSE_OID);\n}\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData) {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\nexport class CosePublicKey {\n  constructor(_cose) {\n    this._cose = _cose;\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n  toDer() {\n    return this._encodedKey;\n  }\n  getCose() {\n    return this._cose;\n  }\n}\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge = '<ic0.app>') {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(credentialCreationOptions) {\n  const creds = await navigator.credentials.create(credentialCreationOptions ?? {\n    publicKey: {\n      authenticatorSelection: {\n        userVerification: 'preferred'\n      },\n      attestation: 'direct',\n      challenge: _createChallengeBuffer(),\n      pubKeyCredParams: [{\n        type: 'public-key',\n        alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256\n      }],\n      rp: {\n        name: 'Internet Identity Service'\n      },\n      user: {\n        id: randomBytes(16),\n        name: 'Internet Identity',\n        displayName: 'Internet Identity'\n      }\n    }\n  });\n  if (creds === null) {\n    return null;\n  }\n  return {\n    // do _not_ use ...creds here, as creds is not enumerable in all cases\n    id: creds.id,\n    response: creds.response,\n    type: creds.type,\n    authenticatorAttachment: creds.authenticatorAttachment,\n    getClientExtensionResults: creds.getClientExtensionResults,\n    // Some password managers will return a Uint8Array, so we ensure we return an ArrayBuffer.\n    rawId: creds.rawId,\n    toJSON: creds.toJSON.bind(creds) // Ensure the toJSON method is included\n  };\n}\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nvar PubKeyCoseAlgo;\n(function (PubKeyCoseAlgo) {\n  PubKeyCoseAlgo[PubKeyCoseAlgo[\"ECDSA_WITH_SHA256\"] = -7] = \"ECDSA_WITH_SHA256\";\n})(PubKeyCoseAlgo || (PubKeyCoseAlgo = {}));\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  static fromJSON(json) {\n    const {\n      publicKey,\n      rawId\n    } = JSON.parse(json);\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n    return new this(hexToBytes(rawId), hexToBytes(publicKey), undefined);\n  }\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  static async create(credentialCreationOptions) {\n    const creds = await _createCredential(credentialCreationOptions);\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n    const response = creds.response;\n    if (response.attestationObject === undefined) {\n      throw new Error('Was expecting an attestation response.');\n    }\n    // Parse the attestationObject as CBOR.\n    const attObject = Cbor.decode(new Uint8Array(response.attestationObject));\n    return new this(uint8FromBufLike(creds.rawId), _authDataToCose(attObject.authData), creds.authenticatorAttachment ?? undefined);\n  }\n  constructor(rawId, cose, authenticatorAttachment) {\n    super();\n    this.rawId = rawId;\n    this.authenticatorAttachment = authenticatorAttachment;\n    this._publicKey = new CosePublicKey(cose);\n  }\n  getPublicKey() {\n    return this._publicKey;\n  }\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  getAuthenticatorAttachment() {\n    return this.authenticatorAttachment;\n  }\n  async sign(blob) {\n    const result = await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [{\n          type: 'public-key',\n          id: this.rawId\n        }],\n        challenge: blob,\n        userVerification: 'preferred'\n      }\n    });\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n    const response = result.response;\n    const encoded = Cbor.encode({\n      authenticator_data: response.authenticatorData,\n      client_data_json: bytesToUtf8(new Uint8Array(response.clientDataJSON)),\n      signature: response.signature\n    });\n    if (!encoded) {\n      throw new Error('failed to encode cbor');\n    }\n    Object.assign(encoded, {\n      __signature__: undefined\n    });\n    return encoded;\n  }\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  toJSON() {\n    return {\n      publicKey: bytesToHex(this._publicKey.getCose()),\n      rawId: bytesToHex(this.rawId)\n    };\n  }\n}","map":{"version":3,"names":["SignIdentity","wrapDER","DER_COSE_OID","Cbor","bytesToHex","hexToBytes","randomBytes","bytesToUtf8","uint8FromBufLike","_coseToDerEncodedBlob","cose","_authDataToCose","authData","dataView","DataView","ArrayBuffer","idLenBytes","slice","Uint8Array","forEach","v","i","setUint8","credentialIdLength","getUint16","CosePublicKey","constructor","_cose","_encodedKey","toDer","getCose","_createChallengeBuffer","challenge","from","c","charCodeAt","_createCredential","credentialCreationOptions","creds","navigator","credentials","create","publicKey","authenticatorSelection","userVerification","attestation","pubKeyCredParams","type","alg","PubKeyCoseAlgo","ECDSA_WITH_SHA256","rp","name","user","id","displayName","response","authenticatorAttachment","getClientExtensionResults","rawId","toJSON","bind","WebAuthnIdentity","fromJSON","json","JSON","parse","Error","undefined","attestationObject","attObject","decode","_publicKey","getPublicKey","getAuthenticatorAttachment","sign","blob","result","get","allowCredentials","encoded","encode","authenticator_data","authenticatorData","client_data_json","clientDataJSON","signature","Object","assign","__signature__"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\identity\\src\\identity\\webauthn.ts"],"sourcesContent":["import {\n  type DerEncodedPublicKey,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n  wrapDER,\n  DER_COSE_OID,\n  Cbor,\n} from '@dfinity/agent';\nimport { bytesToHex, hexToBytes, randomBytes, bytesToUtf8 } from '@noble/hashes/utils';\nimport { uint8FromBufLike } from '@dfinity/candid';\n\nfunction _coseToDerEncodedBlob(cose: Uint8Array): DerEncodedPublicKey {\n  return wrapDER(cose, DER_COSE_OID) as DerEncodedPublicKey;\n}\n\ntype PublicKeyCredentialWithAttachment = PublicKeyCredential & {\n  // Extends `PublicKeyCredential` with an optional field introduced in the WebAuthn level 3 spec:\n  // https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment\n  // Already supported by Chrome, Safari and Edge\n  // Note: `null` is included here as a possible value because Edge set this value to null in the\n  // past.\n  authenticatorAttachment: AuthenticatorAttachment | undefined | null;\n  // Explicitly including toJSON method from the base PublicKeyCredential interface\n  toJSON: () => Record<string, unknown>;\n};\n\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData: Uint8Array): Uint8Array {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\n\nexport class CosePublicKey implements PublicKey {\n  protected _encodedKey: DerEncodedPublicKey;\n\n  public constructor(protected _cose: Uint8Array) {\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this._encodedKey;\n  }\n\n  public getCose(): Uint8Array {\n    return this._cose;\n  }\n}\n\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge: string | Uint8Array = '<ic0.app>'): Uint8Array {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(\n  credentialCreationOptions?: CredentialCreationOptions,\n): Promise<PublicKeyCredentialWithAttachment | null> {\n  const creds = (await navigator.credentials.create(\n    credentialCreationOptions ?? {\n      publicKey: {\n        authenticatorSelection: {\n          userVerification: 'preferred',\n        },\n        attestation: 'direct',\n        challenge: _createChallengeBuffer(),\n        pubKeyCredParams: [{ type: 'public-key', alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256 }],\n        rp: {\n          name: 'Internet Identity Service',\n        },\n        user: {\n          id: randomBytes(16),\n          name: 'Internet Identity',\n          displayName: 'Internet Identity',\n        },\n      },\n    },\n  )) as PublicKeyCredentialWithAttachment | null;\n\n  if (creds === null) {\n    return null;\n  }\n\n  return {\n    // do _not_ use ...creds here, as creds is not enumerable in all cases\n    id: creds.id,\n    response: creds.response,\n    type: creds.type,\n    authenticatorAttachment: creds.authenticatorAttachment,\n    getClientExtensionResults: creds.getClientExtensionResults,\n    // Some password managers will return a Uint8Array, so we ensure we return an ArrayBuffer.\n    rawId: creds.rawId,\n    toJSON: creds.toJSON.bind(creds), // Ensure the toJSON method is included\n  };\n}\n\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nenum PubKeyCoseAlgo {\n  ECDSA_WITH_SHA256 = -7,\n}\n\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  public static fromJSON(json: string): WebAuthnIdentity {\n    const { publicKey, rawId } = JSON.parse(json);\n\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n\n    return new this(hexToBytes(rawId), hexToBytes(publicKey), undefined);\n  }\n\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  public static async create(\n    credentialCreationOptions?: CredentialCreationOptions,\n  ): Promise<WebAuthnIdentity> {\n    const creds = await _createCredential(credentialCreationOptions);\n\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n\n    const response = creds.response as AuthenticatorAttestationResponse;\n    if (response.attestationObject === undefined) {\n      throw new Error('Was expecting an attestation response.');\n    }\n\n    // Parse the attestationObject as CBOR.\n    const attObject = Cbor.decode<{ authData: Uint8Array }>(\n      new Uint8Array(response.attestationObject),\n    );\n\n    return new this(\n      uint8FromBufLike(creds.rawId),\n      _authDataToCose(attObject.authData),\n      creds.authenticatorAttachment ?? undefined,\n    );\n  }\n\n  protected _publicKey: CosePublicKey;\n\n  public constructor(\n    public readonly rawId: Uint8Array,\n    cose: Uint8Array,\n    protected authenticatorAttachment: AuthenticatorAttachment | undefined,\n  ) {\n    super();\n    this._publicKey = new CosePublicKey(cose);\n  }\n\n  public getPublicKey(): PublicKey {\n    return this._publicKey;\n  }\n\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  public getAuthenticatorAttachment(): AuthenticatorAttachment | undefined {\n    return this.authenticatorAttachment;\n  }\n\n  public async sign(blob: Uint8Array): Promise<Signature> {\n    const result = (await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [\n          {\n            type: 'public-key',\n            id: this.rawId,\n          },\n        ],\n        challenge: blob,\n        userVerification: 'preferred',\n      },\n    })) as PublicKeyCredentialWithAttachment;\n\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n\n    const response = result.response as AuthenticatorAssertionResponse;\n\n    const encoded = Cbor.encode({\n      authenticator_data: response.authenticatorData,\n      client_data_json: bytesToUtf8(new Uint8Array(response.clientDataJSON)),\n      signature: response.signature,\n    });\n\n    if (!encoded) {\n      throw new Error('failed to encode cbor');\n    }\n\n    Object.assign(encoded, {\n      __signature__: undefined,\n    });\n\n    return encoded as Signature;\n  }\n\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  public toJSON(): JsonnableWebAuthnIdentity {\n    return {\n      publicKey: bytesToHex(this._publicKey.getCose()),\n      rawId: bytesToHex(this.rawId),\n    };\n  }\n}\n\n/**\n * ReturnType<WebAuthnIdentity.toJSON>\n */\nexport interface JsonnableWebAuthnIdentity {\n  // The hexadecimal representation of the DER encoded public key.\n  publicKey: string;\n  // The string representation of the local WebAuthn Credential.id (base64url encoded).\n  rawId: string;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}