{"ast":null,"code":"import { ProtocolError, TimeoutWaitingForResponseErrorCode } from \"../errors.js\";\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy() {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\nexport function once() {\n  let first = true;\n  return async () => {\n    if (first) {\n      first = false;\n      return true;\n    }\n    return false;\n  };\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition, timeInMsec) {\n  return async (canisterId, requestId, status) => {\n    if (await condition(canisterId, requestId, status)) {\n      return new Promise(resolve => setTimeout(resolve, timeInMsec));\n    }\n  };\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count) {\n  let attempts = count;\n  return async (_canisterId, requestId, status) => {\n    if (--attempts <= 0) {\n      throw ProtocolError.fromCode(new TimeoutWaitingForResponseErrorCode(`Failed to retrieve a reply for request after ${count} attempts`, requestId, status));\n    }\n  };\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec) {\n  return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec) {\n  const end = Date.now() + timeInMsec;\n  return async (_canisterId, requestId, status) => {\n    if (Date.now() > end) {\n      throw ProtocolError.fromCode(new TimeoutWaitingForResponseErrorCode(`Request timed out after ${timeInMsec} msec`, requestId, status));\n    }\n  };\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec, backoffFactor) {\n  let currentThrottling = startingThrottleInMsec;\n  return () => new Promise(resolve => setTimeout(() => {\n    currentThrottling *= backoffFactor;\n    resolve();\n  }, currentThrottling));\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain() {\n  for (var _len = arguments.length, strategies = new Array(_len), _key = 0; _key < _len; _key++) {\n    strategies[_key] = arguments[_key];\n  }\n  return async (canisterId, requestId, status) => {\n    for (const a of strategies) {\n      await a(canisterId, requestId, status);\n    }\n  };\n}","map":{"version":3,"names":["ProtocolError","TimeoutWaitingForResponseErrorCode","FIVE_MINUTES_IN_MSEC","defaultStrategy","chain","conditionalDelay","once","backoff","timeout","first","condition","timeInMsec","canisterId","requestId","status","Promise","resolve","setTimeout","maxAttempts","count","attempts","_canisterId","fromCode","throttle","throttleInMsec","end","Date","now","startingThrottleInMsec","backoffFactor","currentThrottling","_len","arguments","length","strategies","Array","_key","a"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\polling\\strategy.ts"],"sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { RequestStatusResponseStatus } from '../agent/index.ts';\nimport { type PollStrategy } from './index.ts';\nimport { type RequestId } from '../request_id.ts';\nimport { ProtocolError, TimeoutWaitingForResponseErrorCode } from '../errors.ts';\n\nexport type Predicate<T> = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<T>;\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy(): PollStrategy {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n\n/**\n * Predicate that returns true once.\n */\nexport function once(): Predicate<boolean> {\n  let first = true;\n  return async () => {\n    if (first) {\n      first = false;\n      return true;\n    }\n    return false;\n  };\n}\n\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition: Predicate<boolean>, timeInMsec: number): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (await condition(canisterId, requestId, status)) {\n      return new Promise(resolve => setTimeout(resolve, timeInMsec));\n    }\n  };\n}\n\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count: number): PollStrategy {\n  let attempts = count;\n  return async (\n    _canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (--attempts <= 0) {\n      throw ProtocolError.fromCode(\n        new TimeoutWaitingForResponseErrorCode(\n          `Failed to retrieve a reply for request after ${count} attempts`,\n          requestId,\n          status,\n        ),\n      );\n    }\n  };\n}\n\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec: number): PollStrategy {\n  return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec: number): PollStrategy {\n  const end = Date.now() + timeInMsec;\n  return async (\n    _canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (Date.now() > end) {\n      throw ProtocolError.fromCode(\n        new TimeoutWaitingForResponseErrorCode(\n          `Request timed out after ${timeInMsec} msec`,\n          requestId,\n          status,\n        ),\n      );\n    }\n  };\n}\n\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec: number, backoffFactor: number): PollStrategy {\n  let currentThrottling = startingThrottleInMsec;\n\n  return () =>\n    new Promise(resolve =>\n      setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n      }, currentThrottling),\n    );\n}\n\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain(...strategies: PollStrategy[]): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    for (const a of strategies) {\n      await a(canisterId, requestId, status);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}