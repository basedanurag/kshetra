{"ast":null,"code":"// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\nimport { PipeArrayBuffer as Pipe } from \"./buffer.js\";\nimport { ilog2 } from \"./bigint-math.js\";\nfunction eob() {\n  throw new Error('unexpected end of buffer');\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Uint8Array\n */\nexport function safeRead(pipe, num) {\n  if (pipe.byteLength < num) {\n    eob();\n  }\n  return pipe.read(num);\n}\n/**\n * @param pipe - PipeArrayBuffer simulating buffer-pipe api\n */\nexport function safeReadUint8(pipe) {\n  const byte = pipe.readUint8();\n  if (byte === undefined) {\n    eob();\n  }\n  return byte;\n}\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\nexport function lebEncode(value) {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n  if (value < BigInt(0)) {\n    throw new Error('Cannot leb encode negative values.');\n  }\n  const byteLength = (value === BigInt(0) ? 0 : ilog2(value)) + 1;\n  const pipe = new Pipe(new Uint8Array(byteLength), 0);\n  while (true) {\n    const i = Number(value & BigInt(0x7f));\n    value /= BigInt(0x80);\n    if (value === BigInt(0)) {\n      pipe.write(new Uint8Array([i]));\n      break;\n    } else {\n      pipe.write(new Uint8Array([i | 0x80]));\n    }\n  }\n  return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\nexport function lebDecode(pipe) {\n  let weight = BigInt(1);\n  let value = BigInt(0);\n  let byte;\n  do {\n    byte = safeReadUint8(pipe);\n    value += BigInt(byte & 0x7f).valueOf() * weight;\n    weight *= BigInt(128);\n  } while (byte >= 0x80);\n  return value;\n}\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\nexport function slebEncode(value) {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n  const isNeg = value < BigInt(0);\n  if (isNeg) {\n    value = -value - BigInt(1);\n  }\n  const byteLength = (value === BigInt(0) ? 0 : ilog2(value)) + 1;\n  const pipe = new Pipe(new Uint8Array(byteLength), 0);\n  while (true) {\n    const i = getLowerBytes(value);\n    value /= BigInt(0x80);\n    // prettier-ignore\n    if (isNeg && value === BigInt(0) && (i & 0x40) !== 0 || !isNeg && value === BigInt(0) && (i & 0x40) === 0) {\n      pipe.write(new Uint8Array([i]));\n      break;\n    } else {\n      pipe.write(new Uint8Array([i | 0x80]));\n    }\n  }\n  function getLowerBytes(num) {\n    const bytes = num % BigInt(0x80);\n    if (isNeg) {\n      // We swap the bits here again, and remove 1 to do two's complement.\n      return Number(BigInt(0x80) - bytes - BigInt(1));\n    } else {\n      return Number(bytes);\n    }\n  }\n  return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\nexport function slebDecode(pipe) {\n  // Get the size of the buffer, then cut a buffer of that size.\n  const pipeView = new Uint8Array(pipe.buffer);\n  let len = 0;\n  for (; len < pipeView.byteLength; len++) {\n    if (pipeView[len] < 0x80) {\n      // If it's a positive number, we reuse lebDecode.\n      if ((pipeView[len] & 0x40) === 0) {\n        return lebDecode(pipe);\n      }\n      break;\n    }\n  }\n  const bytes = new Uint8Array(safeRead(pipe, len + 1));\n  let value = BigInt(0);\n  for (let i = bytes.byteLength - 1; i >= 0; i--) {\n    value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n  }\n  return -value - BigInt(1);\n}\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Uint8Array\n */\nexport function writeUIntLE(value, byteLength) {\n  if (BigInt(value) < BigInt(0)) {\n    throw new Error('Cannot write negative values.');\n  }\n  return writeIntLE(value, byteLength);\n}\n/**\n *\n * @param value - bigint or number\n * @param byteLength - number\n * @returns Uint8Array\n */\nexport function writeIntLE(value, byteLength) {\n  value = BigInt(value);\n  const pipe = new Pipe(new Uint8Array(Math.min(1, byteLength)), 0);\n  let i = 0;\n  let mul = BigInt(256);\n  let sub = BigInt(0);\n  let byte = Number(value % mul);\n  pipe.write(new Uint8Array([byte]));\n  while (++i < byteLength) {\n    if (value < 0 && sub === BigInt(0) && byte !== 0) {\n      sub = BigInt(1);\n    }\n    byte = Number((value / mul - sub) % BigInt(256));\n    pipe.write(new Uint8Array([byte]));\n    mul *= BigInt(256);\n  }\n  return pipe.buffer;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readUIntLE(pipe, byteLength) {\n  if (byteLength <= 0 || !Number.isInteger(byteLength)) {\n    throw new Error('Byte length must be a positive integer');\n  }\n  let val = BigInt(safeReadUint8(pipe));\n  let mul = BigInt(1);\n  let i = 0;\n  while (++i < byteLength) {\n    mul *= BigInt(256);\n    const byte = BigInt(safeReadUint8(pipe));\n    val = val + mul * byte;\n  }\n  return val;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readIntLE(pipe, byteLength) {\n  if (byteLength <= 0 || !Number.isInteger(byteLength)) {\n    throw new Error('Byte length must be a positive integer');\n  }\n  let val = readUIntLE(pipe, byteLength);\n  const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n  if (val >= mul) {\n    val -= mul * BigInt(2);\n  }\n  return val;\n}","map":{"version":3,"names":["PipeArrayBuffer","Pipe","ilog2","eob","Error","safeRead","pipe","num","byteLength","read","safeReadUint8","byte","readUint8","undefined","lebEncode","value","BigInt","Uint8Array","i","Number","write","buffer","lebDecode","weight","valueOf","slebEncode","isNeg","getLowerBytes","bytes","slebDecode","pipeView","len","writeUIntLE","writeIntLE","Math","min","mul","sub","readUIntLE","isInteger","val","readIntLE"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\candid\\src\\utils\\leb128.ts"],"sourcesContent":["// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\nimport { PipeArrayBuffer as Pipe } from './buffer.ts';\nimport { ilog2 } from './bigint-math.ts';\n\nfunction eob(): never {\n  throw new Error('unexpected end of buffer');\n}\n\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Uint8Array\n */\nexport function safeRead(pipe: Pipe, num: number): Uint8Array {\n  if (pipe.byteLength < num) {\n    eob();\n  }\n  return pipe.read(num);\n}\n\n/**\n * @param pipe - PipeArrayBuffer simulating buffer-pipe api\n */\nexport function safeReadUint8(pipe: Pipe): number {\n  const byte = pipe.readUint8();\n  if (byte === undefined) {\n    eob();\n  }\n  return byte;\n}\n\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\nexport function lebEncode(value: bigint | number): Uint8Array {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n\n  if (value < BigInt(0)) {\n    throw new Error('Cannot leb encode negative values.');\n  }\n\n  const byteLength = (value === BigInt(0) ? 0 : ilog2(value)) + 1;\n  const pipe = new Pipe(new Uint8Array(byteLength), 0);\n  while (true) {\n    const i = Number(value & BigInt(0x7f));\n    value /= BigInt(0x80);\n    if (value === BigInt(0)) {\n      pipe.write(new Uint8Array([i]));\n      break;\n    } else {\n      pipe.write(new Uint8Array([i | 0x80]));\n    }\n  }\n\n  return pipe.buffer;\n}\n\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\nexport function lebDecode(pipe: Pipe): bigint {\n  let weight = BigInt(1);\n  let value = BigInt(0);\n  let byte;\n\n  do {\n    byte = safeReadUint8(pipe);\n    value += BigInt(byte & 0x7f).valueOf() * weight;\n    weight *= BigInt(128);\n  } while (byte >= 0x80);\n\n  return value;\n}\n\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\nexport function slebEncode(value: bigint | number): Uint8Array {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n\n  const isNeg = value < BigInt(0);\n  if (isNeg) {\n    value = -value - BigInt(1);\n  }\n  const byteLength = (value === BigInt(0) ? 0 : ilog2(value)) + 1;\n  const pipe = new Pipe(new Uint8Array(byteLength), 0);\n  while (true) {\n    const i = getLowerBytes(value);\n    value /= BigInt(0x80);\n\n    // prettier-ignore\n    if (   ( isNeg && value === BigInt(0) && (i & 0x40) !== 0)\n          || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {\n        pipe.write(new Uint8Array([i]));\n        break;\n      } else {\n        pipe.write(new Uint8Array([i | 0x80]));\n      }\n  }\n\n  function getLowerBytes(num: bigint): number {\n    const bytes = num % BigInt(0x80);\n    if (isNeg) {\n      // We swap the bits here again, and remove 1 to do two's complement.\n      return Number(BigInt(0x80) - bytes - BigInt(1));\n    } else {\n      return Number(bytes);\n    }\n  }\n  return pipe.buffer;\n}\n\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\nexport function slebDecode(pipe: Pipe): bigint {\n  // Get the size of the buffer, then cut a buffer of that size.\n  const pipeView = new Uint8Array(pipe.buffer);\n  let len = 0;\n  for (; len < pipeView.byteLength; len++) {\n    if (pipeView[len] < 0x80) {\n      // If it's a positive number, we reuse lebDecode.\n      if ((pipeView[len] & 0x40) === 0) {\n        return lebDecode(pipe);\n      }\n      break;\n    }\n  }\n\n  const bytes = new Uint8Array(safeRead(pipe, len + 1));\n  let value = BigInt(0);\n  for (let i = bytes.byteLength - 1; i >= 0; i--) {\n    value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n  }\n  return -value - BigInt(1);\n}\n\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Uint8Array\n */\nexport function writeUIntLE(value: bigint | number, byteLength: number): Uint8Array {\n  if (BigInt(value) < BigInt(0)) {\n    throw new Error('Cannot write negative values.');\n  }\n  return writeIntLE(value, byteLength);\n}\n\n/**\n *\n * @param value - bigint or number\n * @param byteLength - number\n * @returns Uint8Array\n */\nexport function writeIntLE(value: bigint | number, byteLength: number): Uint8Array {\n  value = BigInt(value);\n\n  const pipe = new Pipe(new Uint8Array(Math.min(1, byteLength)), 0);\n  let i = 0;\n  let mul = BigInt(256);\n  let sub = BigInt(0);\n  let byte = Number(value % mul);\n  pipe.write(new Uint8Array([byte]));\n  while (++i < byteLength) {\n    if (value < 0 && sub === BigInt(0) && byte !== 0) {\n      sub = BigInt(1);\n    }\n    byte = Number((value / mul - sub) % BigInt(256));\n    pipe.write(new Uint8Array([byte]));\n    mul *= BigInt(256);\n  }\n\n  return pipe.buffer;\n}\n\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readUIntLE(pipe: Pipe, byteLength: number): bigint {\n  if (byteLength <= 0 || !Number.isInteger(byteLength)) {\n    throw new Error('Byte length must be a positive integer');\n  }\n  let val = BigInt(safeReadUint8(pipe));\n  let mul = BigInt(1);\n  let i = 0;\n  while (++i < byteLength) {\n    mul *= BigInt(256);\n    const byte = BigInt(safeReadUint8(pipe));\n    val = val + mul * byte;\n  }\n  return val;\n}\n\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readIntLE(pipe: Pipe, byteLength: number): bigint {\n  if (byteLength <= 0 || !Number.isInteger(byteLength)) {\n    throw new Error('Byte length must be a positive integer');\n  }\n  let val = readUIntLE(pipe, byteLength);\n  const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n  if (val >= mul) {\n    val -= mul * BigInt(2);\n  }\n  return val;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}