{"ast":null,"code":"import { isV2ResponseBody, isV3ResponseBody, QueryResponseStatus } from \"./agent/index.js\";\nimport { CertifiedRejectErrorCode, ExternalError, InputError, MissingCanisterIdErrorCode, MissingRootKeyErrorCode, RejectError, UncertifiedRejectErrorCode, UnexpectedErrorCode, UnknownError } from \"./errors.js\";\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, DEFAULT_POLLING_OPTIONS } from \"./polling/index.js\";\nimport { Principal } from '@dfinity/principal';\nimport { Certificate, lookupResultToBuffer } from \"./certificate.js\";\nimport { HttpAgent } from \"./agent/http/index.js\";\nimport { utf8ToBytes } from '@noble/hashes/utils';\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  static agentOf(actor) {\n    return actor[metadataSymbol].config.agent;\n  }\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  static interfaceOf(actor) {\n    return actor[metadataSymbol].service;\n  }\n  static canisterIdOf(actor) {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n  static createActorClass(interfaceFactory, options) {\n    const service = interfaceFactory({\n      IDL\n    });\n    class CanisterActor extends Actor {\n      constructor(config) {\n        if (!config.canisterId) {\n          throw InputError.fromCode(new MissingCanisterIdErrorCode(config.canisterId));\n        }\n        const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId\n          },\n          service\n        });\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options?.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n    return CanisterActor;\n  }\n  static createActor(interfaceFactory, configuration) {\n    if (!configuration.canisterId) {\n      throw InputError.fromCode(new MissingCanisterIdErrorCode(configuration.canisterId));\n    }\n    return new (this.createActorClass(interfaceFactory))(configuration);\n  }\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  static createActorWithHttpDetails(interfaceFactory, configuration) {\n    return new (this.createActorClass(interfaceFactory, {\n      httpDetails: true\n    }))(configuration);\n  }\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  static createActorWithExtendedDetails(interfaceFactory, configuration) {\n    let actorClassOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      httpDetails: true,\n      certificate: true\n    };\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);\n  }\n  constructor(metadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n  const returnValues = IDL.decode(types, msg);\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingOptions: DEFAULT_POLLING_OPTIONS\n};\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\nfunction _createActorMethod(actor, methodName, func, blsVerify) {\n  let caller;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async function (options) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options\n        })\n      };\n      const agent = options.agent || actor[metadataSymbol].config.agent || new HttpAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId\n      });\n      const httpDetails = {\n        ...result.httpDetails,\n        requestDetails: result.requestDetails\n      };\n      switch (result.status) {\n        case QueryResponseStatus.Rejected:\n          {\n            const uncertifiedRejectErrorCode = new UncertifiedRejectErrorCode(result.requestId, result.reject_code, result.reject_message, result.error_code, result.signatures);\n            uncertifiedRejectErrorCode.callContext = {\n              canisterId: cid,\n              methodName,\n              httpDetails\n            };\n            throw RejectError.fromCode(uncertifiedRejectErrorCode);\n          }\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, result.reply.arg)\n          } : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async function (options) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options\n        })\n      };\n      const agent = options.agent || actor[metadataSymbol].config.agent || HttpAgent.createSync();\n      const {\n        canisterId,\n        effectiveCanisterId,\n        pollingOptions\n      } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n      const {\n        requestId,\n        response,\n        requestDetails\n      } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n        nonce: options.nonce\n      });\n      let reply;\n      let certificate;\n      if (isV3ResponseBody(response.body)) {\n        if (agent.rootKey == null) {\n          throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n        }\n        const cert = response.body.certificate;\n        certificate = await Certificate.create({\n          certificate: cert,\n          rootKey: agent.rootKey,\n          canisterId: Principal.from(canisterId),\n          blsVerify\n        });\n        const path = [utf8ToBytes('request_status'), requestId];\n        const status = new TextDecoder().decode(lookupResultToBuffer(certificate.lookup_path([...path, 'status'])));\n        switch (status) {\n          case 'replied':\n            reply = lookupResultToBuffer(certificate.lookup_path([...path, 'reply']));\n            break;\n          case 'rejected':\n            {\n              // Find rejection details in the certificate\n              const rejectCode = new Uint8Array(lookupResultToBuffer(certificate.lookup_path([...path, 'reject_code'])))[0];\n              const rejectMessage = new TextDecoder().decode(lookupResultToBuffer(certificate.lookup_path([...path, 'reject_message'])));\n              const error_code_buf = lookupResultToBuffer(certificate.lookup_path([...path, 'error_code']));\n              const error_code = error_code_buf ? new TextDecoder().decode(error_code_buf) : undefined;\n              const certifiedRejectErrorCode = new CertifiedRejectErrorCode(requestId, rejectCode, rejectMessage, error_code);\n              certifiedRejectErrorCode.callContext = {\n                canisterId: cid,\n                methodName,\n                httpDetails: response\n              };\n              throw RejectError.fromCode(certifiedRejectErrorCode);\n            }\n        }\n      } else if (isV2ResponseBody(response.body)) {\n        // handle v2 response errors by throwing an UpdateCallRejectedError object\n        const {\n          reject_code,\n          reject_message,\n          error_code\n        } = response.body;\n        const certifiedRejectErrorCode = new CertifiedRejectErrorCode(requestId, reject_code, reject_message, error_code);\n        certifiedRejectErrorCode.callContext = {\n          canisterId: cid,\n          methodName,\n          httpDetails: response\n        };\n        throw RejectError.fromCode(certifiedRejectErrorCode);\n      }\n      // Fall back to polling if we receive an Accepted response code\n      if (response.status === 202) {\n        const pollOptions = {\n          ...pollingOptions,\n          blsVerify\n        };\n        // Contains the certificate and the reply from the boundary node\n        const response = await pollForResponse(agent, ecid, requestId, pollOptions);\n        certificate = response.certificate;\n        reply = response.reply;\n      }\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n      const httpDetails = {\n        ...response,\n        requestDetails\n      };\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails ? {\n          httpDetails: response,\n          result: undefined\n        } : undefined;\n      } else {\n        throw UnknownError.fromCode(new UnexpectedErrorCode(`Call was returned undefined, but type [${func.retTypes.map(t => t.display()).join(',')}].`));\n      }\n    };\n  }\n  const handler = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return caller({}, ...args);\n  };\n  handler.withOptions = options => function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return caller(options, ...args);\n  };\n  return handler;\n}","map":{"version":3,"names":["isV2ResponseBody","isV3ResponseBody","QueryResponseStatus","CertifiedRejectErrorCode","ExternalError","InputError","MissingCanisterIdErrorCode","MissingRootKeyErrorCode","RejectError","UncertifiedRejectErrorCode","UnexpectedErrorCode","UnknownError","IDL","pollForResponse","DEFAULT_POLLING_OPTIONS","Principal","Certificate","lookupResultToBuffer","HttpAgent","utf8ToBytes","metadataSymbol","Symbol","for","Actor","agentOf","actor","config","agent","interfaceOf","service","canisterIdOf","from","canisterId","createActorClass","interfaceFactory","options","CanisterActor","constructor","fromCode","fromText","DEFAULT_ACTOR_CONFIG","methodName","func","_fields","httpDetails","annotations","push","ACTOR_METHOD_WITH_HTTP_DETAILS","certificate","ACTOR_METHOD_WITH_CERTIFICATE","_createActorMethod","blsVerify","createActor","configuration","createActorWithHttpDetails","createActorWithExtendedDetails","actorClassOptions","arguments","length","undefined","metadata","Object","freeze","decodeReturnValue","types","msg","returnValues","decode","pollingOptions","caller","includes","_len","args","Array","_key","queryTransform","cid","arg","encode","argTypes","result","query","effectiveCanisterId","requestDetails","status","Rejected","uncertifiedRejectErrorCode","requestId","reject_code","reject_message","error_code","signatures","callContext","Replied","retTypes","reply","_len2","_key2","callTransform","createSync","ecid","response","call","nonce","body","rootKey","cert","create","path","TextDecoder","lookup_path","rejectCode","Uint8Array","rejectMessage","error_code_buf","certifiedRejectErrorCode","pollOptions","shouldIncludeHttpDetails","shouldIncludeCertificate","map","t","display","join","handler","_len3","_key3","withOptions","_len4","_key4"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\actor.ts"],"sourcesContent":["import {\n  type Agent,\n  type HttpDetailsResponse,\n  isV2ResponseBody,\n  isV3ResponseBody,\n  QueryResponseStatus,\n} from './agent/index.ts';\nimport {\n  CertifiedRejectErrorCode,\n  ExternalError,\n  InputError,\n  MissingCanisterIdErrorCode,\n  MissingRootKeyErrorCode,\n  RejectError,\n  UncertifiedRejectErrorCode,\n  UnexpectedErrorCode,\n  UnknownError,\n} from './errors.ts';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, type PollingOptions, DEFAULT_POLLING_OPTIONS } from './polling/index.ts';\nimport { Principal } from '@dfinity/principal';\nimport { Certificate, type CreateCertificateOptions, lookupResultToBuffer } from './certificate.ts';\nimport { HttpAgent } from './agent/http/index.ts';\nimport { utf8ToBytes } from '@noble/hashes/utils';\n\n/**\n * Configuration to make calls to the Replica.\n */\nexport interface CallConfig {\n  /**\n   * An agent to use in this call, otherwise the actor or call will try to discover the\n   * agent to use.\n   */\n  agent?: Agent;\n\n  /**\n   * Options for controlling polling behavior.\n   */\n  pollingOptions?: PollingOptions;\n\n  /**\n   * The canister ID of this Actor.\n   */\n  canisterId?: string | Principal;\n\n  /**\n   * The effective canister ID. This should almost always be ignored.\n   */\n  effectiveCanisterId?: Principal;\n\n  /**\n   * The nonce to use for this call. This is used to prevent replay attacks.\n   */\n  nonce?: Uint8Array;\n}\n\n/**\n * Configuration that can be passed to customize the Actor behaviour.\n */\nexport interface ActorConfig extends CallConfig {\n  /**\n   * The Canister ID of this Actor. This is required for an Actor.\n   */\n  canisterId: string | Principal;\n\n  /**\n   * An override function for update calls' CallConfig. This will be called on every calls.\n   */\n  callTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * An override function for query calls' CallConfig. This will be called on every query.\n   */\n  queryTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * Polyfill for BLS Certificate verification in case wasm is not supported\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n\n  /**\n   * Polling options to use when making update calls. This will override the default DEFAULT_POLLING_OPTIONS.\n   */\n  pollingOptions?: PollingOptions;\n}\n\n// TODO: move this to proper typing when Candid support TypeScript.\n/**\n * A subclass of an actor. Actor class itself is meant to be a based class.\n */\nexport type ActorSubclass<T = Record<string, ActorMethod>> = Actor & T;\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethod<Args extends unknown[] = unknown[], Ret = unknown> {\n  (...args: Args): Promise<Ret>;\n\n  withOptions(options: CallConfig): (...args: Args) => Promise<Ret>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodWithHttpDetails<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{ httpDetails: HttpDetailsResponse; result: Ret }>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodExtended<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{\n    certificate?: Certificate;\n    httpDetails?: HttpDetailsResponse;\n    result: Ret;\n  }>;\n}\n\nexport type FunctionWithArgsAndReturn<Args extends unknown[] = unknown[], Ret = unknown> = (\n  ...args: Args\n) => Ret;\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedWithHttpDetails<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodWithHttpDetails<Args, Ret>\n    : never;\n};\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedExtended<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodExtended<Args, Ret>\n    : never;\n};\n\n/**\n * The mode used when installing a canister.\n */\nexport type CanisterInstallMode =\n  | {\n      reinstall: null;\n    }\n  | {\n      upgrade:\n        | []\n        | [\n            {\n              skip_pre_upgrade: [] | [boolean];\n            },\n          ];\n    }\n  | {\n      install: null;\n    };\n\n/**\n * Internal metadata for actors. It's an enhanced version of ActorConfig with\n * some fields marked as required (as they are defaulted) and canisterId as\n * a Principal type.\n */\ninterface ActorMetadata {\n  service: IDL.ServiceClass;\n  agent?: Agent;\n  config: ActorConfig;\n}\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n\nexport interface CreateActorClassOpts {\n  httpDetails?: boolean;\n  certificate?: boolean;\n}\n\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  public static agentOf(actor: Actor): Agent | undefined {\n    return actor[metadataSymbol].config.agent;\n  }\n\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  public static interfaceOf(actor: Actor): IDL.ServiceClass {\n    return actor[metadataSymbol].service;\n  }\n\n  public static canisterIdOf(actor: Actor): Principal {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  public static createActorClass(\n    interfaceFactory: IDL.InterfaceFactory,\n    options?: CreateActorClassOpts,\n  ): ActorConstructor {\n    const service = interfaceFactory({ IDL });\n\n    class CanisterActor extends Actor {\n      [x: string]: ActorMethod;\n\n      constructor(config: ActorConfig) {\n        if (!config.canisterId) {\n          throw InputError.fromCode(new MissingCanisterIdErrorCode(config.canisterId));\n        }\n        const canisterId =\n          typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId,\n          },\n          service,\n        });\n\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options?.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n\n    return CanisterActor;\n  }\n\n  public static createActor<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<T> {\n    if (!configuration.canisterId) {\n      throw InputError.fromCode(new MissingCanisterIdErrorCode(configuration.canisterId));\n    }\n    return new (this.createActorClass(interfaceFactory))(\n      configuration,\n    ) as unknown as ActorSubclass<T>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  public static createActorWithHttpDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<ActorMethodMappedWithHttpDetails<T>> {\n    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedWithHttpDetails<T>>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  public static createActorWithExtendedDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n    actorClassOptions: CreateActorClassOpts = {\n      httpDetails: true,\n      certificate: true,\n    },\n  ): ActorSubclass<ActorMethodMappedExtended<T>> {\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedExtended<T>>;\n  }\n\n  private [metadataSymbol]: ActorMetadata;\n\n  protected constructor(metadata: ActorMetadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types: IDL.Type[], msg: Uint8Array) {\n  const returnValues = IDL.decode(types, msg);\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG: Partial<ActorConfig> = {\n  pollingOptions: DEFAULT_POLLING_OPTIONS,\n};\n\nexport type ActorConstructor = new (config: ActorConfig) => ActorSubclass;\n\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\n\nfunction _createActorMethod(\n  actor: Actor,\n  methodName: string,\n  func: IDL.FuncClass,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): ActorMethod {\n  let caller: (options: CallConfig, ...args: unknown[]) => Promise<unknown>;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || new HttpAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId,\n      });\n      const httpDetails = {\n        ...result.httpDetails,\n        requestDetails: result.requestDetails,\n      } as HttpDetailsResponse;\n\n      switch (result.status) {\n        case QueryResponseStatus.Rejected: {\n          const uncertifiedRejectErrorCode = new UncertifiedRejectErrorCode(\n            result.requestId,\n            result.reject_code,\n            result.reject_message,\n            result.error_code,\n            result.signatures,\n          );\n          uncertifiedRejectErrorCode.callContext = {\n            canisterId: cid,\n            methodName,\n            httpDetails,\n          };\n          throw RejectError.fromCode(uncertifiedRejectErrorCode);\n        }\n\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n            ? {\n                httpDetails,\n                result: decodeReturnValue(func.retTypes, result.reply.arg),\n              }\n            : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || HttpAgent.createSync();\n\n      const { canisterId, effectiveCanisterId, pollingOptions } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options,\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n\n      const { requestId, response, requestDetails } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n        nonce: options.nonce,\n      });\n      let reply: Uint8Array | undefined;\n      let certificate: Certificate | undefined;\n      if (isV3ResponseBody(response.body)) {\n        if (agent.rootKey == null) {\n          throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n        }\n        const cert = response.body.certificate;\n        certificate = await Certificate.create({\n          certificate: cert,\n          rootKey: agent.rootKey,\n          canisterId: Principal.from(canisterId),\n          blsVerify,\n        });\n        const path = [utf8ToBytes('request_status'), requestId];\n        const status = new TextDecoder().decode(\n          lookupResultToBuffer(certificate.lookup_path([...path, 'status'])),\n        );\n\n        switch (status) {\n          case 'replied':\n            reply = lookupResultToBuffer(certificate.lookup_path([...path, 'reply']));\n            break;\n          case 'rejected': {\n            // Find rejection details in the certificate\n            const rejectCode = new Uint8Array(\n              lookupResultToBuffer(certificate.lookup_path([...path, 'reject_code']))!,\n            )[0];\n            const rejectMessage = new TextDecoder().decode(\n              lookupResultToBuffer(certificate.lookup_path([...path, 'reject_message']))!,\n            );\n\n            const error_code_buf = lookupResultToBuffer(\n              certificate.lookup_path([...path, 'error_code']),\n            );\n            const error_code = error_code_buf\n              ? new TextDecoder().decode(error_code_buf)\n              : undefined;\n\n            const certifiedRejectErrorCode = new CertifiedRejectErrorCode(\n              requestId,\n              rejectCode,\n              rejectMessage,\n              error_code,\n            );\n            certifiedRejectErrorCode.callContext = {\n              canisterId: cid,\n              methodName,\n              httpDetails: response,\n            };\n            throw RejectError.fromCode(certifiedRejectErrorCode);\n          }\n        }\n      } else if (isV2ResponseBody(response.body)) {\n        // handle v2 response errors by throwing an UpdateCallRejectedError object\n        const { reject_code, reject_message, error_code } = response.body;\n        const certifiedRejectErrorCode = new CertifiedRejectErrorCode(\n          requestId,\n          reject_code,\n          reject_message,\n          error_code,\n        );\n        certifiedRejectErrorCode.callContext = {\n          canisterId: cid,\n          methodName,\n          httpDetails: response,\n        };\n        throw RejectError.fromCode(certifiedRejectErrorCode);\n      }\n\n      // Fall back to polling if we receive an Accepted response code\n      if (response.status === 202) {\n        const pollOptions: PollingOptions = {\n          ...pollingOptions,\n          blsVerify,\n        };\n        // Contains the certificate and the reply from the boundary node\n        const response = await pollForResponse(agent, ecid, requestId, pollOptions);\n        certificate = response.certificate;\n        reply = response.reply;\n      }\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n\n      const httpDetails = { ...response, requestDetails } as HttpDetailsResponse;\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: undefined,\n            }\n          : undefined;\n      } else {\n        throw UnknownError.fromCode(\n          new UnexpectedErrorCode(\n            `Call was returned undefined, but type [${func.retTypes.map(t => t.display()).join(',')}].`,\n          ),\n        );\n      }\n    };\n  }\n\n  const handler = (...args: unknown[]) => caller({}, ...args);\n  handler.withOptions =\n    (options: CallConfig) =>\n    (...args: unknown[]) =>\n      caller(options, ...args);\n  return handler as ActorMethod;\n}\n"],"mappings":"AAAA,SAGEA,gBAAgB,EAChBC,gBAAgB,EAChBC,mBAAmB,QACd,kBAAkB;AACzB,SACEC,wBAAwB,EACxBC,aAAa,EACbC,UAAU,EACVC,0BAA0B,EAC1BC,uBAAuB,EACvBC,WAAW,EACXC,0BAA0B,EAC1BC,mBAAmB,EACnBC,YAAY,QACP,aAAa;AACpB,SAASC,GAAG,QAAQ,iBAAiB;AACrC,SAASC,eAAe,EAAuBC,uBAAuB,QAAQ,oBAAoB;AAClG,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,SAASC,WAAW,EAAiCC,oBAAoB,QAAQ,kBAAkB;AACnG,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,WAAW,QAAQ,qBAAqB;AA2JjD,MAAMC,cAAc,GAAGC,MAAM,CAACC,GAAG,CAAC,mBAAmB,CAAC;AAOtD;;;;AAIA,OAAM,MAAOC,KAAK;EAChB;;;;;EAKO,OAAOC,OAAOA,CAACC,KAAY;IAChC,OAAOA,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM,CAACC,KAAK;EAC3C;EAEA;;;;EAIO,OAAOC,WAAWA,CAACH,KAAY;IACpC,OAAOA,KAAK,CAACL,cAAc,CAAC,CAACS,OAAO;EACtC;EAEO,OAAOC,YAAYA,CAACL,KAAY;IACrC,OAAOV,SAAS,CAACgB,IAAI,CAACN,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM,CAACM,UAAU,CAAC;EAChE;EAEO,OAAOC,gBAAgBA,CAC5BC,gBAAsC,EACtCC,OAA8B;IAE9B,MAAMN,OAAO,GAAGK,gBAAgB,CAAC;MAAEtB;IAAG,CAAE,CAAC;IAEzC,MAAMwB,aAAc,SAAQb,KAAK;MAG/Bc,YAAYX,MAAmB;QAC7B,IAAI,CAACA,MAAM,CAACM,UAAU,EAAE;UACtB,MAAM3B,UAAU,CAACiC,QAAQ,CAAC,IAAIhC,0BAA0B,CAACoB,MAAM,CAACM,UAAU,CAAC,CAAC;QAC9E;QACA,MAAMA,UAAU,GACd,OAAON,MAAM,CAACM,UAAU,KAAK,QAAQ,GACjCjB,SAAS,CAACwB,QAAQ,CAACb,MAAM,CAACM,UAAU,CAAC,GACrCN,MAAM,CAACM,UAAU;QAEvB,KAAK,CAAC;UACJN,MAAM,EAAE;YACN,GAAGc,oBAAoB;YACvB,GAAGd,MAAM;YACTM;WACD;UACDH;SACD,CAAC;QAEF,KAAK,MAAM,CAACY,UAAU,EAAEC,IAAI,CAAC,IAAIb,OAAO,CAACc,OAAO,EAAE;UAChD,IAAIR,OAAO,EAAES,WAAW,EAAE;YACxBF,IAAI,CAACG,WAAW,CAACC,IAAI,CAACC,8BAA8B,CAAC;UACvD;UACA,IAAIZ,OAAO,EAAEa,WAAW,EAAE;YACxBN,IAAI,CAACG,WAAW,CAACC,IAAI,CAACG,6BAA6B,CAAC;UACtD;UAEA,IAAI,CAACR,UAAU,CAAC,GAAGS,kBAAkB,CAAC,IAAI,EAAET,UAAU,EAAEC,IAAI,EAAEhB,MAAM,CAACyB,SAAS,CAAC;QACjF;MACF;;IAGF,OAAOf,aAAa;EACtB;EAEO,OAAOgB,WAAWA,CACvBlB,gBAAsC,EACtCmB,aAA0B;IAE1B,IAAI,CAACA,aAAa,CAACrB,UAAU,EAAE;MAC7B,MAAM3B,UAAU,CAACiC,QAAQ,CAAC,IAAIhC,0BAA0B,CAAC+C,aAAa,CAACrB,UAAU,CAAC,CAAC;IACrF;IACA,OAAO,KAAK,IAAI,CAACC,gBAAgB,CAACC,gBAAgB,CAAC,EACjDmB,aAAa,CACiB;EAClC;EAEA;;;;;;EAMO,OAAOC,0BAA0BA,CACtCpB,gBAAsC,EACtCmB,aAA0B;IAE1B,OAAO,KAAK,IAAI,CAACpB,gBAAgB,CAACC,gBAAgB,EAAE;MAAEU,WAAW,EAAE;IAAI,CAAE,CAAC,EACxES,aAAa,CACmD;EACpE;EAEA;;;;;;EAMO,OAAOE,8BAA8BA,CAC1CrB,gBAAsC,EACtCmB,aAA0B,EAIzB;IAAA,IAHDG,iBAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA0C;MACxCb,WAAW,EAAE,IAAI;MACjBI,WAAW,EAAE;KACd;IAED,OAAO,KAAK,IAAI,CAACf,gBAAgB,CAACC,gBAAgB,EAAEsB,iBAAiB,CAAC,EACpEH,aAAa,CAC4C;EAC7D;EAIAhB,YAAsBuB,QAAuB;IAC3C,IAAI,CAACxC,cAAc,CAAC,GAAGyC,MAAM,CAACC,MAAM,CAACF,QAAQ,CAAC;EAChD;;AAGF;AACA;AACA;AACA,SAASG,iBAAiBA,CAACC,KAAiB,EAAEC,GAAe;EAC3D,MAAMC,YAAY,GAAGtD,GAAG,CAACuD,MAAM,CAACH,KAAK,EAAEC,GAAG,CAAC;EAC3C,QAAQC,YAAY,CAACR,MAAM;IACzB,KAAK,CAAC;MACJ,OAAOC,SAAS;IAClB,KAAK,CAAC;MACJ,OAAOO,YAAY,CAAC,CAAC,CAAC;IACxB;MACE,OAAOA,YAAY;EACvB;AACF;AAEA,MAAM1B,oBAAoB,GAAyB;EACjD4B,cAAc,EAAEtD;CACjB;AAID,OAAO,MAAMiC,8BAA8B,GAAG,cAAc;AAC5D,OAAO,MAAME,6BAA6B,GAAG,aAAa;AAE1D,SAASC,kBAAkBA,CACzBzB,KAAY,EACZgB,UAAkB,EAClBC,IAAmB,EACnBS,SAAiD;EAEjD,IAAIkB,MAAqE;EACzE,IAAI3B,IAAI,CAACG,WAAW,CAACyB,QAAQ,CAAC,OAAO,CAAC,IAAI5B,IAAI,CAACG,WAAW,CAACyB,QAAQ,CAAC,iBAAiB,CAAC,EAAE;IACtFD,MAAM,GAAG,eAAAA,CAAOlC,OAAO,EAAa;MAAA,SAAAoC,IAAA,GAAAd,SAAA,CAAAC,MAAA,EAARc,IAAI,OAAAC,KAAA,CAAAF,IAAA,OAAAA,IAAA,WAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;QAAJF,IAAI,CAAAE,IAAA,QAAAjB,SAAA,CAAAiB,IAAA;MAAA;MAC9B;MACAvC,OAAO,GAAG;QACR,GAAGA,OAAO;QACV,GAAGV,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM,CAACiD,cAAc,GAAGlC,UAAU,EAAE+B,IAAI,EAAE;UACjE,GAAG/C,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM;UAC/B,GAAGS;SACJ;OACF;MAED,MAAMR,KAAK,GAAGQ,OAAO,CAACR,KAAK,IAAIF,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM,CAACC,KAAK,IAAI,IAAIT,SAAS,EAAE;MACpF,MAAM0D,GAAG,GAAG7D,SAAS,CAACgB,IAAI,CAACI,OAAO,CAACH,UAAU,IAAIP,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM,CAACM,UAAU,CAAC;MACzF,MAAM6C,GAAG,GAAGjE,GAAG,CAACkE,MAAM,CAACpC,IAAI,CAACqC,QAAQ,EAAEP,IAAI,CAAC;MAE3C,MAAMQ,MAAM,GAAG,MAAMrD,KAAK,CAACsD,KAAK,CAACL,GAAG,EAAE;QACpCnC,UAAU;QACVoC,GAAG;QACHK,mBAAmB,EAAE/C,OAAO,CAAC+C;OAC9B,CAAC;MACF,MAAMtC,WAAW,GAAG;QAClB,GAAGoC,MAAM,CAACpC,WAAW;QACrBuC,cAAc,EAAEH,MAAM,CAACG;OACD;MAExB,QAAQH,MAAM,CAACI,MAAM;QACnB,KAAKlF,mBAAmB,CAACmF,QAAQ;UAAE;YACjC,MAAMC,0BAA0B,GAAG,IAAI7E,0BAA0B,CAC/DuE,MAAM,CAACO,SAAS,EAChBP,MAAM,CAACQ,WAAW,EAClBR,MAAM,CAACS,cAAc,EACrBT,MAAM,CAACU,UAAU,EACjBV,MAAM,CAACW,UAAU,CAClB;YACDL,0BAA0B,CAACM,WAAW,GAAG;cACvC5D,UAAU,EAAE4C,GAAG;cACfnC,UAAU;cACVG;aACD;YACD,MAAMpC,WAAW,CAAC8B,QAAQ,CAACgD,0BAA0B,CAAC;UACxD;QAEA,KAAKpF,mBAAmB,CAAC2F,OAAO;UAC9B,OAAOnD,IAAI,CAACG,WAAW,CAACyB,QAAQ,CAACvB,8BAA8B,CAAC,GAC5D;YACEH,WAAW;YACXoC,MAAM,EAAEjB,iBAAiB,CAACrB,IAAI,CAACoD,QAAQ,EAAEd,MAAM,CAACe,KAAK,CAAClB,GAAG;WAC1D,GACDd,iBAAiB,CAACrB,IAAI,CAACoD,QAAQ,EAAEd,MAAM,CAACe,KAAK,CAAClB,GAAG,CAAC;MAC1D;IACF,CAAC;EACH,CAAC,MAAM;IACLR,MAAM,GAAG,eAAAA,CAAOlC,OAAO,EAAa;MAAA,SAAA6D,KAAA,GAAAvC,SAAA,CAAAC,MAAA,EAARc,IAAI,OAAAC,KAAA,CAAAuB,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJzB,IAAI,CAAAyB,KAAA,QAAAxC,SAAA,CAAAwC,KAAA;MAAA;MAC9B;MACA9D,OAAO,GAAG;QACR,GAAGA,OAAO;QACV,GAAGV,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM,CAACwE,aAAa,GAAGzD,UAAU,EAAE+B,IAAI,EAAE;UAChE,GAAG/C,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM;UAC/B,GAAGS;SACJ;OACF;MAED,MAAMR,KAAK,GAAGQ,OAAO,CAACR,KAAK,IAAIF,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM,CAACC,KAAK,IAAIT,SAAS,CAACiF,UAAU,EAAE;MAE3F,MAAM;QAAEnE,UAAU;QAAEkD,mBAAmB;QAAEd;MAAc,CAAE,GAAG;QAC1D,GAAG5B,oBAAoB;QACvB,GAAGf,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM;QAC/B,GAAGS;OACJ;MACD,MAAMyC,GAAG,GAAG7D,SAAS,CAACgB,IAAI,CAACC,UAAU,CAAC;MACtC,MAAMoE,IAAI,GAAGlB,mBAAmB,KAAKvB,SAAS,GAAG5C,SAAS,CAACgB,IAAI,CAACmD,mBAAmB,CAAC,GAAGN,GAAG;MAC1F,MAAMC,GAAG,GAAGjE,GAAG,CAACkE,MAAM,CAACpC,IAAI,CAACqC,QAAQ,EAAEP,IAAI,CAAC;MAE3C,MAAM;QAAEe,SAAS;QAAEc,QAAQ;QAAElB;MAAc,CAAE,GAAG,MAAMxD,KAAK,CAAC2E,IAAI,CAAC1B,GAAG,EAAE;QACpEnC,UAAU;QACVoC,GAAG;QACHK,mBAAmB,EAAEkB,IAAI;QACzBG,KAAK,EAAEpE,OAAO,CAACoE;OAChB,CAAC;MACF,IAAIR,KAA6B;MACjC,IAAI/C,WAAoC;MACxC,IAAI/C,gBAAgB,CAACoG,QAAQ,CAACG,IAAI,CAAC,EAAE;QACnC,IAAI7E,KAAK,CAAC8E,OAAO,IAAI,IAAI,EAAE;UACzB,MAAMrG,aAAa,CAACkC,QAAQ,CAAC,IAAI/B,uBAAuB,EAAE,CAAC;QAC7D;QACA,MAAMmG,IAAI,GAAGL,QAAQ,CAACG,IAAI,CAACxD,WAAW;QACtCA,WAAW,GAAG,MAAMhC,WAAW,CAAC2F,MAAM,CAAC;UACrC3D,WAAW,EAAE0D,IAAI;UACjBD,OAAO,EAAE9E,KAAK,CAAC8E,OAAO;UACtBzE,UAAU,EAAEjB,SAAS,CAACgB,IAAI,CAACC,UAAU,CAAC;UACtCmB;SACD,CAAC;QACF,MAAMyD,IAAI,GAAG,CAACzF,WAAW,CAAC,gBAAgB,CAAC,EAAEoE,SAAS,CAAC;QACvD,MAAMH,MAAM,GAAG,IAAIyB,WAAW,EAAE,CAAC1C,MAAM,CACrClD,oBAAoB,CAAC+B,WAAW,CAAC8D,WAAW,CAAC,CAAC,GAAGF,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CACnE;QAED,QAAQxB,MAAM;UACZ,KAAK,SAAS;YACZW,KAAK,GAAG9E,oBAAoB,CAAC+B,WAAW,CAAC8D,WAAW,CAAC,CAAC,GAAGF,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;YACzE;UACF,KAAK,UAAU;YAAE;cACf;cACA,MAAMG,UAAU,GAAG,IAAIC,UAAU,CAC/B/F,oBAAoB,CAAC+B,WAAW,CAAC8D,WAAW,CAAC,CAAC,GAAGF,IAAI,EAAE,aAAa,CAAC,CAAC,CAAE,CACzE,CAAC,CAAC,CAAC;cACJ,MAAMK,aAAa,GAAG,IAAIJ,WAAW,EAAE,CAAC1C,MAAM,CAC5ClD,oBAAoB,CAAC+B,WAAW,CAAC8D,WAAW,CAAC,CAAC,GAAGF,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAE,CAC5E;cAED,MAAMM,cAAc,GAAGjG,oBAAoB,CACzC+B,WAAW,CAAC8D,WAAW,CAAC,CAAC,GAAGF,IAAI,EAAE,YAAY,CAAC,CAAC,CACjD;cACD,MAAMlB,UAAU,GAAGwB,cAAc,GAC7B,IAAIL,WAAW,EAAE,CAAC1C,MAAM,CAAC+C,cAAc,CAAC,GACxCvD,SAAS;cAEb,MAAMwD,wBAAwB,GAAG,IAAIhH,wBAAwB,CAC3DoF,SAAS,EACTwB,UAAU,EACVE,aAAa,EACbvB,UAAU,CACX;cACDyB,wBAAwB,CAACvB,WAAW,GAAG;gBACrC5D,UAAU,EAAE4C,GAAG;gBACfnC,UAAU;gBACVG,WAAW,EAAEyD;eACd;cACD,MAAM7F,WAAW,CAAC8B,QAAQ,CAAC6E,wBAAwB,CAAC;YACtD;QACF;MACF,CAAC,MAAM,IAAInH,gBAAgB,CAACqG,QAAQ,CAACG,IAAI,CAAC,EAAE;QAC1C;QACA,MAAM;UAAEhB,WAAW;UAAEC,cAAc;UAAEC;QAAU,CAAE,GAAGW,QAAQ,CAACG,IAAI;QACjE,MAAMW,wBAAwB,GAAG,IAAIhH,wBAAwB,CAC3DoF,SAAS,EACTC,WAAW,EACXC,cAAc,EACdC,UAAU,CACX;QACDyB,wBAAwB,CAACvB,WAAW,GAAG;UACrC5D,UAAU,EAAE4C,GAAG;UACfnC,UAAU;UACVG,WAAW,EAAEyD;SACd;QACD,MAAM7F,WAAW,CAAC8B,QAAQ,CAAC6E,wBAAwB,CAAC;MACtD;MAEA;MACA,IAAId,QAAQ,CAACjB,MAAM,KAAK,GAAG,EAAE;QAC3B,MAAMgC,WAAW,GAAmB;UAClC,GAAGhD,cAAc;UACjBjB;SACD;QACD;QACA,MAAMkD,QAAQ,GAAG,MAAMxF,eAAe,CAACc,KAAK,EAAEyE,IAAI,EAAEb,SAAS,EAAE6B,WAAW,CAAC;QAC3EpE,WAAW,GAAGqD,QAAQ,CAACrD,WAAW;QAClC+C,KAAK,GAAGM,QAAQ,CAACN,KAAK;MACxB;MACA,MAAMsB,wBAAwB,GAAG3E,IAAI,CAACG,WAAW,CAACyB,QAAQ,CAACvB,8BAA8B,CAAC;MAC1F,MAAMuE,wBAAwB,GAAG5E,IAAI,CAACG,WAAW,CAACyB,QAAQ,CAACrB,6BAA6B,CAAC;MAEzF,MAAML,WAAW,GAAG;QAAE,GAAGyD,QAAQ;QAAElB;MAAc,CAAyB;MAC1E,IAAIY,KAAK,KAAKpC,SAAS,EAAE;QACvB,IAAI0D,wBAAwB,IAAIC,wBAAwB,EAAE;UACxD,OAAO;YACL1E,WAAW;YACXI,WAAW;YACXgC,MAAM,EAAEjB,iBAAiB,CAACrB,IAAI,CAACoD,QAAQ,EAAEC,KAAK;WAC/C;QACH,CAAC,MAAM,IAAIuB,wBAAwB,EAAE;UACnC,OAAO;YACLtE,WAAW;YACXgC,MAAM,EAAEjB,iBAAiB,CAACrB,IAAI,CAACoD,QAAQ,EAAEC,KAAK;WAC/C;QACH,CAAC,MAAM,IAAIsB,wBAAwB,EAAE;UACnC,OAAO;YACLzE,WAAW;YACXoC,MAAM,EAAEjB,iBAAiB,CAACrB,IAAI,CAACoD,QAAQ,EAAEC,KAAK;WAC/C;QACH;QACA,OAAOhC,iBAAiB,CAACrB,IAAI,CAACoD,QAAQ,EAAEC,KAAK,CAAC;MAChD,CAAC,MAAM,IAAIrD,IAAI,CAACoD,QAAQ,CAACpC,MAAM,KAAK,CAAC,EAAE;QACrC,OAAO2D,wBAAwB,GAC3B;UACEzE,WAAW,EAAEyD,QAAQ;UACrBrB,MAAM,EAAErB;SACT,GACDA,SAAS;MACf,CAAC,MAAM;QACL,MAAMhD,YAAY,CAAC2B,QAAQ,CACzB,IAAI5B,mBAAmB,CACrB,0CAA0CgC,IAAI,CAACoD,QAAQ,CAACyB,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,OAAO,EAAE,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,IAAI,CAC5F,CACF;MACH;IACF,CAAC;EACH;EAEA,MAAMC,OAAO,GAAG,SAAAA,CAAA;IAAA,SAAAC,KAAA,GAAAnE,SAAA,CAAAC,MAAA,EAAIc,IAAe,OAAAC,KAAA,CAAAmD,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAfrD,IAAe,CAAAqD,KAAA,IAAApE,SAAA,CAAAoE,KAAA;IAAA;IAAA,OAAKxD,MAAM,CAAC,EAAE,EAAE,GAAGG,IAAI,CAAC;EAAA;EAC3DmD,OAAO,CAACG,WAAW,GAChB3F,OAAmB,IACpB;IAAA,SAAA4F,KAAA,GAAAtE,SAAA,CAAAC,MAAA,EAAIc,IAAe,OAAAC,KAAA,CAAAsD,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAfxD,IAAe,CAAAwD,KAAA,IAAAvE,SAAA,CAAAuE,KAAA;IAAA;IAAA,OACjB3D,MAAM,CAAClC,OAAO,EAAE,GAAGqC,IAAI,CAAC;EAAA;EAC5B,OAAOmD,OAAsB;AAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}