{"ast":null,"code":"import { Certificate, lookupResultToBuffer } from \"../certificate.js\";\nimport { CertifiedRejectErrorCode, ExternalError, InputError, InvalidReadStateRequestErrorCode, MissingRootKeyErrorCode, RejectError, RequestStatusDoneNoReplyErrorCode, UnknownError, UNREACHABLE_ERROR } from \"../errors.js\";\nimport * as _strategy from \"./strategy.js\";\nexport { _strategy as strategy };\nimport { defaultStrategy } from \"./strategy.js\";\nimport { ReadRequestType } from \"../agent/http/types.js\";\nimport { RequestStatusResponseStatus } from \"../agent/index.js\";\nimport { utf8ToBytes } from '@noble/hashes/utils';\nexport { defaultStrategy } from \"./strategy.js\";\nexport const DEFAULT_POLLING_OPTIONS = {\n  strategy: defaultStrategy(),\n  preSignReadStateRequest: false\n};\n/**\n * Check if an object has a property\n * @param value the object that might have the property\n * @param property the key of property we're looking for\n */\nfunction hasProperty(value, property) {\n  return Object.prototype.hasOwnProperty.call(value, property);\n}\nfunction isObjectWithProperty(value, property) {\n  return value !== null && typeof value === 'object' && hasProperty(value, property);\n}\nfunction hasFunction(value, property) {\n  return hasProperty(value, property) && typeof value[property] === 'function';\n}\n/**\n * Check if value is a signed read state request with expiry\n * @param value to check\n */\nfunction isSignedReadStateRequestWithExpiry(value) {\n  return isObjectWithProperty(value, 'body') && isObjectWithProperty(value.body, 'content') && value.body.content.request_type === ReadRequestType.ReadState && isObjectWithProperty(value.body.content, 'ingress_expiry') && typeof value.body.content.ingress_expiry === 'object' && value.body.content.ingress_expiry !== null && hasFunction(value.body.content.ingress_expiry, 'toHash');\n}\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param options polling options to control behavior\n */\nexport async function pollForResponse(agent, canisterId, requestId) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const path = [utf8ToBytes('request_status'), requestId];\n  let state;\n  let currentRequest;\n  const preSignReadStateRequest = options.preSignReadStateRequest ?? false;\n  if (preSignReadStateRequest) {\n    // If preSignReadStateRequest is true, we need to create a new request\n    currentRequest = await constructRequest({\n      paths: [path],\n      agent,\n      pollingOptions: options\n    });\n    state = await agent.readState(canisterId, {\n      paths: [path]\n    }, undefined, currentRequest);\n  } else {\n    // If preSignReadStateRequest is false, we use the default strategy and sign the request each time\n    state = await agent.readState(canisterId, {\n      paths: [path]\n    });\n  }\n  if (agent.rootKey == null) {\n    throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n  }\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify: options.blsVerify\n  });\n  const maybeBuf = lookupResultToBuffer(cert.lookup_path([...path, utf8ToBytes('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n  switch (status) {\n    case RequestStatusResponseStatus.Replied:\n      {\n        return {\n          reply: lookupResultToBuffer(cert.lookup_path([...path, 'reply'])),\n          certificate: cert\n        };\n      }\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      {\n        // Execute the polling strategy, then retry.\n        const strategy = options.strategy ?? defaultStrategy();\n        await strategy(canisterId, requestId, status);\n        return pollForResponse(agent, canisterId, requestId, {\n          ...options,\n          request: currentRequest\n        });\n      }\n    case RequestStatusResponseStatus.Rejected:\n      {\n        const rejectCode = new Uint8Array(lookupResultToBuffer(cert.lookup_path([...path, 'reject_code'])))[0];\n        const rejectMessage = new TextDecoder().decode(lookupResultToBuffer(cert.lookup_path([...path, 'reject_message'])));\n        const errorCodeBuf = lookupResultToBuffer(cert.lookup_path([...path, 'error_code']));\n        const errorCode = errorCodeBuf ? new TextDecoder().decode(errorCodeBuf) : undefined;\n        throw RejectError.fromCode(new CertifiedRejectErrorCode(requestId, rejectCode, rejectMessage, errorCode));\n      }\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw UnknownError.fromCode(new RequestStatusDoneNoReplyErrorCode(requestId));\n  }\n  throw UNREACHABLE_ERROR;\n}\n// Determine if we should reuse the read state request or create a new one\n// based on the options provided.\n/**\n * Constructs a read state request for the given paths.\n * If the request is already signed and has an expiry, it will be returned as is.\n * Otherwise, a new request will be created.\n * @param options The options to use for creating the request.\n * @param options.paths The paths to read from.\n * @param options.agent The agent to use to create the request.\n * @param options.pollingOptions The options to use for creating the request.\n * @returns The read state request.\n */\nexport async function constructRequest(options) {\n  const {\n    paths,\n    agent,\n    pollingOptions\n  } = options;\n  if (pollingOptions.request && isSignedReadStateRequestWithExpiry(pollingOptions.request)) {\n    return pollingOptions.request;\n  }\n  const request = await agent.createReadStateRequest?.({\n    paths\n  }, undefined);\n  if (!isSignedReadStateRequestWithExpiry(request)) {\n    throw InputError.fromCode(new InvalidReadStateRequestErrorCode(request));\n  }\n  return request;\n}","map":{"version":3,"names":["Certificate","lookupResultToBuffer","CertifiedRejectErrorCode","ExternalError","InputError","InvalidReadStateRequestErrorCode","MissingRootKeyErrorCode","RejectError","RequestStatusDoneNoReplyErrorCode","UnknownError","UNREACHABLE_ERROR","_strategy","strategy","defaultStrategy","ReadRequestType","RequestStatusResponseStatus","utf8ToBytes","DEFAULT_POLLING_OPTIONS","preSignReadStateRequest","hasProperty","value","property","Object","prototype","hasOwnProperty","call","isObjectWithProperty","hasFunction","isSignedReadStateRequestWithExpiry","body","content","request_type","ReadState","ingress_expiry","pollForResponse","agent","canisterId","requestId","options","arguments","length","undefined","path","state","currentRequest","constructRequest","paths","pollingOptions","readState","rootKey","fromCode","cert","create","certificate","blsVerify","maybeBuf","lookup_path","status","Unknown","TextDecoder","decode","Replied","reply","Received","Processing","request","Rejected","rejectCode","Uint8Array","rejectMessage","errorCodeBuf","errorCode","Done","createReadStateRequest"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\polling\\index.ts"],"sourcesContent":["import { type RequestId } from '../request_id.ts';\nimport { type CreateCertificateOptions, Certificate, lookupResultToBuffer } from '../certificate.ts';\nimport { type Agent, type ReadStateResponse } from '../agent/api.ts';\nimport { Principal } from '@dfinity/principal';\nimport {\n  CertifiedRejectErrorCode,\n  ExternalError,\n  InputError,\n  InvalidReadStateRequestErrorCode,\n  MissingRootKeyErrorCode,\n  RejectError,\n  RequestStatusDoneNoReplyErrorCode,\n  UnknownError,\n  UNREACHABLE_ERROR,\n} from '../errors.ts';\n\nexport * as strategy from './strategy.ts';\nimport { defaultStrategy } from './strategy.ts';\nimport { ReadRequestType, type ReadStateRequest } from '../agent/http/types.ts';\nimport { RequestStatusResponseStatus } from '../agent/index.ts';\nimport { utf8ToBytes } from '@noble/hashes/utils';\nexport { defaultStrategy } from './strategy.ts';\n\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\n\nexport type PollStrategyFactory = () => PollStrategy;\n\ninterface SignedReadStateRequestWithExpiry extends ReadStateRequest {\n  body: {\n    content: Pick<ReadStateRequest, 'request_type' | 'ingress_expiry'>;\n  };\n}\n\n/**\n * Options for controlling polling behavior\n */\nexport interface PollingOptions {\n  /**\n   * A polling strategy that dictates how much and often we should poll the\n   * read_state endpoint to get the result of an update call.\n   * @default defaultStrategy()\n   */\n  strategy?: PollStrategy;\n\n  /**\n   * Whether to reuse the same signed request for polling or create a new unsigned request each time.\n   * @default false\n   */\n  preSignReadStateRequest?: boolean;\n\n  /**\n   * Optional replacement function that verifies the BLS signature of a certificate.\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n\n  /**\n   * The request to use for polling. If not provided, a new request will be created.\n   * This is only used if `preSignReadStateRequest` is set to false.\n   */\n  request?: ReadStateRequest;\n}\n\nexport const DEFAULT_POLLING_OPTIONS: PollingOptions = {\n  strategy: defaultStrategy(),\n  preSignReadStateRequest: false,\n};\n\n/**\n * Check if an object has a property\n * @param value the object that might have the property\n * @param property the key of property we're looking for\n */\nfunction hasProperty<O extends object, P extends string>(\n  value: O,\n  property: P,\n): value is O & Record<P, unknown> {\n  return Object.prototype.hasOwnProperty.call(value, property);\n}\n\nfunction isObjectWithProperty<O extends object, P extends string>(\n  value: unknown,\n  property: P,\n): value is O & Record<P, unknown> {\n  return value !== null && typeof value === 'object' && hasProperty(value, property);\n}\n\nfunction hasFunction<O extends object, P extends string>(\n  value: O,\n  property: P,\n): value is O & Record<P, (...args: unknown[]) => unknown> {\n  return hasProperty(value, property) && typeof value[property] === 'function';\n}\n\n/**\n * Check if value is a signed read state request with expiry\n * @param value to check\n */\nfunction isSignedReadStateRequestWithExpiry(\n  value: unknown,\n): value is SignedReadStateRequestWithExpiry {\n  return (\n    isObjectWithProperty(value, 'body') &&\n    isObjectWithProperty(value.body, 'content') &&\n    (value.body.content as { request_type: ReadRequestType }).request_type ===\n      ReadRequestType.ReadState &&\n    isObjectWithProperty(value.body.content, 'ingress_expiry') &&\n    typeof value.body.content.ingress_expiry === 'object' &&\n    value.body.content.ingress_expiry !== null &&\n    hasFunction(value.body.content.ingress_expiry, 'toHash')\n  );\n}\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param options polling options to control behavior\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  options: PollingOptions = {},\n): Promise<{\n  certificate: Certificate;\n  reply: Uint8Array;\n}> {\n  const path = [utf8ToBytes('request_status'), requestId];\n\n  let state: ReadStateResponse;\n  let currentRequest: ReadStateRequest | undefined;\n  const preSignReadStateRequest = options.preSignReadStateRequest ?? false;\n  if (preSignReadStateRequest) {\n    // If preSignReadStateRequest is true, we need to create a new request\n    currentRequest = await constructRequest({\n      paths: [path],\n      agent,\n      pollingOptions: options,\n    });\n    state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  } else {\n    // If preSignReadStateRequest is false, we use the default strategy and sign the request each time\n    state = await agent.readState(canisterId, { paths: [path] });\n  }\n\n  if (agent.rootKey == null) {\n    throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n  }\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify: options.blsVerify,\n  });\n\n  const maybeBuf = lookupResultToBuffer(cert.lookup_path([...path, utf8ToBytes('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return {\n        reply: lookupResultToBuffer(cert.lookup_path([...path, 'reply']))!,\n        certificate: cert,\n      };\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing: {\n      // Execute the polling strategy, then retry.\n      const strategy = options.strategy ?? defaultStrategy();\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, {\n        ...options,\n        request: currentRequest,\n      });\n    }\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(\n        lookupResultToBuffer(cert.lookup_path([...path, 'reject_code']))!,\n      )[0];\n      const rejectMessage = new TextDecoder().decode(\n        lookupResultToBuffer(cert.lookup_path([...path, 'reject_message']))!,\n      );\n      const errorCodeBuf = lookupResultToBuffer(cert.lookup_path([...path, 'error_code']));\n      const errorCode = errorCodeBuf ? new TextDecoder().decode(errorCodeBuf) : undefined;\n      throw RejectError.fromCode(\n        new CertifiedRejectErrorCode(requestId, rejectCode, rejectMessage, errorCode),\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw UnknownError.fromCode(new RequestStatusDoneNoReplyErrorCode(requestId));\n  }\n  throw UNREACHABLE_ERROR;\n}\n\n// Determine if we should reuse the read state request or create a new one\n// based on the options provided.\n\n/**\n * Constructs a read state request for the given paths.\n * If the request is already signed and has an expiry, it will be returned as is.\n * Otherwise, a new request will be created.\n * @param options The options to use for creating the request.\n * @param options.paths The paths to read from.\n * @param options.agent The agent to use to create the request.\n * @param options.pollingOptions The options to use for creating the request.\n * @returns The read state request.\n */\nexport async function constructRequest(options: {\n  paths: Uint8Array[][];\n  agent: Agent;\n  pollingOptions: PollingOptions;\n}): Promise<ReadStateRequest> {\n  const { paths, agent, pollingOptions } = options;\n  if (pollingOptions.request && isSignedReadStateRequestWithExpiry(pollingOptions.request)) {\n    return pollingOptions.request;\n  }\n  const request = await agent.createReadStateRequest?.(\n    {\n      paths,\n    },\n    undefined,\n  );\n  if (!isSignedReadStateRequestWithExpiry(request)) {\n    throw InputError.fromCode(new InvalidReadStateRequestErrorCode(request));\n  }\n  return request;\n}\n"],"mappings":"AACA,SAAwCA,WAAW,EAAEC,oBAAoB,QAAQ,mBAAmB;AAGpG,SACEC,wBAAwB,EACxBC,aAAa,EACbC,UAAU,EACVC,gCAAgC,EAChCC,uBAAuB,EACvBC,WAAW,EACXC,iCAAiC,EACjCC,YAAY,EACZC,iBAAiB,QACZ,cAAc;AAAC,YAAAC,SAAA,MAEI,eAAe;AAAA,SAAAA,SAAA,IAA7BC,QAAQ;AACpB,SAASC,eAAe,QAAQ,eAAe;AAC/C,SAASC,eAAe,QAA+B,wBAAwB;AAC/E,SAASC,2BAA2B,QAAQ,mBAAmB;AAC/D,SAASC,WAAW,QAAQ,qBAAqB;AACjD,SAASH,eAAe,QAAQ,eAAe;AA6C/C,OAAO,MAAMI,uBAAuB,GAAmB;EACrDL,QAAQ,EAAEC,eAAe,EAAE;EAC3BK,uBAAuB,EAAE;CAC1B;AAED;;;;;AAKA,SAASC,WAAWA,CAClBC,KAAQ,EACRC,QAAW;EAEX,OAAOC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACL,KAAK,EAAEC,QAAQ,CAAC;AAC9D;AAEA,SAASK,oBAAoBA,CAC3BN,KAAc,EACdC,QAAW;EAEX,OAAOD,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAID,WAAW,CAACC,KAAK,EAAEC,QAAQ,CAAC;AACpF;AAEA,SAASM,WAAWA,CAClBP,KAAQ,EACRC,QAAW;EAEX,OAAOF,WAAW,CAACC,KAAK,EAAEC,QAAQ,CAAC,IAAI,OAAOD,KAAK,CAACC,QAAQ,CAAC,KAAK,UAAU;AAC9E;AAEA;;;;AAIA,SAASO,kCAAkCA,CACzCR,KAAc;EAEd,OACEM,oBAAoB,CAACN,KAAK,EAAE,MAAM,CAAC,IACnCM,oBAAoB,CAACN,KAAK,CAACS,IAAI,EAAE,SAAS,CAAC,IAC1CT,KAAK,CAACS,IAAI,CAACC,OAA6C,CAACC,YAAY,KACpEjB,eAAe,CAACkB,SAAS,IAC3BN,oBAAoB,CAACN,KAAK,CAACS,IAAI,CAACC,OAAO,EAAE,gBAAgB,CAAC,IAC1D,OAAOV,KAAK,CAACS,IAAI,CAACC,OAAO,CAACG,cAAc,KAAK,QAAQ,IACrDb,KAAK,CAACS,IAAI,CAACC,OAAO,CAACG,cAAc,KAAK,IAAI,IAC1CN,WAAW,CAACP,KAAK,CAACS,IAAI,CAACC,OAAO,CAACG,cAAc,EAAE,QAAQ,CAAC;AAE5D;AAEA;;;;;;;;AAQA,OAAO,eAAeC,eAAeA,CACnCC,KAAY,EACZC,UAAqB,EACrBC,SAAoB,EACQ;EAAA,IAA5BC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA0B,EAAE;EAK5B,MAAMG,IAAI,GAAG,CAAC1B,WAAW,CAAC,gBAAgB,CAAC,EAAEqB,SAAS,CAAC;EAEvD,IAAIM,KAAwB;EAC5B,IAAIC,cAA4C;EAChD,MAAM1B,uBAAuB,GAAGoB,OAAO,CAACpB,uBAAuB,IAAI,KAAK;EACxE,IAAIA,uBAAuB,EAAE;IAC3B;IACA0B,cAAc,GAAG,MAAMC,gBAAgB,CAAC;MACtCC,KAAK,EAAE,CAACJ,IAAI,CAAC;MACbP,KAAK;MACLY,cAAc,EAAET;KACjB,CAAC;IACFK,KAAK,GAAG,MAAMR,KAAK,CAACa,SAAS,CAACZ,UAAU,EAAE;MAAEU,KAAK,EAAE,CAACJ,IAAI;IAAC,CAAE,EAAED,SAAS,EAAEG,cAAc,CAAC;EACzF,CAAC,MAAM;IACL;IACAD,KAAK,GAAG,MAAMR,KAAK,CAACa,SAAS,CAACZ,UAAU,EAAE;MAAEU,KAAK,EAAE,CAACJ,IAAI;IAAC,CAAE,CAAC;EAC9D;EAEA,IAAIP,KAAK,CAACc,OAAO,IAAI,IAAI,EAAE;IACzB,MAAM9C,aAAa,CAAC+C,QAAQ,CAAC,IAAI5C,uBAAuB,EAAE,CAAC;EAC7D;EACA,MAAM6C,IAAI,GAAG,MAAMnD,WAAW,CAACoD,MAAM,CAAC;IACpCC,WAAW,EAAEV,KAAK,CAACU,WAAW;IAC9BJ,OAAO,EAAEd,KAAK,CAACc,OAAO;IACtBb,UAAU,EAAEA,UAAU;IACtBkB,SAAS,EAAEhB,OAAO,CAACgB;GACpB,CAAC;EAEF,MAAMC,QAAQ,GAAGtD,oBAAoB,CAACkD,IAAI,CAACK,WAAW,CAAC,CAAC,GAAGd,IAAI,EAAE1B,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;EACzF,IAAIyC,MAAM;EACV,IAAI,OAAOF,QAAQ,KAAK,WAAW,EAAE;IACnC;IACAE,MAAM,GAAG1C,2BAA2B,CAAC2C,OAAO;EAC9C,CAAC,MAAM;IACLD,MAAM,GAAG,IAAIE,WAAW,EAAE,CAACC,MAAM,CAACL,QAAQ,CAAC;EAC7C;EAEA,QAAQE,MAAM;IACZ,KAAK1C,2BAA2B,CAAC8C,OAAO;MAAE;QACxC,OAAO;UACLC,KAAK,EAAE7D,oBAAoB,CAACkD,IAAI,CAACK,WAAW,CAAC,CAAC,GAAGd,IAAI,EAAE,OAAO,CAAC,CAAC,CAAE;UAClEW,WAAW,EAAEF;SACd;MACH;IAEA,KAAKpC,2BAA2B,CAACgD,QAAQ;IACzC,KAAKhD,2BAA2B,CAAC2C,OAAO;IACxC,KAAK3C,2BAA2B,CAACiD,UAAU;MAAE;QAC3C;QACA,MAAMpD,QAAQ,GAAG0B,OAAO,CAAC1B,QAAQ,IAAIC,eAAe,EAAE;QACtD,MAAMD,QAAQ,CAACwB,UAAU,EAAEC,SAAS,EAAEoB,MAAM,CAAC;QAC7C,OAAOvB,eAAe,CAACC,KAAK,EAAEC,UAAU,EAAEC,SAAS,EAAE;UACnD,GAAGC,OAAO;UACV2B,OAAO,EAAErB;SACV,CAAC;MACJ;IAEA,KAAK7B,2BAA2B,CAACmD,QAAQ;MAAE;QACzC,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAC/BnE,oBAAoB,CAACkD,IAAI,CAACK,WAAW,CAAC,CAAC,GAAGd,IAAI,EAAE,aAAa,CAAC,CAAC,CAAE,CAClE,CAAC,CAAC,CAAC;QACJ,MAAM2B,aAAa,GAAG,IAAIV,WAAW,EAAE,CAACC,MAAM,CAC5C3D,oBAAoB,CAACkD,IAAI,CAACK,WAAW,CAAC,CAAC,GAAGd,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAE,CACrE;QACD,MAAM4B,YAAY,GAAGrE,oBAAoB,CAACkD,IAAI,CAACK,WAAW,CAAC,CAAC,GAAGd,IAAI,EAAE,YAAY,CAAC,CAAC,CAAC;QACpF,MAAM6B,SAAS,GAAGD,YAAY,GAAG,IAAIX,WAAW,EAAE,CAACC,MAAM,CAACU,YAAY,CAAC,GAAG7B,SAAS;QACnF,MAAMlC,WAAW,CAAC2C,QAAQ,CACxB,IAAIhD,wBAAwB,CAACmC,SAAS,EAAE8B,UAAU,EAAEE,aAAa,EAAEE,SAAS,CAAC,CAC9E;MACH;IAEA,KAAKxD,2BAA2B,CAACyD,IAAI;MACnC;MACA;MACA,MAAM/D,YAAY,CAACyC,QAAQ,CAAC,IAAI1C,iCAAiC,CAAC6B,SAAS,CAAC,CAAC;EACjF;EACA,MAAM3B,iBAAiB;AACzB;AAEA;AACA;AAEA;;;;;;;;;;AAUA,OAAO,eAAemC,gBAAgBA,CAACP,OAItC;EACC,MAAM;IAAEQ,KAAK;IAAEX,KAAK;IAAEY;EAAc,CAAE,GAAGT,OAAO;EAChD,IAAIS,cAAc,CAACkB,OAAO,IAAIrC,kCAAkC,CAACmB,cAAc,CAACkB,OAAO,CAAC,EAAE;IACxF,OAAOlB,cAAc,CAACkB,OAAO;EAC/B;EACA,MAAMA,OAAO,GAAG,MAAM9B,KAAK,CAACsC,sBAAsB,GAChD;IACE3B;GACD,EACDL,SAAS,CACV;EACD,IAAI,CAACb,kCAAkC,CAACqC,OAAO,CAAC,EAAE;IAChD,MAAM7D,UAAU,CAAC8C,QAAQ,CAAC,IAAI7C,gCAAgC,CAAC4D,OAAO,CAAC,CAAC;EAC1E;EACA,OAAOA,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}