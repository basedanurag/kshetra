{"ast":null,"code":"import { requestIdOf, SignIdentity, IC_REQUEST_DOMAIN_SEPARATOR, IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR } from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport { PartialIdentity } from \"./partial.js\";\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\nfunction _parseBlob(value) {\n  if (typeof value !== 'string' || value.length < 64) {\n    throw new Error('Invalid public key.');\n  }\n  return hexToBytes(value);\n}\n/**\n * A single delegation object that is signed by a private key. This is constructed by\n * `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport class Delegation {\n  constructor(pubkey, expiration, targets) {\n    this.pubkey = pubkey;\n    this.expiration = expiration;\n    this.targets = targets;\n  }\n  toCborValue() {\n    return {\n      pubkey: this.pubkey,\n      expiration: this.expiration,\n      ...(this.targets && {\n        targets: this.targets\n      })\n    };\n  }\n  toJSON() {\n    // every string should be hex and once-de-hexed,\n    // discoverable what it is (e.g. de-hex to get JSON with a 'type' property, or de-hex to DER\n    // with an OID). After de-hex, if it's not obvious what it is, it's an ArrayBuffer.\n    return {\n      expiration: this.expiration.toString(16),\n      pubkey: bytesToHex(this.pubkey),\n      ...(this.targets && {\n        targets: this.targets.map(p => p.toHex())\n      })\n    };\n  }\n}\n/**\n * Sign a single delegation object for a period of time.\n * @param from The identity that lends its delegation.\n * @param to The identity that receives the delegation.\n * @param expiration An expiration date for this delegation.\n * @param targets Limit this delegation to the target principals.\n */\nasync function _createSingleDelegation(from, to, expiration, targets) {\n  const delegation = new Delegation(to.toDer(), BigInt(+expiration) * BigInt(1000000),\n  // In nanoseconds.\n  targets);\n  // The signature is calculated by signing the concatenation of the domain separator\n  // and the message.\n  // Note: To ensure Safari treats this as a user gesture, ensure to not use async methods\n  // besides the actualy webauthn functionality (such as `sign`). Safari will de-register\n  // a user gesture if you await an async call thats not fetch, xhr, or setTimeout.\n  const challenge = new Uint8Array([...IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR, ...new Uint8Array(requestIdOf({\n    ...delegation\n  }))]);\n  const signature = await from.sign(challenge);\n  return {\n    delegation,\n    signature\n  };\n}\n/**\n * A chain of delegations. This is JSON Serializable.\n * This is the object to serialize and pass to a DelegationIdentity. It does not keep any\n * private keys.\n */\nexport class DelegationChain {\n  /**\n   * Create a delegation chain between two (or more) keys. By default, the expiration time\n   * will be very short (15 minutes).\n   *\n   * To build a chain of more than 2 identities, this function needs to be called multiple times,\n   * passing the previous delegation chain into the options argument. For example:\n   * @example\n   * const rootKey = createKey();\n   * const middleKey = createKey();\n   * const bottomeKey = createKey();\n   *\n   * const rootToMiddle = await DelegationChain.create(\n   *   root, middle.getPublicKey(), Date.parse('2100-01-01'),\n   * );\n   * const middleToBottom = await DelegationChain.create(\n   *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },\n   * );\n   *\n   * // We can now use a delegation identity that uses the delegation above:\n   * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);\n   * @param from The identity that will delegate.\n   * @param to The identity that gets delegated. It can now sign messages as if it was the\n   *           identity above.\n   * @param expiration The length the delegation is valid. By default, 15 minutes from calling\n   *                   this function.\n   * @param options A set of options for this delegation. expiration and previous\n   * @param options.previous - Another DelegationChain that this chain should start with.\n   * @param options.targets - targets that scope the delegation (e.g. Canister Principals)\n   */\n  static async create(from, to, expiration = new Date(Date.now() + 15 * 60 * 1000), options = {}) {\n    const delegation = await _createSingleDelegation(from, to, expiration, options.targets);\n    return new DelegationChain([...(options.previous?.delegations || []), delegation], options.previous?.publicKey || from.getPublicKey().toDer());\n  }\n  /**\n   * Creates a DelegationChain object from a JSON string.\n   * @param json The JSON string to parse.\n   */\n  static fromJSON(json) {\n    const {\n      publicKey,\n      delegations\n    } = typeof json === 'string' ? JSON.parse(json) : json;\n    if (!Array.isArray(delegations)) {\n      throw new Error('Invalid delegations.');\n    }\n    const parsedDelegations = delegations.map(signedDelegation => {\n      const {\n        delegation,\n        signature\n      } = signedDelegation;\n      const {\n        pubkey,\n        expiration,\n        targets\n      } = delegation;\n      if (targets !== undefined && !Array.isArray(targets)) {\n        throw new Error('Invalid targets.');\n      }\n      return {\n        delegation: new Delegation(_parseBlob(pubkey), BigInt('0x' + expiration),\n        // expiration in JSON is an hexa string (See toJSON() below).\n        targets && targets.map(t => {\n          if (typeof t !== 'string') {\n            throw new Error('Invalid target.');\n          }\n          return Principal.fromHex(t);\n        })),\n        signature: _parseBlob(signature)\n      };\n    });\n    return new this(parsedDelegations, _parseBlob(publicKey));\n  }\n  /**\n   * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.\n   * @param delegations The list of delegations.\n   * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.\n   */\n  static fromDelegations(delegations, publicKey) {\n    return new this(delegations, publicKey);\n  }\n  constructor(delegations, publicKey) {\n    this.delegations = delegations;\n    this.publicKey = publicKey;\n  }\n  toJSON() {\n    return {\n      delegations: this.delegations.map(signedDelegation => {\n        const {\n          delegation,\n          signature\n        } = signedDelegation;\n        const {\n          targets\n        } = delegation;\n        return {\n          delegation: {\n            expiration: delegation.expiration.toString(16),\n            pubkey: bytesToHex(delegation.pubkey),\n            ...(targets && {\n              targets: targets.map(t => t.toHex())\n            })\n          },\n          signature: bytesToHex(signature)\n        };\n      }),\n      publicKey: bytesToHex(this.publicKey)\n    };\n  }\n}\n/**\n * An Identity that adds delegation to a request. Everywhere in this class, the name\n * innerKey refers to the SignIdentity that is being used to sign the requests, while\n * originalKey is the identity that is being borrowed. More identities can be used\n * in the middle to delegate.\n */\nexport class DelegationIdentity extends SignIdentity {\n  /**\n   * Create a delegation without having access to delegateKey.\n   * @param key The key used to sign the requests.\n   * @param delegation A delegation object created using `createDelegation`.\n   */\n  static fromDelegation(key, delegation) {\n    return new this(key, delegation);\n  }\n  constructor(_inner, _delegation) {\n    super();\n    this._inner = _inner;\n    this._delegation = _delegation;\n  }\n  getDelegation() {\n    return this._delegation;\n  }\n  getPublicKey() {\n    return {\n      derKey: this._delegation.publicKey,\n      toDer: () => this._delegation.publicKey\n    };\n  }\n  sign(blob) {\n    return this._inner.sign(blob);\n  }\n  async transformRequest(request) {\n    const {\n      body,\n      ...fields\n    } = request;\n    const requestId = await requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_sig: await this.sign(new Uint8Array([...IC_REQUEST_DOMAIN_SEPARATOR, ...new Uint8Array(requestId)])),\n        sender_delegation: this._delegation.delegations,\n        sender_pubkey: this._delegation.publicKey\n      }\n    };\n  }\n}\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialDelegationIdentity extends PartialIdentity {\n  #delegation;\n  /**\n   * The Delegation Chain of this identity.\n   */\n  get delegation() {\n    return this.#delegation;\n  }\n  constructor(inner, delegation) {\n    super(inner);\n    this.#delegation = delegation;\n  }\n  /**\n   * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.\n   * @param key The {@link PublicKey} to delegate to.\n   * @param delegation a {@link DelegationChain} targeting the inner key.\n   */\n  static fromDelegation(key, delegation) {\n    return new PartialDelegationIdentity(key, delegation);\n  }\n}\n/**\n * Analyze a DelegationChain and validate that it's valid, ie. not expired and apply to the\n * scope.\n * @param chain The chain to validate.\n * @param checks Various checks to validate on the chain.\n */\nexport function isDelegationValid(chain, checks) {\n  // Verify that the no delegation is expired. If any are in the chain, returns false.\n  for (const {\n    delegation\n  } of chain.delegations) {\n    // prettier-ignore\n    if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {\n      return false;\n    }\n  }\n  // Check the scopes.\n  const scopes = [];\n  const maybeScope = checks?.scope;\n  if (maybeScope) {\n    if (Array.isArray(maybeScope)) {\n      scopes.push(...maybeScope.map(s => typeof s === 'string' ? Principal.fromText(s) : s));\n    } else {\n      scopes.push(typeof maybeScope === 'string' ? Principal.fromText(maybeScope) : maybeScope);\n    }\n  }\n  for (const s of scopes) {\n    const scope = s.toText();\n    for (const {\n      delegation\n    } of chain.delegations) {\n      if (delegation.targets === undefined) {\n        continue;\n      }\n      let none = true;\n      for (const target of delegation.targets) {\n        if (target.toText() === scope) {\n          none = false;\n          break;\n        }\n      }\n      if (none) {\n        return false;\n      }\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["requestIdOf","SignIdentity","IC_REQUEST_DOMAIN_SEPARATOR","IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR","Principal","PartialIdentity","bytesToHex","hexToBytes","_parseBlob","value","length","Error","Delegation","constructor","pubkey","expiration","targets","toCborValue","toJSON","toString","map","p","toHex","_createSingleDelegation","from","to","delegation","toDer","BigInt","challenge","Uint8Array","signature","sign","DelegationChain","create","Date","now","options","previous","delegations","publicKey","getPublicKey","fromJSON","json","JSON","parse","Array","isArray","parsedDelegations","signedDelegation","undefined","t","fromHex","fromDelegations","DelegationIdentity","fromDelegation","key","_inner","_delegation","getDelegation","derKey","blob","transformRequest","request","body","fields","requestId","content","sender_sig","sender_delegation","sender_pubkey","PartialDelegationIdentity","inner","isDelegationValid","chain","checks","Number","scopes","maybeScope","scope","push","s","fromText","toText","none","target"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\identity\\src\\identity\\delegation.ts"],"sourcesContent":["import {\n  type DerEncodedPublicKey,\n  type HttpAgentRequest,\n  type PublicKey,\n  requestIdOf,\n  type Signature,\n  SignIdentity,\n  IC_REQUEST_DOMAIN_SEPARATOR,\n  IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR,\n  ToCborValue,\n} from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport { PartialIdentity } from './partial.ts';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\nfunction _parseBlob(value: unknown): Uint8Array {\n  if (typeof value !== 'string' || value.length < 64) {\n    throw new Error('Invalid public key.');\n  }\n\n  return hexToBytes(value);\n}\n\n/**\n * A single delegation object that is signed by a private key. This is constructed by\n * `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport class Delegation implements ToCborValue {\n  constructor(\n    public readonly pubkey: Uint8Array,\n    public readonly expiration: bigint,\n    public readonly targets?: Principal[],\n  ) {}\n\n  public toCborValue() {\n    return {\n      pubkey: this.pubkey,\n      expiration: this.expiration,\n      ...(this.targets && {\n        targets: this.targets,\n      }),\n    };\n  }\n\n  public toJSON(): JsonnableDelegation {\n    // every string should be hex and once-de-hexed,\n    // discoverable what it is (e.g. de-hex to get JSON with a 'type' property, or de-hex to DER\n    // with an OID). After de-hex, if it's not obvious what it is, it's an ArrayBuffer.\n    return {\n      expiration: this.expiration.toString(16),\n      pubkey: bytesToHex(this.pubkey),\n      ...(this.targets && { targets: this.targets.map(p => p.toHex()) }),\n    };\n  }\n}\n\n/**\n * Type of ReturnType<Delegation.toJSON>.\n * The goal here is to stringify all non-JSON-compatible types to some bytes representation we can\n * stringify as hex.\n * (Hex shouldn't be ambiguous ever, because you can encode as DER with semantic OIDs).\n */\ninterface JsonnableDelegation {\n  // A BigInt of Nanoseconds since epoch as hex\n  expiration: string;\n  // Hexadecimal representation of the DER public key.\n  pubkey: string;\n  // Array of strings, where each string is hex of principal blob (*NOT* textual representation).\n  targets?: string[];\n}\n\n/**\n * A signed delegation, which lends its identity to the public key in the delegation\n * object. This is constructed by `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport interface SignedDelegation {\n  delegation: Delegation;\n  signature: Signature;\n}\n\n/**\n * Sign a single delegation object for a period of time.\n * @param from The identity that lends its delegation.\n * @param to The identity that receives the delegation.\n * @param expiration An expiration date for this delegation.\n * @param targets Limit this delegation to the target principals.\n */\nasync function _createSingleDelegation(\n  from: SignIdentity,\n  to: PublicKey,\n  expiration: Date,\n  targets?: Principal[],\n): Promise<SignedDelegation> {\n  const delegation: Delegation = new Delegation(\n    to.toDer(),\n    BigInt(+expiration) * BigInt(1000000), // In nanoseconds.\n    targets,\n  );\n  // The signature is calculated by signing the concatenation of the domain separator\n  // and the message.\n  // Note: To ensure Safari treats this as a user gesture, ensure to not use async methods\n  // besides the actualy webauthn functionality (such as `sign`). Safari will de-register\n  // a user gesture if you await an async call thats not fetch, xhr, or setTimeout.\n  const challenge = new Uint8Array([\n    ...IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR,\n    ...new Uint8Array(requestIdOf({ ...delegation })),\n  ]);\n  const signature = await from.sign(challenge);\n\n  return {\n    delegation,\n    signature,\n  };\n}\n\nexport interface JsonnableDelegationChain {\n  publicKey: string;\n  delegations: Array<{\n    signature: string;\n    delegation: {\n      pubkey: string;\n      expiration: string;\n      targets?: string[];\n    };\n  }>;\n}\n\n/**\n * A chain of delegations. This is JSON Serializable.\n * This is the object to serialize and pass to a DelegationIdentity. It does not keep any\n * private keys.\n */\nexport class DelegationChain {\n  /**\n   * Create a delegation chain between two (or more) keys. By default, the expiration time\n   * will be very short (15 minutes).\n   *\n   * To build a chain of more than 2 identities, this function needs to be called multiple times,\n   * passing the previous delegation chain into the options argument. For example:\n   * @example\n   * const rootKey = createKey();\n   * const middleKey = createKey();\n   * const bottomeKey = createKey();\n   *\n   * const rootToMiddle = await DelegationChain.create(\n   *   root, middle.getPublicKey(), Date.parse('2100-01-01'),\n   * );\n   * const middleToBottom = await DelegationChain.create(\n   *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },\n   * );\n   *\n   * // We can now use a delegation identity that uses the delegation above:\n   * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);\n   * @param from The identity that will delegate.\n   * @param to The identity that gets delegated. It can now sign messages as if it was the\n   *           identity above.\n   * @param expiration The length the delegation is valid. By default, 15 minutes from calling\n   *                   this function.\n   * @param options A set of options for this delegation. expiration and previous\n   * @param options.previous - Another DelegationChain that this chain should start with.\n   * @param options.targets - targets that scope the delegation (e.g. Canister Principals)\n   */\n  public static async create(\n    from: SignIdentity,\n    to: PublicKey,\n    expiration: Date = new Date(Date.now() + 15 * 60 * 1000),\n    options: {\n      previous?: DelegationChain;\n      targets?: Principal[];\n    } = {},\n  ): Promise<DelegationChain> {\n    const delegation = await _createSingleDelegation(from, to, expiration, options.targets);\n    return new DelegationChain(\n      [...(options.previous?.delegations || []), delegation],\n      options.previous?.publicKey || from.getPublicKey().toDer(),\n    );\n  }\n\n  /**\n   * Creates a DelegationChain object from a JSON string.\n   * @param json The JSON string to parse.\n   */\n  public static fromJSON(json: string | JsonnableDelegationChain): DelegationChain {\n    const { publicKey, delegations } = typeof json === 'string' ? JSON.parse(json) : json;\n    if (!Array.isArray(delegations)) {\n      throw new Error('Invalid delegations.');\n    }\n\n    const parsedDelegations: SignedDelegation[] = delegations.map(signedDelegation => {\n      const { delegation, signature } = signedDelegation;\n      const { pubkey, expiration, targets } = delegation;\n      if (targets !== undefined && !Array.isArray(targets)) {\n        throw new Error('Invalid targets.');\n      }\n\n      return {\n        delegation: new Delegation(\n          _parseBlob(pubkey),\n          BigInt('0x' + expiration), // expiration in JSON is an hexa string (See toJSON() below).\n          targets &&\n            targets.map((t: unknown) => {\n              if (typeof t !== 'string') {\n                throw new Error('Invalid target.');\n              }\n              return Principal.fromHex(t);\n            }),\n        ),\n        signature: _parseBlob(signature) as Signature,\n      };\n    });\n\n    return new this(parsedDelegations, _parseBlob(publicKey) as DerEncodedPublicKey);\n  }\n\n  /**\n   * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.\n   * @param delegations The list of delegations.\n   * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.\n   */\n  public static fromDelegations(\n    delegations: SignedDelegation[],\n    publicKey: DerEncodedPublicKey,\n  ): DelegationChain {\n    return new this(delegations, publicKey);\n  }\n\n  protected constructor(\n    public readonly delegations: SignedDelegation[],\n    public readonly publicKey: DerEncodedPublicKey,\n  ) {}\n\n  public toJSON(): JsonnableDelegationChain {\n    return {\n      delegations: this.delegations.map(signedDelegation => {\n        const { delegation, signature } = signedDelegation;\n        const { targets } = delegation;\n        return {\n          delegation: {\n            expiration: delegation.expiration.toString(16),\n            pubkey: bytesToHex(delegation.pubkey),\n            ...(targets && {\n              targets: targets.map(t => t.toHex()),\n            }),\n          },\n          signature: bytesToHex(signature),\n        };\n      }),\n      publicKey: bytesToHex(this.publicKey),\n    };\n  }\n}\n\n/**\n * An Identity that adds delegation to a request. Everywhere in this class, the name\n * innerKey refers to the SignIdentity that is being used to sign the requests, while\n * originalKey is the identity that is being borrowed. More identities can be used\n * in the middle to delegate.\n */\nexport class DelegationIdentity extends SignIdentity {\n  /**\n   * Create a delegation without having access to delegateKey.\n   * @param key The key used to sign the requests.\n   * @param delegation A delegation object created using `createDelegation`.\n   */\n  public static fromDelegation(\n    key: Pick<SignIdentity, 'sign'>,\n    delegation: DelegationChain,\n  ): DelegationIdentity {\n    return new this(key, delegation);\n  }\n\n  protected constructor(\n    private _inner: Pick<SignIdentity, 'sign'>,\n    private _delegation: DelegationChain,\n  ) {\n    super();\n  }\n\n  public getDelegation(): DelegationChain {\n    return this._delegation;\n  }\n\n  public getPublicKey(): PublicKey {\n    return {\n      derKey: this._delegation.publicKey,\n      toDer: () => this._delegation.publicKey,\n    };\n  }\n  public sign(blob: Uint8Array): Promise<Signature> {\n    return this._inner.sign(blob);\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = await requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_sig: await this.sign(\n          new Uint8Array([...IC_REQUEST_DOMAIN_SEPARATOR, ...new Uint8Array(requestId)]),\n        ),\n        sender_delegation: this._delegation.delegations,\n        sender_pubkey: this._delegation.publicKey,\n      },\n    };\n  }\n}\n\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialDelegationIdentity extends PartialIdentity {\n  #delegation: DelegationChain;\n\n  /**\n   * The Delegation Chain of this identity.\n   */\n  get delegation(): DelegationChain {\n    return this.#delegation;\n  }\n\n  private constructor(inner: PublicKey, delegation: DelegationChain) {\n    super(inner);\n    this.#delegation = delegation;\n  }\n\n  /**\n   * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.\n   * @param key The {@link PublicKey} to delegate to.\n   * @param delegation a {@link DelegationChain} targeting the inner key.\n   */\n  public static fromDelegation(key: PublicKey, delegation: DelegationChain) {\n    return new PartialDelegationIdentity(key, delegation);\n  }\n}\n\n/**\n * List of things to check for a delegation chain validity.\n */\nexport interface DelegationValidChecks {\n  /**\n   * Check that the scope is amongst the scopes that this delegation has access to.\n   */\n  scope?: Principal | string | Array<Principal | string>;\n}\n\n/**\n * Analyze a DelegationChain and validate that it's valid, ie. not expired and apply to the\n * scope.\n * @param chain The chain to validate.\n * @param checks Various checks to validate on the chain.\n */\nexport function isDelegationValid(chain: DelegationChain, checks?: DelegationValidChecks): boolean {\n  // Verify that the no delegation is expired. If any are in the chain, returns false.\n  for (const { delegation } of chain.delegations) {\n    // prettier-ignore\n    if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {\n      return false;\n    }\n  }\n\n  // Check the scopes.\n  const scopes: Principal[] = [];\n  const maybeScope = checks?.scope;\n  if (maybeScope) {\n    if (Array.isArray(maybeScope)) {\n      scopes.push(...maybeScope.map(s => (typeof s === 'string' ? Principal.fromText(s) : s)));\n    } else {\n      scopes.push(typeof maybeScope === 'string' ? Principal.fromText(maybeScope) : maybeScope);\n    }\n  }\n\n  for (const s of scopes) {\n    const scope = s.toText();\n    for (const { delegation } of chain.delegations) {\n      if (delegation.targets === undefined) {\n        continue;\n      }\n\n      let none = true;\n      for (const target of delegation.targets) {\n        if (target.toText() === scope) {\n          none = false;\n          break;\n        }\n      }\n      if (none) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}