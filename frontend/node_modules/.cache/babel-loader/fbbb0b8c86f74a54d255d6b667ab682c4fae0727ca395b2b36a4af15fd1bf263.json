{"ast":null,"code":"import { lebEncode, compare } from '@dfinity/candid';\nimport { HashValueErrorCode, InputError } from \"./errors.js\";\nimport { uint8FromBufLike } from \"./utils/buffer.js\";\nimport { concatBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha2';\n/**\n *\n * @param value unknown value\n * @returns Uint8Array\n */\nexport function hashValue(value) {\n  if (typeof value === 'string') {\n    return hashString(value);\n  } else if (typeof value === 'number') {\n    return sha256(lebEncode(value));\n  } else if (value instanceof Uint8Array || ArrayBuffer.isView(value)) {\n    return sha256(uint8FromBufLike(value));\n  } else if (Array.isArray(value)) {\n    const vals = value.map(hashValue);\n    return sha256(concatBytes(...vals));\n  } else if (value && typeof value === 'object' && value._isPrincipal) {\n    return sha256(value.toUint8Array());\n  } else if (typeof value === 'object' && value !== null && typeof value.toHash === 'function') {\n    return hashValue(value.toHash());\n    // TODO This should be move to a specific async method as the webauthn flow required\n    // the flow to be synchronous to ensure Safari touch id works.\n    // } else if (value instanceof Promise) {\n    //   return value.then(x => hashValue(x));\n  } else if (typeof value === 'object') {\n    return hashOfMap(value);\n  } else if (typeof value === 'bigint') {\n    // Do this check much later than the other bigint check because this one is much less\n    // type-safe.\n    // So we want to try all the high-assurance type guards before this 'probable' one.\n    return sha256(lebEncode(value));\n  }\n  throw InputError.fromCode(new HashValueErrorCode(value));\n}\nconst hashString = value => {\n  const encoded = new TextEncoder().encode(value);\n  return sha256(encoded);\n};\n/**\n * Get the RequestId of the provided ic-ref request.\n * RequestId is the result of the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param request - ic-ref request to hash into RequestId\n */\nexport function requestIdOf(request) {\n  return hashOfMap(request);\n}\n/**\n * Hash a map into a Uint8Array using the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param map - Any non-nested object\n * @returns Uint8Array\n */\nexport function hashOfMap(map) {\n  const hashed = Object.entries(map).filter(_ref => {\n    let [, value] = _ref;\n    return value !== undefined;\n  }).map(_ref2 => {\n    let [key, value] = _ref2;\n    const hashedKey = hashString(key);\n    const hashedValue = hashValue(value);\n    return [hashedKey, hashedValue];\n  });\n  const traversed = hashed;\n  const sorted = traversed.sort((_ref3, _ref4) => {\n    let [k1] = _ref3;\n    let [k2] = _ref4;\n    return compare(k1, k2);\n  });\n  const concatenated = concatBytes(...sorted.map(x => concatBytes(...x)));\n  const result = sha256(concatenated);\n  return result;\n}","map":{"version":3,"names":["lebEncode","compare","HashValueErrorCode","InputError","uint8FromBufLike","concatBytes","sha256","hashValue","value","hashString","Uint8Array","ArrayBuffer","isView","Array","isArray","vals","map","_isPrincipal","toUint8Array","toHash","hashOfMap","fromCode","encoded","TextEncoder","encode","requestIdOf","request","hashed","Object","entries","filter","_ref","undefined","_ref2","key","hashedKey","hashedValue","traversed","sorted","sort","_ref3","_ref4","k1","k2","concatenated","x","result"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\request_id.ts"],"sourcesContent":["import { lebEncode, compare } from '@dfinity/candid';\nimport { Principal } from '@dfinity/principal';\nimport { HashValueErrorCode, InputError } from './errors.ts';\nimport { uint8FromBufLike } from './utils/buffer.ts';\nimport { concatBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha2';\n\nexport type RequestId = Uint8Array & { __requestId__: void };\n\ninterface ToHashable {\n  toHash(): unknown;\n}\n\n/**\n *\n * @param value unknown value\n * @returns Uint8Array\n */\nexport function hashValue(value: unknown): Uint8Array {\n  if (typeof value === 'string') {\n    return hashString(value);\n  } else if (typeof value === 'number') {\n    return sha256(lebEncode(value));\n  } else if (value instanceof Uint8Array || ArrayBuffer.isView(value)) {\n    return sha256(uint8FromBufLike(value));\n  } else if (Array.isArray(value)) {\n    const vals = value.map(hashValue);\n    return sha256(concatBytes(...vals));\n  } else if (value && typeof value === 'object' && (value as Principal)._isPrincipal) {\n    return sha256((value as Principal).toUint8Array());\n  } else if (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof (value as ToHashable).toHash === 'function'\n  ) {\n    return hashValue((value as ToHashable).toHash());\n    // TODO This should be move to a specific async method as the webauthn flow required\n    // the flow to be synchronous to ensure Safari touch id works.\n    // } else if (value instanceof Promise) {\n    //   return value.then(x => hashValue(x));\n  } else if (typeof value === 'object') {\n    return hashOfMap(value as Record<string, unknown>);\n  } else if (typeof value === 'bigint') {\n    // Do this check much later than the other bigint check because this one is much less\n    // type-safe.\n    // So we want to try all the high-assurance type guards before this 'probable' one.\n    return sha256(lebEncode(value));\n  }\n  throw InputError.fromCode(new HashValueErrorCode(value));\n}\n\nconst hashString = (value: string): Uint8Array => {\n  const encoded = new TextEncoder().encode(value);\n  return sha256(encoded);\n};\n\n/**\n * Get the RequestId of the provided ic-ref request.\n * RequestId is the result of the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param request - ic-ref request to hash into RequestId\n */\nexport function requestIdOf(request: Record<string, unknown>): RequestId {\n  return hashOfMap(request) as RequestId;\n}\n\n/**\n * Hash a map into a Uint8Array using the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param map - Any non-nested object\n * @returns Uint8Array\n */\nexport function hashOfMap(map: Record<string, unknown>): Uint8Array {\n  const hashed: Array<[Uint8Array, Uint8Array]> = Object.entries(map)\n    .filter(([, value]) => value !== undefined)\n    .map(([key, value]: [string, unknown]) => {\n      const hashedKey = hashString(key);\n      const hashedValue = hashValue(value);\n\n      return [hashedKey, hashedValue] as [Uint8Array, Uint8Array];\n    });\n\n  const traversed: Array<[Uint8Array, Uint8Array]> = hashed;\n\n  const sorted: Array<[Uint8Array, Uint8Array]> = traversed.sort(([k1], [k2]) => {\n    return compare(k1, k2);\n  });\n\n  const concatenated = concatBytes(...sorted.map(x => concatBytes(...x)));\n  const result = sha256(concatenated);\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}