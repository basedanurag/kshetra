{"ast":null,"code":"import { SignIdentity } from '@dfinity/agent';\nimport { uint8FromBufLike } from '@dfinity/candid';\nexport class CryptoError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    Object.setPrototypeOf(this, CryptoError.prototype);\n  }\n}\n/**\n * Utility method to ensure that a subtleCrypto implementation is provided or is available in the global context\n * @param subtleCrypto SubtleCrypto implementation\n * @returns subleCrypto\n */\nfunction _getEffectiveCrypto(subtleCrypto) {\n  if (typeof global !== 'undefined' && global['crypto'] && global['crypto']['subtle']) {\n    return global['crypto']['subtle'];\n  }\n  if (subtleCrypto) {\n    return subtleCrypto;\n  } else if (typeof crypto !== 'undefined' && crypto['subtle']) {\n    return crypto.subtle;\n  } else {\n    throw new CryptoError('Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto');\n  }\n}\n/**\n * An identity interface that wraps an ECDSA keypair using the P-256 named curve. Supports DER-encoding and decoding for agent calls\n */\nexport class ECDSAKeyIdentity extends SignIdentity {\n  /**\n   * Generates a randomly generated identity for use in calls to the Internet Computer.\n   * @param {CryptoKeyOptions} options optional settings\n   * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.\n   * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for\n   * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface\n   * @returns a {@link ECDSAKeyIdentity}\n   */\n  static async generate(options) {\n    const {\n      extractable = false,\n      keyUsages = ['sign', 'verify'],\n      subtleCrypto\n    } = options ?? {};\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const keyPair = await effectiveCrypto.generateKey({\n      name: 'ECDSA',\n      namedCurve: 'P-256'\n    }, extractable, keyUsages);\n    const derKey = uint8FromBufLike(await effectiveCrypto.exportKey('spki', keyPair.publicKey));\n    Object.assign(derKey, {\n      __derEncodedPublicKey__: undefined\n    });\n    return new this(keyPair, derKey, effectiveCrypto);\n  }\n  /**\n   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n   * @param keyPair a CryptoKeyPair\n   * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally\n   * @returns an {@link ECDSAKeyIdentity}\n   */\n  static async fromKeyPair(keyPair, subtleCrypto) {\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const derKey = uint8FromBufLike(await effectiveCrypto.exportKey('spki', keyPair.publicKey));\n    Object.assign(derKey, {\n      __derEncodedPublicKey__: undefined\n    });\n    return new ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);\n  }\n  // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.\n  constructor(keyPair, derKey, subtleCrypto) {\n    super();\n    this._keyPair = keyPair;\n    this._derKey = derKey;\n    this._subtleCrypto = subtleCrypto;\n  }\n  /**\n   * Return the internally-used key pair.\n   * @returns a CryptoKeyPair\n   */\n  getKeyPair() {\n    return this._keyPair;\n  }\n  /**\n   * Return the public key.\n   * @returns an {@link PublicKey & DerCryptoKey}\n   */\n  getPublicKey() {\n    const derKey = this._derKey;\n    const key = Object.create(this._keyPair.publicKey);\n    key.toDer = function () {\n      return derKey;\n    };\n    return key;\n  }\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param {Uint8Array} challenge - challenge to sign with this identity's secretKey, producing a signature\n   * @returns {Promise<Signature>} signature\n   */\n  async sign(challenge) {\n    const params = {\n      name: 'ECDSA',\n      hash: {\n        name: 'SHA-256'\n      }\n    };\n    const signature = uint8FromBufLike(await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge));\n    Object.assign(signature, {\n      __signature__: undefined\n    });\n    return signature;\n  }\n}\nexport default ECDSAKeyIdentity;","map":{"version":3,"names":["SignIdentity","uint8FromBufLike","CryptoError","Error","constructor","message","Object","setPrototypeOf","prototype","_getEffectiveCrypto","subtleCrypto","global","crypto","subtle","ECDSAKeyIdentity","generate","options","extractable","keyUsages","effectiveCrypto","keyPair","generateKey","name","namedCurve","derKey","exportKey","publicKey","assign","__derEncodedPublicKey__","undefined","fromKeyPair","_keyPair","_derKey","_subtleCrypto","getKeyPair","getPublicKey","key","create","toDer","sign","challenge","params","hash","signature","privateKey","__signature__"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\identity\\src\\identity\\ecdsa.ts"],"sourcesContent":["import {\n  type DerEncodedPublicKey,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n} from '@dfinity/agent';\nimport { uint8FromBufLike } from '@dfinity/candid';\n\n/**\n * Options used in a {@link ECDSAKeyIdentity}\n */\nexport type CryptoKeyOptions = {\n  extractable?: boolean;\n  keyUsages?: KeyUsage[];\n  subtleCrypto?: SubtleCrypto;\n};\n\nexport class CryptoError extends Error {\n  constructor(public readonly message: string) {\n    super(message);\n    Object.setPrototypeOf(this, CryptoError.prototype);\n  }\n}\n\nexport interface DerCryptoKey extends CryptoKey {\n  toDer: () => DerEncodedPublicKey;\n}\n\n/**\n * Utility method to ensure that a subtleCrypto implementation is provided or is available in the global context\n * @param subtleCrypto SubtleCrypto implementation\n * @returns subleCrypto\n */\nfunction _getEffectiveCrypto(subtleCrypto: CryptoKeyOptions['subtleCrypto']): SubtleCrypto {\n  if (typeof global !== 'undefined' && global['crypto'] && global['crypto']['subtle']) {\n    return global['crypto']['subtle'];\n  }\n  if (subtleCrypto) {\n    return subtleCrypto;\n  } else if (typeof crypto !== 'undefined' && crypto['subtle']) {\n    return crypto.subtle;\n  } else {\n    throw new CryptoError(\n      'Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto',\n    );\n  }\n}\n\n/**\n * An identity interface that wraps an ECDSA keypair using the P-256 named curve. Supports DER-encoding and decoding for agent calls\n */\nexport class ECDSAKeyIdentity extends SignIdentity {\n  /**\n   * Generates a randomly generated identity for use in calls to the Internet Computer.\n   * @param {CryptoKeyOptions} options optional settings\n   * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.\n   * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for\n   * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface\n   * @returns a {@link ECDSAKeyIdentity}\n   */\n  public static async generate(options?: CryptoKeyOptions): Promise<ECDSAKeyIdentity> {\n    const { extractable = false, keyUsages = ['sign', 'verify'], subtleCrypto } = options ?? {};\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const keyPair = await effectiveCrypto.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n      },\n      extractable,\n      keyUsages,\n    );\n    const derKey: DerEncodedPublicKey = uint8FromBufLike(\n      await effectiveCrypto.exportKey('spki', keyPair.publicKey),\n    );\n\n    Object.assign(derKey, {\n      __derEncodedPublicKey__: undefined,\n    });\n\n    return new this(keyPair, derKey, effectiveCrypto);\n  }\n\n  /**\n   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n   * @param keyPair a CryptoKeyPair\n   * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally\n   * @returns an {@link ECDSAKeyIdentity}\n   */\n  public static async fromKeyPair(\n    keyPair: CryptoKeyPair | { privateKey: CryptoKey; publicKey: CryptoKey },\n    subtleCrypto?: SubtleCrypto,\n  ): Promise<ECDSAKeyIdentity> {\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const derKey: DerEncodedPublicKey = uint8FromBufLike(\n      await effectiveCrypto.exportKey('spki', keyPair.publicKey),\n    );\n    Object.assign(derKey, {\n      __derEncodedPublicKey__: undefined,\n    });\n    return new ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);\n  }\n\n  protected _derKey: DerEncodedPublicKey;\n  protected _keyPair: CryptoKeyPair;\n  protected _subtleCrypto: SubtleCrypto;\n\n  // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.\n  protected constructor(\n    keyPair: CryptoKeyPair,\n    derKey: DerEncodedPublicKey,\n    subtleCrypto: SubtleCrypto,\n  ) {\n    super();\n    this._keyPair = keyPair;\n    this._derKey = derKey;\n    this._subtleCrypto = subtleCrypto;\n  }\n\n  /**\n   * Return the internally-used key pair.\n   * @returns a CryptoKeyPair\n   */\n  public getKeyPair(): CryptoKeyPair {\n    return this._keyPair;\n  }\n\n  /**\n   * Return the public key.\n   * @returns an {@link PublicKey & DerCryptoKey}\n   */\n  public getPublicKey(): PublicKey & DerCryptoKey {\n    const derKey = this._derKey;\n    const key: DerCryptoKey = Object.create(this._keyPair.publicKey);\n    key.toDer = function () {\n      return derKey;\n    };\n\n    return key;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param {Uint8Array} challenge - challenge to sign with this identity's secretKey, producing a signature\n   * @returns {Promise<Signature>} signature\n   */\n  public async sign(challenge: Uint8Array): Promise<Signature> {\n    const params: EcdsaParams = {\n      name: 'ECDSA',\n      hash: { name: 'SHA-256' },\n    };\n    const signature = uint8FromBufLike(\n      await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge),\n    );\n\n    Object.assign(signature, {\n      __signature__: undefined,\n    });\n\n    return signature as Signature;\n  }\n}\n\nexport default ECDSAKeyIdentity;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}