{"ast":null,"code":"import { isV2ResponseBody, isV3ResponseBody, QueryResponseStatus } from \"./agent/index.js\";\nimport { CertifiedRejectErrorCode, ExternalError, InputError, MissingCanisterIdErrorCode, MissingRootKeyErrorCode, RejectError, UncertifiedRejectErrorCode, UnexpectedErrorCode, UnknownError } from \"./errors.js\";\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, DEFAULT_POLLING_OPTIONS } from \"./polling/index.js\";\nimport { Principal } from '@dfinity/principal';\nimport { Certificate, lookupResultToBuffer } from \"./certificate.js\";\nimport { HttpAgent } from \"./agent/http/index.js\";\nimport { utf8ToBytes } from '@noble/hashes/utils';\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  static agentOf(actor) {\n    return actor[metadataSymbol].config.agent;\n  }\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  static interfaceOf(actor) {\n    return actor[metadataSymbol].service;\n  }\n  static canisterIdOf(actor) {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n  static createActorClass(interfaceFactory, options) {\n    const service = interfaceFactory({\n      IDL\n    });\n    class CanisterActor extends Actor {\n      constructor(config) {\n        if (!config.canisterId) {\n          throw InputError.fromCode(new MissingCanisterIdErrorCode(config.canisterId));\n        }\n        const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId\n          },\n          service\n        });\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options?.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n    return CanisterActor;\n  }\n  static createActor(interfaceFactory, configuration) {\n    if (!configuration.canisterId) {\n      throw InputError.fromCode(new MissingCanisterIdErrorCode(configuration.canisterId));\n    }\n    return new (this.createActorClass(interfaceFactory))(configuration);\n  }\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  static createActorWithHttpDetails(interfaceFactory, configuration) {\n    return new (this.createActorClass(interfaceFactory, {\n      httpDetails: true\n    }))(configuration);\n  }\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  static createActorWithExtendedDetails(interfaceFactory, configuration, actorClassOptions = {\n    httpDetails: true,\n    certificate: true\n  }) {\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);\n  }\n  constructor(metadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n  const returnValues = IDL.decode(types, msg);\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingOptions: DEFAULT_POLLING_OPTIONS\n};\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\nfunction _createActorMethod(actor, methodName, func, blsVerify) {\n  let caller;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options\n        })\n      };\n      const agent = options.agent || actor[metadataSymbol].config.agent || new HttpAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId\n      });\n      const httpDetails = {\n        ...result.httpDetails,\n        requestDetails: result.requestDetails\n      };\n      switch (result.status) {\n        case QueryResponseStatus.Rejected:\n          {\n            const uncertifiedRejectErrorCode = new UncertifiedRejectErrorCode(result.requestId, result.reject_code, result.reject_message, result.error_code, result.signatures);\n            uncertifiedRejectErrorCode.callContext = {\n              canisterId: cid,\n              methodName,\n              httpDetails\n            };\n            throw RejectError.fromCode(uncertifiedRejectErrorCode);\n          }\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, result.reply.arg)\n          } : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options\n        })\n      };\n      const agent = options.agent || actor[metadataSymbol].config.agent || HttpAgent.createSync();\n      const {\n        canisterId,\n        effectiveCanisterId,\n        pollingOptions\n      } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n      const {\n        requestId,\n        response,\n        requestDetails\n      } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n        nonce: options.nonce\n      });\n      let reply;\n      let certificate;\n      if (isV3ResponseBody(response.body)) {\n        if (agent.rootKey == null) {\n          throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n        }\n        const cert = response.body.certificate;\n        certificate = await Certificate.create({\n          certificate: cert,\n          rootKey: agent.rootKey,\n          canisterId: Principal.from(canisterId),\n          blsVerify\n        });\n        const path = [utf8ToBytes('request_status'), requestId];\n        const status = new TextDecoder().decode(lookupResultToBuffer(certificate.lookup_path([...path, 'status'])));\n        switch (status) {\n          case 'replied':\n            reply = lookupResultToBuffer(certificate.lookup_path([...path, 'reply']));\n            break;\n          case 'rejected':\n            {\n              // Find rejection details in the certificate\n              const rejectCode = new Uint8Array(lookupResultToBuffer(certificate.lookup_path([...path, 'reject_code'])))[0];\n              const rejectMessage = new TextDecoder().decode(lookupResultToBuffer(certificate.lookup_path([...path, 'reject_message'])));\n              const error_code_buf = lookupResultToBuffer(certificate.lookup_path([...path, 'error_code']));\n              const error_code = error_code_buf ? new TextDecoder().decode(error_code_buf) : undefined;\n              const certifiedRejectErrorCode = new CertifiedRejectErrorCode(requestId, rejectCode, rejectMessage, error_code);\n              certifiedRejectErrorCode.callContext = {\n                canisterId: cid,\n                methodName,\n                httpDetails: response\n              };\n              throw RejectError.fromCode(certifiedRejectErrorCode);\n            }\n        }\n      } else if (isV2ResponseBody(response.body)) {\n        // handle v2 response errors by throwing an UpdateCallRejectedError object\n        const {\n          reject_code,\n          reject_message,\n          error_code\n        } = response.body;\n        const certifiedRejectErrorCode = new CertifiedRejectErrorCode(requestId, reject_code, reject_message, error_code);\n        certifiedRejectErrorCode.callContext = {\n          canisterId: cid,\n          methodName,\n          httpDetails: response\n        };\n        throw RejectError.fromCode(certifiedRejectErrorCode);\n      }\n      // Fall back to polling if we receive an Accepted response code\n      if (response.status === 202) {\n        const pollOptions = {\n          ...pollingOptions,\n          blsVerify\n        };\n        // Contains the certificate and the reply from the boundary node\n        const response = await pollForResponse(agent, ecid, requestId, pollOptions);\n        certificate = response.certificate;\n        reply = response.reply;\n      }\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n      const httpDetails = {\n        ...response,\n        requestDetails\n      };\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails ? {\n          httpDetails: response,\n          result: undefined\n        } : undefined;\n      } else {\n        throw UnknownError.fromCode(new UnexpectedErrorCode(`Call was returned undefined, but type [${func.retTypes.map(t => t.display()).join(',')}].`));\n      }\n    };\n  }\n  const handler = (...args) => caller({}, ...args);\n  handler.withOptions = options => (...args) => caller(options, ...args);\n  return handler;\n}","map":{"version":3,"names":["isV2ResponseBody","isV3ResponseBody","QueryResponseStatus","CertifiedRejectErrorCode","ExternalError","InputError","MissingCanisterIdErrorCode","MissingRootKeyErrorCode","RejectError","UncertifiedRejectErrorCode","UnexpectedErrorCode","UnknownError","IDL","pollForResponse","DEFAULT_POLLING_OPTIONS","Principal","Certificate","lookupResultToBuffer","HttpAgent","utf8ToBytes","metadataSymbol","Symbol","for","Actor","agentOf","actor","config","agent","interfaceOf","service","canisterIdOf","from","canisterId","createActorClass","interfaceFactory","options","CanisterActor","constructor","fromCode","fromText","DEFAULT_ACTOR_CONFIG","methodName","func","_fields","httpDetails","annotations","push","ACTOR_METHOD_WITH_HTTP_DETAILS","certificate","ACTOR_METHOD_WITH_CERTIFICATE","_createActorMethod","blsVerify","createActor","configuration","createActorWithHttpDetails","createActorWithExtendedDetails","actorClassOptions","metadata","Object","freeze","decodeReturnValue","types","msg","returnValues","decode","length","undefined","pollingOptions","caller","includes","args","queryTransform","cid","arg","encode","argTypes","result","query","effectiveCanisterId","requestDetails","status","Rejected","uncertifiedRejectErrorCode","requestId","reject_code","reject_message","error_code","signatures","callContext","Replied","retTypes","reply","callTransform","createSync","ecid","response","call","nonce","body","rootKey","cert","create","path","TextDecoder","lookup_path","rejectCode","Uint8Array","rejectMessage","error_code_buf","certifiedRejectErrorCode","pollOptions","shouldIncludeHttpDetails","shouldIncludeCertificate","map","t","display","join","handler","withOptions"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\actor.ts"],"sourcesContent":["import {\n  type Agent,\n  type HttpDetailsResponse,\n  isV2ResponseBody,\n  isV3ResponseBody,\n  QueryResponseStatus,\n} from './agent/index.ts';\nimport {\n  CertifiedRejectErrorCode,\n  ExternalError,\n  InputError,\n  MissingCanisterIdErrorCode,\n  MissingRootKeyErrorCode,\n  RejectError,\n  UncertifiedRejectErrorCode,\n  UnexpectedErrorCode,\n  UnknownError,\n} from './errors.ts';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, type PollingOptions, DEFAULT_POLLING_OPTIONS } from './polling/index.ts';\nimport { Principal } from '@dfinity/principal';\nimport { Certificate, type CreateCertificateOptions, lookupResultToBuffer } from './certificate.ts';\nimport { HttpAgent } from './agent/http/index.ts';\nimport { utf8ToBytes } from '@noble/hashes/utils';\n\n/**\n * Configuration to make calls to the Replica.\n */\nexport interface CallConfig {\n  /**\n   * An agent to use in this call, otherwise the actor or call will try to discover the\n   * agent to use.\n   */\n  agent?: Agent;\n\n  /**\n   * Options for controlling polling behavior.\n   */\n  pollingOptions?: PollingOptions;\n\n  /**\n   * The canister ID of this Actor.\n   */\n  canisterId?: string | Principal;\n\n  /**\n   * The effective canister ID. This should almost always be ignored.\n   */\n  effectiveCanisterId?: Principal;\n\n  /**\n   * The nonce to use for this call. This is used to prevent replay attacks.\n   */\n  nonce?: Uint8Array;\n}\n\n/**\n * Configuration that can be passed to customize the Actor behaviour.\n */\nexport interface ActorConfig extends CallConfig {\n  /**\n   * The Canister ID of this Actor. This is required for an Actor.\n   */\n  canisterId: string | Principal;\n\n  /**\n   * An override function for update calls' CallConfig. This will be called on every calls.\n   */\n  callTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * An override function for query calls' CallConfig. This will be called on every query.\n   */\n  queryTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * Polyfill for BLS Certificate verification in case wasm is not supported\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n\n  /**\n   * Polling options to use when making update calls. This will override the default DEFAULT_POLLING_OPTIONS.\n   */\n  pollingOptions?: PollingOptions;\n}\n\n// TODO: move this to proper typing when Candid support TypeScript.\n/**\n * A subclass of an actor. Actor class itself is meant to be a based class.\n */\nexport type ActorSubclass<T = Record<string, ActorMethod>> = Actor & T;\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethod<Args extends unknown[] = unknown[], Ret = unknown> {\n  (...args: Args): Promise<Ret>;\n\n  withOptions(options: CallConfig): (...args: Args) => Promise<Ret>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodWithHttpDetails<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{ httpDetails: HttpDetailsResponse; result: Ret }>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodExtended<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{\n    certificate?: Certificate;\n    httpDetails?: HttpDetailsResponse;\n    result: Ret;\n  }>;\n}\n\nexport type FunctionWithArgsAndReturn<Args extends unknown[] = unknown[], Ret = unknown> = (\n  ...args: Args\n) => Ret;\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedWithHttpDetails<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodWithHttpDetails<Args, Ret>\n    : never;\n};\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedExtended<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodExtended<Args, Ret>\n    : never;\n};\n\n/**\n * The mode used when installing a canister.\n */\nexport type CanisterInstallMode =\n  | {\n      reinstall: null;\n    }\n  | {\n      upgrade:\n        | []\n        | [\n            {\n              skip_pre_upgrade: [] | [boolean];\n            },\n          ];\n    }\n  | {\n      install: null;\n    };\n\n/**\n * Internal metadata for actors. It's an enhanced version of ActorConfig with\n * some fields marked as required (as they are defaulted) and canisterId as\n * a Principal type.\n */\ninterface ActorMetadata {\n  service: IDL.ServiceClass;\n  agent?: Agent;\n  config: ActorConfig;\n}\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n\nexport interface CreateActorClassOpts {\n  httpDetails?: boolean;\n  certificate?: boolean;\n}\n\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  public static agentOf(actor: Actor): Agent | undefined {\n    return actor[metadataSymbol].config.agent;\n  }\n\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  public static interfaceOf(actor: Actor): IDL.ServiceClass {\n    return actor[metadataSymbol].service;\n  }\n\n  public static canisterIdOf(actor: Actor): Principal {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  public static createActorClass(\n    interfaceFactory: IDL.InterfaceFactory,\n    options?: CreateActorClassOpts,\n  ): ActorConstructor {\n    const service = interfaceFactory({ IDL });\n\n    class CanisterActor extends Actor {\n      [x: string]: ActorMethod;\n\n      constructor(config: ActorConfig) {\n        if (!config.canisterId) {\n          throw InputError.fromCode(new MissingCanisterIdErrorCode(config.canisterId));\n        }\n        const canisterId =\n          typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId,\n          },\n          service,\n        });\n\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options?.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n\n    return CanisterActor;\n  }\n\n  public static createActor<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<T> {\n    if (!configuration.canisterId) {\n      throw InputError.fromCode(new MissingCanisterIdErrorCode(configuration.canisterId));\n    }\n    return new (this.createActorClass(interfaceFactory))(\n      configuration,\n    ) as unknown as ActorSubclass<T>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  public static createActorWithHttpDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<ActorMethodMappedWithHttpDetails<T>> {\n    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedWithHttpDetails<T>>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  public static createActorWithExtendedDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n    actorClassOptions: CreateActorClassOpts = {\n      httpDetails: true,\n      certificate: true,\n    },\n  ): ActorSubclass<ActorMethodMappedExtended<T>> {\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedExtended<T>>;\n  }\n\n  private [metadataSymbol]: ActorMetadata;\n\n  protected constructor(metadata: ActorMetadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types: IDL.Type[], msg: Uint8Array) {\n  const returnValues = IDL.decode(types, msg);\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG: Partial<ActorConfig> = {\n  pollingOptions: DEFAULT_POLLING_OPTIONS,\n};\n\nexport type ActorConstructor = new (config: ActorConfig) => ActorSubclass;\n\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\n\nfunction _createActorMethod(\n  actor: Actor,\n  methodName: string,\n  func: IDL.FuncClass,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): ActorMethod {\n  let caller: (options: CallConfig, ...args: unknown[]) => Promise<unknown>;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || new HttpAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId,\n      });\n      const httpDetails = {\n        ...result.httpDetails,\n        requestDetails: result.requestDetails,\n      } as HttpDetailsResponse;\n\n      switch (result.status) {\n        case QueryResponseStatus.Rejected: {\n          const uncertifiedRejectErrorCode = new UncertifiedRejectErrorCode(\n            result.requestId,\n            result.reject_code,\n            result.reject_message,\n            result.error_code,\n            result.signatures,\n          );\n          uncertifiedRejectErrorCode.callContext = {\n            canisterId: cid,\n            methodName,\n            httpDetails,\n          };\n          throw RejectError.fromCode(uncertifiedRejectErrorCode);\n        }\n\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n            ? {\n                httpDetails,\n                result: decodeReturnValue(func.retTypes, result.reply.arg),\n              }\n            : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || HttpAgent.createSync();\n\n      const { canisterId, effectiveCanisterId, pollingOptions } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options,\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n\n      const { requestId, response, requestDetails } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n        nonce: options.nonce,\n      });\n      let reply: Uint8Array | undefined;\n      let certificate: Certificate | undefined;\n      if (isV3ResponseBody(response.body)) {\n        if (agent.rootKey == null) {\n          throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n        }\n        const cert = response.body.certificate;\n        certificate = await Certificate.create({\n          certificate: cert,\n          rootKey: agent.rootKey,\n          canisterId: Principal.from(canisterId),\n          blsVerify,\n        });\n        const path = [utf8ToBytes('request_status'), requestId];\n        const status = new TextDecoder().decode(\n          lookupResultToBuffer(certificate.lookup_path([...path, 'status'])),\n        );\n\n        switch (status) {\n          case 'replied':\n            reply = lookupResultToBuffer(certificate.lookup_path([...path, 'reply']));\n            break;\n          case 'rejected': {\n            // Find rejection details in the certificate\n            const rejectCode = new Uint8Array(\n              lookupResultToBuffer(certificate.lookup_path([...path, 'reject_code']))!,\n            )[0];\n            const rejectMessage = new TextDecoder().decode(\n              lookupResultToBuffer(certificate.lookup_path([...path, 'reject_message']))!,\n            );\n\n            const error_code_buf = lookupResultToBuffer(\n              certificate.lookup_path([...path, 'error_code']),\n            );\n            const error_code = error_code_buf\n              ? new TextDecoder().decode(error_code_buf)\n              : undefined;\n\n            const certifiedRejectErrorCode = new CertifiedRejectErrorCode(\n              requestId,\n              rejectCode,\n              rejectMessage,\n              error_code,\n            );\n            certifiedRejectErrorCode.callContext = {\n              canisterId: cid,\n              methodName,\n              httpDetails: response,\n            };\n            throw RejectError.fromCode(certifiedRejectErrorCode);\n          }\n        }\n      } else if (isV2ResponseBody(response.body)) {\n        // handle v2 response errors by throwing an UpdateCallRejectedError object\n        const { reject_code, reject_message, error_code } = response.body;\n        const certifiedRejectErrorCode = new CertifiedRejectErrorCode(\n          requestId,\n          reject_code,\n          reject_message,\n          error_code,\n        );\n        certifiedRejectErrorCode.callContext = {\n          canisterId: cid,\n          methodName,\n          httpDetails: response,\n        };\n        throw RejectError.fromCode(certifiedRejectErrorCode);\n      }\n\n      // Fall back to polling if we receive an Accepted response code\n      if (response.status === 202) {\n        const pollOptions: PollingOptions = {\n          ...pollingOptions,\n          blsVerify,\n        };\n        // Contains the certificate and the reply from the boundary node\n        const response = await pollForResponse(agent, ecid, requestId, pollOptions);\n        certificate = response.certificate;\n        reply = response.reply;\n      }\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n\n      const httpDetails = { ...response, requestDetails } as HttpDetailsResponse;\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: undefined,\n            }\n          : undefined;\n      } else {\n        throw UnknownError.fromCode(\n          new UnexpectedErrorCode(\n            `Call was returned undefined, but type [${func.retTypes.map(t => t.display()).join(',')}].`,\n          ),\n        );\n      }\n    };\n  }\n\n  const handler = (...args: unknown[]) => caller({}, ...args);\n  handler.withOptions =\n    (options: CallConfig) =>\n    (...args: unknown[]) =>\n      caller(options, ...args);\n  return handler as ActorMethod;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}