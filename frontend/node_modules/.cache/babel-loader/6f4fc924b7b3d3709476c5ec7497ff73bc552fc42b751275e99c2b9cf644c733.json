{"ast":null,"code":"import { Principal } from '@dfinity/principal';\nimport { CertificateVerificationErrorCode, MissingRootKeyErrorCode, CertificateNotAuthorizedErrorCode, LookupErrorCode, DerKeyLengthMismatchErrorCode, ExternalError, ProtocolError, TrustError, AgentError, UnknownError, HashTreeDecodeErrorCode, UnexpectedErrorCode, InputError } from \"../errors.js\";\nimport { Certificate, flatten_forks, check_canister_ranges, LookupPathStatus, lookup_path, lookupResultToBuffer, lookup_subtree, LookupSubtreeStatus } from \"../certificate.js\";\nimport * as cbor from \"../cbor.js\";\nimport { decodeLeb128, decodeTime } from \"../utils/leb.js\";\nimport { utf8ToBytes, bytesToHex } from '@noble/hashes/utils';\n/**\n * Interface to define a custom path. Nested paths will be represented as individual buffers, and can be created from text using TextEncoder.\n * @param {string} key the key to use to access the returned value in the canisterStatus map\n * @param {Uint8Array[]} path the path to the desired value, represented as an array of buffers\n * @param {string} decodeStrategy the strategy to use to decode the returned value\n */\nexport class CustomPath {\n  constructor(key, path, decodeStrategy) {\n    this.key = key;\n    this.path = path;\n    this.decodeStrategy = decodeStrategy;\n  }\n}\n/**\n * Request information in the request_status state tree for a given canister.\n * Can be used to request information about the canister's controllers, time, module hash, candid interface, and more.\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nexport const request = async options => {\n  const {\n    agent,\n    paths\n  } = options;\n  const canisterId = Principal.from(options.canisterId);\n  const uniquePaths = [...new Set(paths)];\n  const status = new Map();\n  const promises = uniquePaths.map((path, index) => {\n    const encodedPath = encodePath(path, canisterId);\n    return (async () => {\n      try {\n        const response = await agent.readState(canisterId, {\n          paths: [encodedPath]\n        });\n        if (agent.rootKey == null) {\n          throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n        }\n        const cert = await Certificate.create({\n          certificate: response.certificate,\n          rootKey: agent.rootKey,\n          canisterId: canisterId,\n          disableTimeVerification: true\n        });\n        const lookup = (cert, path) => {\n          if (path === 'subnet') {\n            if (agent.rootKey == null) {\n              throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n            }\n            const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);\n            return {\n              path,\n              data\n            };\n          } else {\n            return {\n              path,\n              data: lookupResultToBuffer(cert.lookup_path(encodedPath))\n            };\n          }\n        };\n        // must pass in the rootKey if we have no delegation\n        const {\n          path,\n          data\n        } = lookup(cert, uniquePaths[index]);\n        if (!data) {\n          // Typically, the cert lookup will throw\n          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n          if (typeof path === 'string') {\n            status.set(path, null);\n          } else {\n            status.set(path.key, null);\n          }\n        } else {\n          switch (path) {\n            case 'time':\n              {\n                status.set(path, decodeTime(data));\n                break;\n              }\n            case 'controllers':\n              {\n                status.set(path, decodeControllers(data));\n                break;\n              }\n            case 'module_hash':\n              {\n                status.set(path, bytesToHex(data));\n                break;\n              }\n            case 'subnet':\n              {\n                status.set(path, data);\n                break;\n              }\n            case 'candid':\n              {\n                status.set(path, new TextDecoder().decode(data));\n                break;\n              }\n            default:\n              {\n                // Check for CustomPath signature\n                if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                  switch (path.decodeStrategy) {\n                    case 'raw':\n                      status.set(path.key, data);\n                      break;\n                    case 'leb128':\n                      {\n                        status.set(path.key, decodeLeb128(data));\n                        break;\n                      }\n                    case 'cbor':\n                      {\n                        status.set(path.key, cbor.decode(data));\n                        break;\n                      }\n                    case 'hex':\n                      {\n                        status.set(path.key, bytesToHex(data));\n                        break;\n                      }\n                    case 'utf-8':\n                      {\n                        status.set(path.key, new TextDecoder().decode(data));\n                      }\n                  }\n                }\n              }\n          }\n        }\n      } catch (error) {\n        // Break on signature verification errors\n        if (error instanceof AgentError && error.hasCode(CertificateVerificationErrorCode)) {\n          throw error;\n        }\n        if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n          status.set(path.key, null);\n        } else {\n          status.set(path, null);\n        }\n        console.group();\n        console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n        console.warn(error);\n        console.groupEnd();\n      }\n    })();\n  });\n  // Fetch all values separately, as each option can fail\n  await Promise.all(promises);\n  return status;\n};\nexport const fetchNodeKeys = (certificate, canisterId, root_key) => {\n  if (!canisterId._isPrincipal) {\n    throw InputError.fromCode(new UnexpectedErrorCode('Invalid canisterId'));\n  }\n  const cert = cbor.decode(certificate);\n  const tree = cert.tree;\n  let delegation = cert.delegation;\n  let subnetId;\n  if (delegation && delegation.subnet_id) {\n    subnetId = Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));\n  }\n  // On local replica, with System type subnet, there is no delegation\n  else if (!delegation && typeof root_key !== 'undefined') {\n    subnetId = Principal.selfAuthenticating(new Uint8Array(root_key));\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new Uint8Array(0)\n    };\n  }\n  // otherwise use default NNS subnet id\n  else {\n    subnetId = Principal.selfAuthenticating(Principal.fromText('tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe').toUint8Array());\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new Uint8Array(0)\n    };\n  }\n  const canisterInRange = check_canister_ranges({\n    canisterId,\n    subnetId,\n    tree\n  });\n  if (!canisterInRange) {\n    throw TrustError.fromCode(new CertificateNotAuthorizedErrorCode(canisterId, delegation.subnet_id));\n  }\n  const subnetLookupResult = lookup_subtree(['subnet', delegation.subnet_id, 'node'], tree);\n  if (subnetLookupResult.status !== LookupSubtreeStatus.Found) {\n    throw ProtocolError.fromCode(new LookupErrorCode('Node not found', subnetLookupResult.status));\n  }\n  if (subnetLookupResult.value instanceof Uint8Array) {\n    throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid node tree'));\n  }\n  // The forks are all labeled trees with the <node_id> label\n  const nodeForks = flatten_forks(subnetLookupResult.value);\n  const nodeKeys = new Map();\n  nodeForks.forEach(fork => {\n    const node_id = Principal.from(fork[1]).toText();\n    const publicKeyLookupResult = lookup_path(['public_key'], fork[2]);\n    if (publicKeyLookupResult.status !== LookupPathStatus.Found) {\n      throw ProtocolError.fromCode(new LookupErrorCode('Public key not found', publicKeyLookupResult.status));\n    }\n    const derEncodedPublicKey = publicKeyLookupResult.value;\n    if (derEncodedPublicKey.byteLength !== 44) {\n      throw ProtocolError.fromCode(new DerKeyLengthMismatchErrorCode(44, derEncodedPublicKey.byteLength));\n    } else {\n      nodeKeys.set(node_id, derEncodedPublicKey);\n    }\n  });\n  return {\n    subnetId: Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),\n    nodeKeys\n  };\n};\nexport const encodePath = (path, canisterId) => {\n  const canisterUint8Array = canisterId.toUint8Array();\n  switch (path) {\n    case 'time':\n      return [utf8ToBytes('time')];\n    case 'controllers':\n      return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('controllers')];\n    case 'module_hash':\n      return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('module_hash')];\n    case 'subnet':\n      return [utf8ToBytes('subnet')];\n    case 'candid':\n      return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('metadata'), utf8ToBytes('candid:service')];\n    default:\n      {\n        // Check for CustomPath signature\n        if ('key' in path && 'path' in path) {\n          // For simplified metadata queries\n          if (typeof path['path'] === 'string' || path['path'] instanceof Uint8Array) {\n            const metaPath = path.path;\n            const encoded = typeof metaPath === 'string' ? utf8ToBytes(metaPath) : metaPath;\n            return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('metadata'), encoded];\n            // For non-metadata, return the provided custompath\n          } else {\n            return path['path'];\n          }\n        }\n      }\n  }\n  throw UnknownError.fromCode(new UnexpectedErrorCode(`Error while encoding your path for canister status. Please ensure that your path ${path} was formatted correctly.`));\n};\n// Controllers are CBOR-encoded buffers\nconst decodeControllers = buf => {\n  const controllersRaw = cbor.decode(buf);\n  return controllersRaw.map(buf => {\n    return Principal.fromUint8Array(buf);\n  });\n};","map":{"version":3,"names":["Principal","CertificateVerificationErrorCode","MissingRootKeyErrorCode","CertificateNotAuthorizedErrorCode","LookupErrorCode","DerKeyLengthMismatchErrorCode","ExternalError","ProtocolError","TrustError","AgentError","UnknownError","HashTreeDecodeErrorCode","UnexpectedErrorCode","InputError","Certificate","flatten_forks","check_canister_ranges","LookupPathStatus","lookup_path","lookupResultToBuffer","lookup_subtree","LookupSubtreeStatus","cbor","decodeLeb128","decodeTime","utf8ToBytes","bytesToHex","CustomPath","constructor","key","path","decodeStrategy","request","options","agent","paths","canisterId","from","uniquePaths","Set","status","Map","promises","map","index","encodedPath","encodePath","response","readState","rootKey","fromCode","cert","create","certificate","disableTimeVerification","lookup","data","fetchNodeKeys","console","warn","set","decodeControllers","TextDecoder","decode","error","hasCode","group","groupEnd","Promise","all","root_key","_isPrincipal","tree","delegation","subnetId","subnet_id","fromUint8Array","Uint8Array","selfAuthenticating","toUint8Array","fromText","canisterInRange","subnetLookupResult","Found","value","nodeForks","nodeKeys","forEach","fork","node_id","toText","publicKeyLookupResult","derEncodedPublicKey","byteLength","canisterUint8Array","metaPath","encoded","buf","controllersRaw"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\canisterStatus\\index.ts"],"sourcesContent":["import { Principal } from '@dfinity/principal';\nimport {\n  CertificateVerificationErrorCode,\n  MissingRootKeyErrorCode,\n  CertificateNotAuthorizedErrorCode,\n  LookupErrorCode,\n  DerKeyLengthMismatchErrorCode,\n  ExternalError,\n  ProtocolError,\n  TrustError,\n  AgentError,\n  UnknownError,\n  HashTreeDecodeErrorCode,\n  UnexpectedErrorCode,\n  InputError,\n} from '../errors.ts';\nimport { HttpAgent } from '../agent/http/index.ts';\nimport {\n  type Cert,\n  Certificate,\n  type CreateCertificateOptions,\n  flatten_forks,\n  check_canister_ranges,\n  LookupPathStatus,\n  lookup_path,\n  lookupResultToBuffer,\n  lookup_subtree,\n  type LabeledHashTree,\n  LookupSubtreeStatus,\n} from '../certificate.ts';\nimport * as cbor from '../cbor.ts';\nimport { decodeLeb128, decodeTime } from '../utils/leb.ts';\nimport { type DerEncodedPublicKey } from '../auth.ts';\nimport { utf8ToBytes, bytesToHex } from '@noble/hashes/utils';\n\n/**\n * Represents the useful information about a subnet\n * @param {string} subnetId the principal id of the canister's subnet\n * @param {string[]} nodeKeys the keys of the individual nodes in the subnet\n */\nexport type SubnetStatus = {\n  // Principal as a string\n  subnetId: string;\n  nodeKeys: Map<string, DerEncodedPublicKey>;\n  metrics?: {\n    num_canisters: bigint;\n    canister_state_bytes: bigint;\n    consumed_cycles_total: {\n      current: bigint;\n      deleted: bigint;\n    };\n    update_transactions_total: bigint;\n  };\n};\n\n/**\n * Types of an entry on the canisterStatus map.\n * An entry of null indicates that the request failed, due to lack of permissions or the result being missing.\n */\nexport type Status =\n  | string\n  | Uint8Array\n  | Date\n  | Uint8Array[]\n  | Principal[]\n  | SubnetStatus\n  | bigint\n  | null;\n\n/**\n * Interface to define a custom path. Nested paths will be represented as individual buffers, and can be created from text using TextEncoder.\n * @param {string} key the key to use to access the returned value in the canisterStatus map\n * @param {Uint8Array[]} path the path to the desired value, represented as an array of buffers\n * @param {string} decodeStrategy the strategy to use to decode the returned value\n */\nexport class CustomPath implements CustomPath {\n  public key: string;\n  public path: Uint8Array[] | string;\n  public decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw';\n  constructor(\n    key: string,\n    path: Uint8Array[] | string,\n    decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw',\n  ) {\n    this.key = key;\n    this.path = path;\n    this.decodeStrategy = decodeStrategy;\n  }\n}\n\n/**\n * @deprecated Use {@link CustomPath} instead\n * @param {string} key the key to use to access the returned value in the canisterStatus map\n * @param {string} path the path to the desired value, represented as a string\n * @param {string} decodeStrategy the strategy to use to decode the returned value\n */\nexport interface MetaData {\n  kind: 'metadata';\n  key: string;\n  path: string | Uint8Array;\n  decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw';\n}\n\n/**\n * Pre-configured fields for canister status paths\n */\nexport type Path =\n  | 'time'\n  | 'controllers'\n  | 'subnet'\n  | 'module_hash'\n  | 'candid'\n  | MetaData\n  | CustomPath;\n\nexport type StatusMap = Map<Path | string, Status>;\n\nexport type CanisterStatusOptions = {\n  canisterId: Principal;\n  agent: HttpAgent;\n  paths?: Path[] | Set<Path>;\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n};\n\n/**\n * Request information in the request_status state tree for a given canister.\n * Can be used to request information about the canister's controllers, time, module hash, candid interface, and more.\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nexport const request = async (options: {\n  canisterId: Principal;\n  agent: HttpAgent;\n  paths?: Path[] | Set<Path>;\n}): Promise<StatusMap> => {\n  const { agent, paths } = options;\n  const canisterId = Principal.from(options.canisterId);\n\n  const uniquePaths = [...new Set(paths)];\n  const status = new Map<string | Path, Status>();\n\n  const promises = uniquePaths.map((path, index) => {\n    const encodedPath = encodePath(path, canisterId);\n\n    return (async () => {\n      try {\n        const response = await agent.readState(canisterId, {\n          paths: [encodedPath],\n        });\n        if (agent.rootKey == null) {\n          throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n        }\n\n        const cert = await Certificate.create({\n          certificate: response.certificate,\n          rootKey: agent.rootKey,\n          canisterId: canisterId,\n          disableTimeVerification: true,\n        });\n\n        const lookup = (cert: Certificate, path: Path) => {\n          if (path === 'subnet') {\n            if (agent.rootKey == null) {\n              throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n            }\n            const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);\n            return {\n              path,\n              data,\n            };\n          } else {\n            return {\n              path,\n              data: lookupResultToBuffer(cert.lookup_path(encodedPath)),\n            };\n          }\n        };\n\n        // must pass in the rootKey if we have no delegation\n        const { path, data } = lookup(cert, uniquePaths[index]);\n        if (!data) {\n          // Typically, the cert lookup will throw\n          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n          if (typeof path === 'string') {\n            status.set(path, null);\n          } else {\n            status.set(path.key, null);\n          }\n        } else {\n          switch (path) {\n            case 'time': {\n              status.set(path, decodeTime(data));\n              break;\n            }\n            case 'controllers': {\n              status.set(path, decodeControllers(data));\n              break;\n            }\n            case 'module_hash': {\n              status.set(path, bytesToHex(data));\n              break;\n            }\n            case 'subnet': {\n              status.set(path, data);\n              break;\n            }\n            case 'candid': {\n              status.set(path, new TextDecoder().decode(data));\n              break;\n            }\n            default: {\n              // Check for CustomPath signature\n              if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                switch (path.decodeStrategy) {\n                  case 'raw':\n                    status.set(path.key, data);\n                    break;\n                  case 'leb128': {\n                    status.set(path.key, decodeLeb128(data));\n                    break;\n                  }\n                  case 'cbor': {\n                    status.set(path.key, cbor.decode(data));\n                    break;\n                  }\n                  case 'hex': {\n                    status.set(path.key, bytesToHex(data));\n                    break;\n                  }\n                  case 'utf-8': {\n                    status.set(path.key, new TextDecoder().decode(data));\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (error) {\n        // Break on signature verification errors\n        if (error instanceof AgentError && error.hasCode(CertificateVerificationErrorCode)) {\n          throw error;\n        }\n        if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n          status.set(path.key, null);\n        } else {\n          status.set(path, null);\n        }\n        console.group();\n        console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n        console.warn(error);\n        console.groupEnd();\n      }\n    })();\n  });\n\n  // Fetch all values separately, as each option can fail\n  await Promise.all(promises);\n\n  return status;\n};\n\nexport const fetchNodeKeys = (\n  certificate: Uint8Array,\n  canisterId: Principal,\n  root_key?: Uint8Array,\n): SubnetStatus => {\n  if (!canisterId._isPrincipal) {\n    throw InputError.fromCode(new UnexpectedErrorCode('Invalid canisterId'));\n  }\n  const cert = cbor.decode<Cert>(certificate);\n  const tree = cert.tree;\n  let delegation = cert.delegation;\n  let subnetId: Principal;\n  if (delegation && delegation.subnet_id) {\n    subnetId = Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));\n  }\n\n  // On local replica, with System type subnet, there is no delegation\n  else if (!delegation && typeof root_key !== 'undefined') {\n    subnetId = Principal.selfAuthenticating(new Uint8Array(root_key));\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new Uint8Array(0),\n    };\n  }\n  // otherwise use default NNS subnet id\n  else {\n    subnetId = Principal.selfAuthenticating(\n      Principal.fromText(\n        'tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe',\n      ).toUint8Array(),\n    );\n    delegation = {\n      subnet_id: subnetId.toUint8Array(),\n      certificate: new Uint8Array(0),\n    };\n  }\n\n  const canisterInRange = check_canister_ranges({ canisterId, subnetId, tree });\n  if (!canisterInRange) {\n    throw TrustError.fromCode(\n      new CertificateNotAuthorizedErrorCode(canisterId, delegation.subnet_id),\n    );\n  }\n\n  const subnetLookupResult = lookup_subtree(['subnet', delegation.subnet_id, 'node'], tree);\n  if (subnetLookupResult.status !== LookupSubtreeStatus.Found) {\n    throw ProtocolError.fromCode(new LookupErrorCode('Node not found', subnetLookupResult.status));\n  }\n  if (subnetLookupResult.value instanceof Uint8Array) {\n    throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid node tree'));\n  }\n\n  // The forks are all labeled trees with the <node_id> label\n  const nodeForks = flatten_forks(subnetLookupResult.value) as Array<LabeledHashTree>;\n  const nodeKeys = new Map<string, DerEncodedPublicKey>();\n\n  nodeForks.forEach(fork => {\n    const node_id = Principal.from(fork[1]).toText();\n    const publicKeyLookupResult = lookup_path(['public_key'], fork[2]);\n    if (publicKeyLookupResult.status !== LookupPathStatus.Found) {\n      throw ProtocolError.fromCode(\n        new LookupErrorCode('Public key not found', publicKeyLookupResult.status),\n      );\n    }\n\n    const derEncodedPublicKey = publicKeyLookupResult.value;\n    if (derEncodedPublicKey.byteLength !== 44) {\n      throw ProtocolError.fromCode(\n        new DerKeyLengthMismatchErrorCode(44, derEncodedPublicKey.byteLength),\n      );\n    } else {\n      nodeKeys.set(node_id, derEncodedPublicKey as DerEncodedPublicKey);\n    }\n  });\n\n  return {\n    subnetId: Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),\n    nodeKeys,\n  };\n};\n\nexport const encodePath = (path: Path, canisterId: Principal): Uint8Array[] => {\n  const canisterUint8Array = canisterId.toUint8Array();\n  switch (path) {\n    case 'time':\n      return [utf8ToBytes('time')];\n    case 'controllers':\n      return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('controllers')];\n    case 'module_hash':\n      return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('module_hash')];\n    case 'subnet':\n      return [utf8ToBytes('subnet')];\n    case 'candid':\n      return [\n        utf8ToBytes('canister'),\n        canisterUint8Array,\n        utf8ToBytes('metadata'),\n        utf8ToBytes('candid:service'),\n      ];\n    default: {\n      // Check for CustomPath signature\n      if ('key' in path && 'path' in path) {\n        // For simplified metadata queries\n        if (typeof path['path'] === 'string' || path['path'] instanceof Uint8Array) {\n          const metaPath = path.path;\n          const encoded = typeof metaPath === 'string' ? utf8ToBytes(metaPath) : metaPath;\n\n          return [utf8ToBytes('canister'), canisterUint8Array, utf8ToBytes('metadata'), encoded];\n\n          // For non-metadata, return the provided custompath\n        } else {\n          return path['path'];\n        }\n      }\n    }\n  }\n  throw UnknownError.fromCode(\n    new UnexpectedErrorCode(\n      `Error while encoding your path for canister status. Please ensure that your path ${path} was formatted correctly.`,\n    ),\n  );\n};\n\n// Controllers are CBOR-encoded buffers\nconst decodeControllers = (buf: Uint8Array): Principal[] => {\n  const controllersRaw = cbor.decode<Uint8Array[]>(buf);\n  return controllersRaw.map(buf => {\n    return Principal.fromUint8Array(buf);\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}