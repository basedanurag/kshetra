{"ast":null,"code":"import { lebEncode } from '@dfinity/candid';\nimport { Endpoint, makeNonce } from \"./types.js\";\nimport { ExpiryJsonDeserializeErrorCode, InputError } from \"../../errors.js\";\nexport const JSON_KEY_EXPIRY = '__expiry__';\nconst NANOSECONDS_PER_MILLISECOND = BigInt(1_000_000);\nconst NANOSECONDS_PER_SECOND = NANOSECONDS_PER_MILLISECOND * BigInt(1_000);\nconst SECONDS_PER_MINUTE = BigInt(60);\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;\nexport class Expiry {\n  constructor(__expiry__) {\n    this.__expiry__ = __expiry__;\n    this._isExpiry = true;\n  }\n  /**\n   * Creates an Expiry object from a delta in milliseconds.\n   * If the delta is less than 90 seconds, it is rounded to the nearest second.\n   * Otherwise, the delta is rounded down to the nearest minute, with a\n   * replica permitted drift subtracted.\n   * @param deltaInMs The delta in milliseconds.\n   * @returns {Expiry} an Expiry object\n   */\n  static fromDeltaInMilliseconds(deltaInMs) {\n    // if ingress as seconds is less than 90, round to nearest second\n    if (deltaInMs < 90 * 1_000) {\n      // Raw value without subtraction of REPLICA_PERMITTED_DRIFT_MILLISECONDS\n      const raw_value = BigInt(Date.now() + deltaInMs) * NANOSECONDS_PER_MILLISECOND;\n      const ingress_as_seconds = raw_value / NANOSECONDS_PER_SECOND;\n      return new Expiry(ingress_as_seconds * NANOSECONDS_PER_SECOND);\n    }\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    const raw_value = BigInt(Math.floor(Date.now() + deltaInMs - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) * NANOSECONDS_PER_MILLISECOND;\n    // round down to the nearest second\n    const ingress_as_seconds = raw_value / NANOSECONDS_PER_SECOND;\n    // round down to nearest minute\n    const ingress_as_minutes = ingress_as_seconds / SECONDS_PER_MINUTE;\n    const rounded_down_nanos = ingress_as_minutes * SECONDS_PER_MINUTE * NANOSECONDS_PER_SECOND;\n    return new Expiry(rounded_down_nanos);\n  }\n  toBigInt() {\n    return this.__expiry__;\n  }\n  toHash() {\n    return lebEncode(this.__expiry__);\n  }\n  toString() {\n    return this.__expiry__.toString();\n  }\n  /**\n   * Serializes to JSON\n   * @returns {JsonnableExpiry} a JSON object with a single key, {@link JSON_KEY_EXPIRY}, whose value is the expiry as a string\n   */\n  toJSON() {\n    return {\n      [JSON_KEY_EXPIRY]: this.toString()\n    };\n  }\n  /**\n   * Deserializes a {@link JsonnableExpiry} object from a JSON string.\n   * @param input The JSON string to deserialize.\n   * @returns {Expiry} The deserialized Expiry object.\n   */\n  static fromJSON(input) {\n    const obj = JSON.parse(input);\n    if (obj[JSON_KEY_EXPIRY]) {\n      try {\n        const expiry = BigInt(obj[JSON_KEY_EXPIRY]);\n        return new Expiry(expiry);\n      } catch (error) {\n        throw new InputError(new ExpiryJsonDeserializeErrorCode(`Not a valid BigInt: ${error}`));\n      }\n    }\n    throw new InputError(new ExpiryJsonDeserializeErrorCode(`The input does not contain the key ${JSON_KEY_EXPIRY}`));\n  }\n  static isExpiry(other) {\n    return other instanceof Expiry || typeof other === 'object' && other !== null && '_isExpiry' in other && other['_isExpiry'] === true && '__expiry__' in other && typeof other['__expiry__'] === 'bigint';\n  }\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform(nonceFn = makeNonce) {\n  return async request => {\n    // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n    const headers = request.request.headers;\n    // TODO: uncomment this when the http proxy supports it.\n    // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n    request.request.headers = headers;\n    // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n    if (request.endpoint === Endpoint.Call) {\n      request.body.nonce = nonceFn();\n    }\n  };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds) {\n  return async request => {\n    request.body.ingress_expiry = Expiry.fromDeltaInMilliseconds(delayInMilliseconds);\n  };\n}\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nexport function httpHeadersTransform(headers) {\n  const headerFields = [];\n  headers.forEach((value, key) => {\n    headerFields.push([key, value]);\n  });\n  return headerFields;\n}","map":{"version":3,"names":["lebEncode","Endpoint","makeNonce","ExpiryJsonDeserializeErrorCode","InputError","JSON_KEY_EXPIRY","NANOSECONDS_PER_MILLISECOND","BigInt","NANOSECONDS_PER_SECOND","SECONDS_PER_MINUTE","REPLICA_PERMITTED_DRIFT_MILLISECONDS","Expiry","constructor","__expiry__","_isExpiry","fromDeltaInMilliseconds","deltaInMs","raw_value","Date","now","ingress_as_seconds","Math","floor","ingress_as_minutes","rounded_down_nanos","toBigInt","toHash","toString","toJSON","fromJSON","input","obj","JSON","parse","expiry","error","isExpiry","other","makeNonceTransform","nonceFn","request","headers","endpoint","Call","body","nonce","makeExpiryTransform","delayInMilliseconds","ingress_expiry","httpHeadersTransform","headerFields","forEach","value","key","push"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\agent\\http\\transforms.ts"],"sourcesContent":["import { lebEncode } from '@dfinity/candid';\nimport {\n  Endpoint,\n  type HttpAgentRequest,\n  type HttpAgentRequestTransformFn,\n  type HttpHeaderField,\n  makeNonce,\n  type Nonce,\n} from './types.ts';\nimport { ExpiryJsonDeserializeErrorCode, InputError } from '../../errors.ts';\n\nexport const JSON_KEY_EXPIRY = '__expiry__';\nconst NANOSECONDS_PER_MILLISECOND = BigInt(1_000_000);\nconst NANOSECONDS_PER_SECOND = NANOSECONDS_PER_MILLISECOND * BigInt(1_000);\nconst SECONDS_PER_MINUTE = BigInt(60);\n\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;\n\nexport type JsonnableExpiry = {\n  [JSON_KEY_EXPIRY]: string;\n};\n\nexport class Expiry {\n  public readonly _isExpiry = true;\n\n  private constructor(private readonly __expiry__: bigint) {}\n\n  /**\n   * Creates an Expiry object from a delta in milliseconds.\n   * If the delta is less than 90 seconds, it is rounded to the nearest second.\n   * Otherwise, the delta is rounded down to the nearest minute, with a\n   * replica permitted drift subtracted.\n   * @param deltaInMs The delta in milliseconds.\n   * @returns {Expiry} an Expiry object\n   */\n  public static fromDeltaInMilliseconds(deltaInMs: number): Expiry {\n    // if ingress as seconds is less than 90, round to nearest second\n    if (deltaInMs < 90 * 1_000) {\n      // Raw value without subtraction of REPLICA_PERMITTED_DRIFT_MILLISECONDS\n      const raw_value = BigInt(Date.now() + deltaInMs) * NANOSECONDS_PER_MILLISECOND;\n      const ingress_as_seconds = raw_value / NANOSECONDS_PER_SECOND;\n      return new Expiry(ingress_as_seconds * NANOSECONDS_PER_SECOND);\n    }\n\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    const raw_value =\n      BigInt(Math.floor(Date.now() + deltaInMs - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) *\n      NANOSECONDS_PER_MILLISECOND;\n\n    // round down to the nearest second\n    const ingress_as_seconds = raw_value / NANOSECONDS_PER_SECOND;\n\n    // round down to nearest minute\n    const ingress_as_minutes = ingress_as_seconds / SECONDS_PER_MINUTE;\n\n    const rounded_down_nanos = ingress_as_minutes * SECONDS_PER_MINUTE * NANOSECONDS_PER_SECOND;\n\n    return new Expiry(rounded_down_nanos);\n  }\n\n  public toBigInt(): bigint {\n    return this.__expiry__;\n  }\n\n  public toHash(): Uint8Array {\n    return lebEncode(this.__expiry__);\n  }\n\n  public toString(): string {\n    return this.__expiry__.toString();\n  }\n\n  /**\n   * Serializes to JSON\n   * @returns {JsonnableExpiry} a JSON object with a single key, {@link JSON_KEY_EXPIRY}, whose value is the expiry as a string\n   */\n  public toJSON(): JsonnableExpiry {\n    return { [JSON_KEY_EXPIRY]: this.toString() };\n  }\n\n  /**\n   * Deserializes a {@link JsonnableExpiry} object from a JSON string.\n   * @param input The JSON string to deserialize.\n   * @returns {Expiry} The deserialized Expiry object.\n   */\n  public static fromJSON(input: string): Expiry {\n    const obj = JSON.parse(input);\n    if (obj[JSON_KEY_EXPIRY]) {\n      try {\n        const expiry = BigInt(obj[JSON_KEY_EXPIRY]);\n        return new Expiry(expiry);\n      } catch (error) {\n        throw new InputError(new ExpiryJsonDeserializeErrorCode(`Not a valid BigInt: ${error}`));\n      }\n    }\n    throw new InputError(\n      new ExpiryJsonDeserializeErrorCode(`The input does not contain the key ${JSON_KEY_EXPIRY}`),\n    );\n  }\n\n  public static isExpiry(other: unknown): other is Expiry {\n    return (\n      other instanceof Expiry ||\n      (typeof other === 'object' &&\n        other !== null &&\n        '_isExpiry' in other &&\n        (other as { _isExpiry: boolean })['_isExpiry'] === true &&\n        '__expiry__' in other &&\n        typeof (other as { __expiry__: bigint })['__expiry__'] === 'bigint')\n    );\n  }\n}\n\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform(nonceFn: () => Nonce = makeNonce): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n    const headers = request.request.headers;\n    // TODO: uncomment this when the http proxy supports it.\n    // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n    request.request.headers = headers;\n\n    // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n    if (request.endpoint === Endpoint.Call) {\n      request.body.nonce = nonceFn();\n    }\n  };\n}\n\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds: number): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    request.body.ingress_expiry = Expiry.fromDeltaInMilliseconds(delayInMilliseconds);\n  };\n}\n\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nexport function httpHeadersTransform(headers: Headers): HttpHeaderField[] {\n  const headerFields: HttpHeaderField[] = [];\n  headers.forEach((value, key) => {\n    headerFields.push([key, value]);\n  });\n  return headerFields;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}