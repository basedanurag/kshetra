{"ast":null,"code":"class w extends Error {\n  constructor(n) {\n    super(n), this.name = \"DecodingError\";\n  }\n}\nconst m = 55799,\n  L = Symbol(\"CBOR_STOP_CODE\");\nvar g = /* @__PURE__ */(t => (t[t.False = 20] = \"False\", t[t.True = 21] = \"True\", t[t.Null = 22] = \"Null\", t[t.Undefined = 23] = \"Undefined\", t[t.Break = 31] = \"Break\", t))(g || {}),\n  c = /* @__PURE__ */(t => (t[t.UnsignedInteger = 0] = \"UnsignedInteger\", t[t.NegativeInteger = 1] = \"NegativeInteger\", t[t.ByteString = 2] = \"ByteString\", t[t.TextString = 3] = \"TextString\", t[t.Array = 4] = \"Array\", t[t.Map = 5] = \"Map\", t[t.Tag = 6] = \"Tag\", t[t.Simple = 7] = \"Simple\", t))(c || {});\nconst z = 23,\n  Y = 255,\n  G = 65535,\n  P = 4294967295,\n  H = BigInt(\"0xffffffffffffffff\");\nvar d = /* @__PURE__ */(t => (t[t.Value = 23] = \"Value\", t[t.OneByte = 24] = \"OneByte\", t[t.TwoBytes = 25] = \"TwoBytes\", t[t.FourBytes = 26] = \"FourBytes\", t[t.EightBytes = 27] = \"EightBytes\", t[t.Indefinite = 31] = \"Indefinite\", t))(d || {});\nconst h = !1;\nfunction W(t) {\n  return t == null;\n}\nfunction R(t, n) {\n  const e = new Uint8Array(n);\n  return e.set(t), e;\n}\nconst K = new TextDecoder();\nfunction Z(t) {\n  return (t & 224) >> 5;\n}\nfunction q(t) {\n  return t & 31;\n}\nlet A = new Uint8Array(),\n  y,\n  a = 0;\nfunction ut(t, n) {\n  A = t, a = 0;\n  const e = B(n);\n  return (n == null ? void 0 : n(e)) ?? e;\n}\nfunction B(t) {\n  const [n, e] = N();\n  switch (n) {\n    case c.UnsignedInteger:\n      return E(e);\n    case c.NegativeInteger:\n      return j(e);\n    case c.ByteString:\n      return $(e);\n    case c.TextString:\n      return F(e);\n    case c.Array:\n      return J(e, t);\n    case c.Map:\n      return b(e, t);\n    case c.Tag:\n      return M(e, t);\n    case c.Simple:\n      return Q(e);\n  }\n  throw new w(`Unsupported major type: ${n}`);\n}\nfunction N() {\n  const t = A.at(a);\n  if (W(t)) throw new w(\"Provided CBOR data is empty\");\n  const n = Z(t),\n    e = q(t);\n  return a++, [n, e];\n}\nfunction J(t, n) {\n  const e = E(t);\n  if (e === 1 / 0) {\n    const u = [];\n    let f = B(n);\n    for (; f !== L;) u.push((n == null ? void 0 : n(f)) ?? f), f = B(n);\n    return u;\n  }\n  const i = new Array(e);\n  for (let u = 0; u < e; u++) {\n    const f = B(n);\n    i[u] = (n == null ? void 0 : n(f)) ?? f;\n  }\n  return i;\n}\nfunction Q(t) {\n  switch (t) {\n    case g.False:\n      return !1;\n    case g.True:\n      return !0;\n    case g.Null:\n      return null;\n    case g.Undefined:\n      return;\n    case g.Break:\n      return L;\n  }\n  throw new w(`Unrecognized simple type: ${t.toString(2)}`);\n}\nfunction b(t, n) {\n  const e = E(t),\n    i = {};\n  if (e === 1 / 0) {\n    let [u, f] = N();\n    for (; u !== c.Simple && f !== g.Break;) {\n      const l = F(f),\n        U = B(n);\n      i[l] = (n == null ? void 0 : n(U, l)) ?? U, [u, f] = N();\n    }\n    return i;\n  }\n  for (let u = 0; u < e; u++) {\n    const [f, l] = N();\n    if (f !== c.TextString) throw new w(\"Map keys must be text strings\");\n    const U = F(l),\n      D = B(n);\n    i[U] = (n == null ? void 0 : n(D, U)) ?? D;\n  }\n  return i;\n}\nfunction E(t) {\n  if (t <= d.Value) return t;\n  switch (y = new DataView(A.buffer, A.byteOffset + a), t) {\n    case d.OneByte:\n      return a++, y.getUint8(0);\n    case d.TwoBytes:\n      return a += 2, y.getUint16(0, h);\n    case d.FourBytes:\n      return a += 4, y.getUint32(0, h);\n    case d.EightBytes:\n      return a += 8, y.getBigUint64(0, h);\n    case d.Indefinite:\n      return 1 / 0;\n    default:\n      throw new w(`Unsupported integer info: ${t.toString(2)}`);\n  }\n}\nfunction j(t) {\n  const n = E(t);\n  return typeof n == \"number\" ? -1 - n : -1n - n;\n}\nfunction $(t) {\n  const n = E(t);\n  if (n > Number.MAX_SAFE_INTEGER) throw new w(\"Byte length is too large\");\n  const e = Number(n);\n  return a += e, A.slice(a - e, a);\n}\nfunction F(t) {\n  const n = $(t);\n  return K.decode(n);\n}\nfunction M(t, n) {\n  const e = E(t);\n  if (e === m) return B(n);\n  throw new w(`Unsupported tag: ${e}.`);\n}\nclass x extends Error {\n  constructor(n) {\n    super(n), this.name = \"SerializationError\";\n  }\n}\nconst p = 2 * 1024,\n  C = 100,\n  v = new TextEncoder();\nfunction S(t) {\n  return t << 5;\n}\nlet o = new Uint8Array(p),\n  r = new DataView(o.buffer),\n  s = 0,\n  O = [];\nfunction rt(t, n) {\n  s = 0;\n  const e = (n == null ? void 0 : n(t)) ?? t;\n  return _(e, n), o.slice(0, s);\n}\nfunction dt(t, n) {\n  s = 0;\n  const e = (n == null ? void 0 : n(t)) ?? t;\n  return it(m, e, n), o.slice(0, s);\n}\nfunction _(t, n) {\n  if (s > o.length - C && (o = R(o, o.length * 2), r = new DataView(o.buffer)), t === !1 || t === !0 || t === null || t === void 0) {\n    et(t);\n    return;\n  }\n  if (typeof t == \"number\" || typeof t == \"bigint\") {\n    ft(t);\n    return;\n  }\n  if (typeof t == \"string\") {\n    X(t);\n    return;\n  }\n  if (t instanceof Uint8Array) {\n    V(t);\n    return;\n  }\n  if (t instanceof ArrayBuffer) {\n    V(new Uint8Array(t));\n    return;\n  }\n  if (Array.isArray(t)) {\n    tt(t, n);\n    return;\n  }\n  if (typeof t == \"object\") {\n    nt(t, n);\n    return;\n  }\n  throw new x(`Unsupported type: ${typeof t}`);\n}\nfunction tt(t, n) {\n  I(c.Array, t.length), t.forEach((e, i) => {\n    _((n == null ? void 0 : n(e, i.toString())) ?? e, n);\n  });\n}\nfunction nt(t, n) {\n  O = Object.entries(t), I(c.Map, O.length), O.forEach(([e, i]) => {\n    X(e), _((n == null ? void 0 : n(i, e)) ?? i, n);\n  });\n}\nfunction I(t, n) {\n  if (n <= z) {\n    r.setUint8(s++, S(t) | Number(n));\n    return;\n  }\n  if (n <= Y) {\n    r.setUint8(s++, S(t) | d.OneByte), r.setUint8(s, Number(n)), s += 1;\n    return;\n  }\n  if (n <= G) {\n    r.setUint8(s++, S(t) | d.TwoBytes), r.setUint16(s, Number(n), h), s += 2;\n    return;\n  }\n  if (n <= P) {\n    r.setUint8(s++, S(t) | d.FourBytes), r.setUint32(s, Number(n), h), s += 4;\n    return;\n  }\n  if (n <= H) {\n    r.setUint8(s++, S(t) | d.EightBytes), r.setBigUint64(s, BigInt(n), h), s += 8;\n    return;\n  }\n  throw new x(`Value too large to encode: ${n}`);\n}\nfunction et(t) {\n  I(c.Simple, st(t));\n}\nfunction st(t) {\n  if (t === !1) return g.False;\n  if (t === !0) return g.True;\n  if (t === null) return g.Null;\n  if (t === void 0) return g.Undefined;\n  throw new x(`Unrecognized simple value: ${t.toString()}`);\n}\nfunction k(t, n) {\n  I(t, n.length), s > o.length - n.length && (o = R(o, o.length + n.length), r = new DataView(o.buffer)), o.set(n, s), s += n.length;\n}\nfunction T(t, n) {\n  I(t, n);\n}\nfunction ct(t) {\n  T(c.UnsignedInteger, t);\n}\nfunction ot(t) {\n  T(c.NegativeInteger, typeof t == \"bigint\" ? -1n - t : -1 - t);\n}\nfunction ft(t) {\n  t >= 0 ? ct(t) : ot(t);\n}\nfunction X(t) {\n  k(c.TextString, v.encode(t));\n}\nfunction V(t) {\n  k(c.ByteString, t);\n}\nfunction it(t, n, e) {\n  I(c.Tag, t), _(n, e);\n}\nexport { w as DecodingError, x as EncodingError, ut as decode, rt as encode, dt as encodeWithSelfDescribedTag };","map":{"version":3,"names":["w","Error","constructor","n","name","m","L","Symbol","g","t","False","True","Null","Undefined","Break","c","UnsignedInteger","NegativeInteger","ByteString","TextString","Array","Map","Tag","Simple","z","Y","G","P","H","BigInt","d","Value","OneByte","TwoBytes","FourBytes","EightBytes","Indefinite","h","W","R","e","Uint8Array","set","K","TextDecoder","Z","q","A","y","a","ut","B","N","E","j","$","F","J","b","M","Q","at","u","f","push","i","toString","l","U","D","DataView","buffer","byteOffset","getUint8","getUint16","getUint32","getBigUint64","Number","MAX_SAFE_INTEGER","slice","decode","x","p","C","v","TextEncoder","S","o","r","s","O","rt","_","dt","it","length","et","ft","X","V","ArrayBuffer","isArray","tt","nt","I","forEach","Object","entries","setUint8","setUint16","setUint32","setBigUint64","st","k","T","ct","ot","encode"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\cbor\\src\\decode\\decoding-error.ts","D:\\Kshetra\\frontend\\node_modules\\@dfinity\\cbor\\src\\cbor-value.ts","D:\\Kshetra\\frontend\\node_modules\\@dfinity\\cbor\\src\\util\\constants.ts","D:\\Kshetra\\frontend\\node_modules\\@dfinity\\cbor\\src\\util\\nil.ts","D:\\Kshetra\\frontend\\node_modules\\@dfinity\\cbor\\src\\util\\typed-array.ts","D:\\Kshetra\\frontend\\node_modules\\@dfinity\\cbor\\src\\decode\\decode.ts","D:\\Kshetra\\frontend\\node_modules\\@dfinity\\cbor\\src\\encode\\encoding-error.ts","D:\\Kshetra\\frontend\\node_modules\\@dfinity\\cbor\\src\\encode\\encode.ts"],"sourcesContent":["export class DecodingError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DecodingError';\n  }\n}\n","export type CborValue<T = any> = ReplacedCborValue<T> | T;\n\nexport type ReplacedCborValue<T = any> =\n  | CborNumber\n  | string\n  | ArrayBuffer\n  | Uint8Array\n  | CborValue<T>[]\n  | CborMap<T>\n  | CborSimple;\n\n/**\n * The tag number `55799`, the self-described tag for CBOR.\n * The serialization of this tag's head is `0xd9d9f7`.\n * @see {@link https://www.rfc-editor.org/rfc/rfc8949.html#section-3.4.6}\n */\nexport const CBOR_SELF_DESCRIBED_TAG = 55799;\n\nexport type CborNumber = number | bigint;\n\nexport const CBOR_STOP_CODE = Symbol('CBOR_STOP_CODE');\n\nexport type CborSimple = boolean | null | undefined | typeof CBOR_STOP_CODE;\n\nexport enum CborSimpleType {\n  False = 0x14,\n  True = 0x15,\n  Null = 0x16,\n  Undefined = 0x17,\n  Break = 0x1f,\n}\n\nexport type CborMap<T = any> =\n  | {\n      [key: string]: CborValue<T>;\n    }\n  | {\n      [key: string | number]: CborValue<T>;\n    }\n  | {\n      [key: string | symbol]: CborValue<T>;\n    }\n  | {\n      [key: string | number | symbol]: CborValue<T>;\n    };\n\nexport enum CborMajorType {\n  UnsignedInteger = 0,\n  NegativeInteger = 1,\n  ByteString = 2,\n  TextString = 3,\n  Array = 4,\n  Map = 5,\n  Tag = 6,\n  Simple = 7,\n}\n\nexport const TOKEN_VALUE_MAX = 0x17;\nexport const ONE_BYTE_MAX = 0xff;\nexport const TWO_BYTES_MAX = 0xffff;\nexport const FOUR_BYTES_MAX = 0xffffffff;\n/**\n * The maximum value that can be encoded in 8 bytes: `18446744073709551615n`.\n */\nexport const EIGHT_BYTES_MAX = BigInt('0xffffffffffffffff');\n\nexport enum CborMinorType {\n  Value = 23,\n  OneByte = 24,\n  TwoBytes = 25,\n  FourBytes = 26,\n  EightBytes = 27,\n  Indefinite = 31,\n}\n","export const IS_LITTLE_ENDIAN = false;\n","export function isNil<T>(\n  value: T | null | undefined,\n): value is null | undefined {\n  return value === null || value === undefined;\n}\n\nexport function isNotNil<T>(value: T | null | undefined): value is T {\n  return !isNil(value);\n}\n","export function resizeUint8Array(\n  array: Uint8Array,\n  newSize: number,\n): Uint8Array {\n  const newArray = new Uint8Array(newSize);\n  newArray.set(array);\n  return newArray;\n}\n","import {\n  CBOR_SELF_DESCRIBED_TAG,\n  CBOR_STOP_CODE,\n  CborMajorType,\n  CborMap,\n  CborMinorType,\n  CborNumber,\n  CborSimple,\n  CborSimpleType,\n  CborValue,\n} from '../cbor-value';\nimport { IS_LITTLE_ENDIAN, isNil } from '../util';\nimport { DecodingError } from './decoding-error';\n\nconst textDecoder = new TextDecoder();\n\nfunction decodeMajorType(firstByte: number): CborMajorType {\n  return (firstByte & 0b1110_0000) >> 5;\n}\n\nfunction decodeInfo(firstByte: number): number {\n  return firstByte & 0b0001_1111;\n}\n\nlet cborBytes = new Uint8Array();\nlet dataView: DataView | undefined;\nlet bytesOffset = 0;\n\n/**\n * A function that can be used to manipulate the decoded value.\n * See {@link decode} for more information.\n * @param value - The value to manipulate.\n * @param key - The current key in a map, or the current stringified index in an array.\n * @returns The manipulated value.\n */\nexport type Reviver<K extends CborValue = CborValue> = (\n  value: K,\n  key?: K extends CborValue ? string : keyof K,\n) => [K] extends [never] ? CborValue : K;\n\n/**\n * Decodes a CBOR byte array into a value.\n * See {@link Reviver} for more information.\n * @param input - The CBOR byte array to decode.\n * @param reviver - A function that can be used to manipulate the decoded value.\n * @returns The decoded value.\n *\n * @example Simple\n * ```ts\n * const value = true;\n * const encoded = encode(value); // returns `Uint8Array [245]` (which is \"F5\" in hex)\n * const decoded = decode(encoded); // returns `true`\n * ```\n *\n * @example Reviver\n * ```ts\n * const bytes = ...; // Uint8Array corresponding to the CBOR encoding of `{ a: 1, b: 2 }`\n * const reviver: Reviver = val => (typeof val === 'number' ? val * 2 : val);\n * decode(bytes, reviver); // returns `{ a: 2, b: 4 }`\n * ```\n */\nexport function decode<T extends CborValue = CborValue>(\n  input: Uint8Array,\n  reviver?: Reviver<T>,\n): T {\n  cborBytes = input;\n  bytesOffset = 0;\n\n  const decodedItem = decodeItem(reviver as Reviver | undefined) as T;\n  return (reviver?.(decodedItem as T) ?? decodedItem) as T;\n}\n\nfunction decodeItem(reviver?: Reviver): CborValue {\n  const [majorType, info] = decodeNextByte();\n\n  switch (majorType) {\n    case CborMajorType.UnsignedInteger:\n      return decodeUnsignedInteger(info);\n\n    case CborMajorType.NegativeInteger:\n      return decodeNegativeInteger(info);\n\n    case CborMajorType.ByteString:\n      return decodeByteString(info);\n\n    case CborMajorType.TextString:\n      return decodeTextString(info);\n\n    case CborMajorType.Array:\n      return decodeArray(info, reviver);\n\n    case CborMajorType.Map:\n      return decodeMap(info, reviver);\n\n    case CborMajorType.Tag:\n      return decodeTag(info, reviver);\n\n    case CborMajorType.Simple:\n      return decodeSimple(info);\n  }\n\n  throw new DecodingError(`Unsupported major type: ${majorType}`);\n}\n\nfunction decodeNextByte(): [CborMajorType, number] {\n  const firstByte = cborBytes.at(bytesOffset);\n  if (isNil(firstByte)) {\n    throw new DecodingError('Provided CBOR data is empty');\n  }\n\n  const majorType = decodeMajorType(firstByte);\n  const info = decodeInfo(firstByte);\n\n  bytesOffset++;\n  return [majorType, info];\n}\n\nfunction decodeArray(info: number, reviver?: Reviver): CborValue[] {\n  const arrayLength = decodeUnsignedInteger(info);\n\n  if (arrayLength === Infinity) {\n    const values: CborValue[] = [];\n    let decodedItem = decodeItem(reviver);\n\n    while (decodedItem !== CBOR_STOP_CODE) {\n      values.push(reviver?.(decodedItem) ?? decodedItem);\n      decodedItem = decodeItem(reviver);\n    }\n\n    return values;\n  }\n\n  const values = new Array<CborValue>(arrayLength);\n  for (let i = 0; i < arrayLength; i++) {\n    const decodedItem = decodeItem(reviver);\n    values[i] = reviver?.(decodedItem) ?? decodedItem;\n  }\n  return values;\n}\n\nfunction decodeSimple(info: number): CborSimple {\n  switch (info) {\n    case CborSimpleType.False: {\n      return false;\n    }\n    case CborSimpleType.True: {\n      return true;\n    }\n    case CborSimpleType.Null: {\n      return null;\n    }\n    case CborSimpleType.Undefined: {\n      return undefined;\n    }\n    case CborSimpleType.Break: {\n      return CBOR_STOP_CODE;\n    }\n  }\n\n  throw new DecodingError(`Unrecognized simple type: ${info.toString(2)}`);\n}\n\nfunction decodeMap(info: number, reviver?: Reviver): CborMap {\n  const mapLength = decodeUnsignedInteger(info);\n  const map: CborMap = {};\n\n  if (mapLength === Infinity) {\n    let [majorType, info] = decodeNextByte();\n\n    while (\n      majorType !== CborMajorType.Simple &&\n      info !== CborSimpleType.Break\n    ) {\n      const key = decodeTextString(info);\n      const decodedItem = decodeItem(reviver);\n      map[key] = reviver?.(decodedItem, key) ?? decodedItem;\n\n      [majorType, info] = decodeNextByte();\n    }\n\n    return map;\n  }\n\n  for (let i = 0; i < mapLength; i++) {\n    const [majorType, info] = decodeNextByte();\n\n    if (majorType !== CborMajorType.TextString) {\n      throw new DecodingError('Map keys must be text strings');\n    }\n\n    const key = decodeTextString(info);\n    const decodedItem = decodeItem(reviver);\n    map[key] = reviver?.(decodedItem, key) ?? decodedItem;\n  }\n\n  return map;\n}\n\nfunction decodeUnsignedInteger(info: number): CborNumber {\n  if (info <= CborMinorType.Value) {\n    return info;\n  }\n\n  dataView = new DataView(cborBytes.buffer, cborBytes.byteOffset + bytesOffset);\n  switch (info) {\n    case CborMinorType.OneByte:\n      bytesOffset++;\n      return dataView.getUint8(0);\n\n    case CborMinorType.TwoBytes:\n      bytesOffset += 2;\n      return dataView.getUint16(0, IS_LITTLE_ENDIAN);\n\n    case CborMinorType.FourBytes:\n      bytesOffset += 4;\n      return dataView.getUint32(0, IS_LITTLE_ENDIAN);\n\n    case CborMinorType.EightBytes:\n      bytesOffset += 8;\n      return dataView.getBigUint64(0, IS_LITTLE_ENDIAN);\n\n    case CborMinorType.Indefinite:\n      return Infinity;\n\n    default:\n      throw new DecodingError(`Unsupported integer info: ${info.toString(2)}`);\n  }\n}\n\nfunction decodeNegativeInteger(info: number): CborNumber {\n  const value = decodeUnsignedInteger(info);\n  const negativeValue = typeof value === 'number' ? -1 - value : -1n - value;\n\n  return negativeValue;\n}\n\nfunction decodeByteString(info: number): Uint8Array {\n  const byteLength = decodeUnsignedInteger(info);\n  if (byteLength > Number.MAX_SAFE_INTEGER) {\n    throw new DecodingError('Byte length is too large');\n  }\n\n  const safeByteLength = Number(byteLength);\n  bytesOffset += safeByteLength;\n  return cborBytes.slice(bytesOffset - safeByteLength, bytesOffset);\n}\n\nfunction decodeTextString(info: number): string {\n  const bytes = decodeByteString(info);\n\n  return textDecoder.decode(bytes);\n}\n\nfunction decodeTag(info: number, reviver?: Reviver): CborValue {\n  const value = decodeUnsignedInteger(info);\n\n  if (value === CBOR_SELF_DESCRIBED_TAG) {\n    return decodeItem(reviver);\n  }\n\n  throw new DecodingError(`Unsupported tag: ${value}.`);\n}\n","export class EncodingError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'SerializationError';\n  }\n}\n","import {\n  CborMajorType,\n  CborMap,\n  CborMinorType,\n  CborNumber,\n  CborSimple,\n  CborSimpleType,\n  CborValue,\n  ReplacedCborValue,\n  EIGHT_BYTES_MAX,\n  FOUR_BYTES_MAX,\n  ONE_BYTE_MAX,\n  TOKEN_VALUE_MAX,\n  TWO_BYTES_MAX,\n  CBOR_SELF_DESCRIBED_TAG,\n} from '../cbor-value';\nimport { EncodingError } from './encoding-error';\nimport { IS_LITTLE_ENDIAN, resizeUint8Array } from '../util';\n\nconst INITIAL_BUFFER_SIZE = 2 * 1_024;\nconst SAFE_BUFFER_END_OFFSET = 100;\n\nconst textEncoder = new TextEncoder();\n\nfunction encodeMajorType(majorType: CborMajorType): number {\n  return majorType << 5;\n}\n\nlet target = new Uint8Array(INITIAL_BUFFER_SIZE);\nlet targetView = new DataView(target.buffer);\nlet bytesOffset = 0;\nlet mapEntries: [string, CborValue][] = [];\n\n/**\n * A function that can be used to manipulate the input before it is encoded.\n * See {@link encode} for more information.\n * @param value - The value to manipulate.\n * @param key - The current key in a map, or the current stringified index in an array.\n * @returns The manipulated value.\n */\nexport type Replacer<T = any> = (\n  value: CborValue<T>,\n  key?: string,\n) => ReplacedCborValue<T>;\n\n/**\n * Encodes a value into a CBOR byte array.\n * @param value - The value to encode.\n * @param replacer - A function that can be used to manipulate the input before it is encoded.\n * @returns The encoded value.\n *\n * @example Simple\n * ```ts\n * const value = true;\n * const encoded = encode(value); // returns `Uint8Array [245]` (which is \"F5\" in hex)\n * ```\n *\n * @example Replacer\n * ```ts\n * const replacer: Replacer = val => (typeof val === 'number' ? val * 2 : val);\n * encode({ a: 1, b: 2 }, replacer); // returns the Uint8Array corresponding to the CBOR encoding of `{ a: 2, b: 4 }`\n * ```\n */\nexport function encode<T = any>(\n  value: CborValue<T>,\n  replacer?: Replacer<T>,\n): Uint8Array {\n  bytesOffset = 0;\n\n  const transformedValue = replacer?.(value) ?? value;\n  encodeItem(transformedValue, replacer);\n\n  return target.slice(0, bytesOffset);\n}\n\n/**\n * Encodes a value into a CBOR byte array (same as {@link encode}), but prepends the self-described CBOR tag (55799).\n * @param value - The value to encode.\n * @param replacer - A function that can be used to manipulate the input before it is encoded.\n * @returns The encoded value with the self-described CBOR tag.\n *\n * @example\n * ```ts\n * const value = true;\n * const encoded = encodeWithSelfDescribedTag(value); // returns the Uint8Array [217, 217, 247, 245] (which is \"D9D9F7F5\" in hex)\n * ```\n */\nexport function encodeWithSelfDescribedTag<T = any>(\n  value: CborValue<T>,\n  replacer?: Replacer<T>,\n): Uint8Array {\n  bytesOffset = 0;\n\n  const transformedValue = replacer?.(value) ?? value;\n  encodeTag(CBOR_SELF_DESCRIBED_TAG, transformedValue, replacer);\n\n  return target.slice(0, bytesOffset);\n}\n\nfunction encodeItem(item: CborValue, replacer?: Replacer): void {\n  if (bytesOffset > target.length - SAFE_BUFFER_END_OFFSET) {\n    target = resizeUint8Array(target, target.length * 2);\n    targetView = new DataView(target.buffer);\n  }\n\n  if (item === false || item === true || item === null || item === undefined) {\n    encodeSimple(item);\n    return;\n  }\n\n  if (typeof item === 'number' || typeof item === 'bigint') {\n    encodeNumber(item);\n    return;\n  }\n\n  if (typeof item === 'string') {\n    encodeTextString(item);\n    return;\n  }\n\n  if (item instanceof Uint8Array) {\n    encodeByteString(item);\n    return;\n  }\n\n  if (item instanceof ArrayBuffer) {\n    encodeByteString(new Uint8Array(item));\n    return;\n  }\n\n  if (Array.isArray(item)) {\n    encodeArray(item, replacer);\n    return;\n  }\n\n  if (typeof item === 'object') {\n    encodeMap(item, replacer);\n    return;\n  }\n\n  throw new EncodingError(`Unsupported type: ${typeof item}`);\n}\n\nfunction encodeArray(items: CborValue[], replacer?: Replacer): void {\n  encodeHeader(CborMajorType.Array, items.length);\n\n  items.forEach((item, i) => {\n    encodeItem(replacer?.(item, i.toString()) ?? item, replacer);\n  });\n}\n\nfunction encodeMap(map: CborMap, replacer?: Replacer): void {\n  mapEntries = Object.entries(map);\n\n  encodeHeader(CborMajorType.Map, mapEntries.length);\n\n  mapEntries.forEach(([key, value]) => {\n    encodeTextString(key);\n    encodeItem(replacer?.(value, key) ?? value, replacer);\n  });\n}\n\nfunction encodeHeader(majorType: CborMajorType, value: CborNumber): void {\n  if (value <= TOKEN_VALUE_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | Number(value),\n    );\n    return;\n  }\n\n  if (value <= ONE_BYTE_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.OneByte,\n    );\n    targetView.setUint8(bytesOffset, Number(value));\n    bytesOffset += 1;\n    return;\n  }\n\n  if (value <= TWO_BYTES_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.TwoBytes,\n    );\n    targetView.setUint16(bytesOffset, Number(value), IS_LITTLE_ENDIAN);\n    bytesOffset += 2;\n    return;\n  }\n\n  if (value <= FOUR_BYTES_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.FourBytes,\n    );\n    targetView.setUint32(bytesOffset, Number(value), IS_LITTLE_ENDIAN);\n    bytesOffset += 4;\n    return;\n  }\n\n  if (value <= EIGHT_BYTES_MAX) {\n    targetView.setUint8(\n      bytesOffset++,\n      encodeMajorType(majorType) | CborMinorType.EightBytes,\n    );\n    targetView.setBigUint64(bytesOffset, BigInt(value), IS_LITTLE_ENDIAN);\n    bytesOffset += 8;\n    return;\n  }\n\n  throw new EncodingError(`Value too large to encode: ${value}`);\n}\n\nfunction encodeSimple(value: CborSimple): void {\n  encodeHeader(CborMajorType.Simple, mapSimple(value));\n}\n\nfunction mapSimple(value: CborSimple): CborSimpleType {\n  if (value === false) {\n    return CborSimpleType.False;\n  }\n\n  if (value === true) {\n    return CborSimpleType.True;\n  }\n\n  if (value === null) {\n    return CborSimpleType.Null;\n  }\n\n  if (value === undefined) {\n    return CborSimpleType.Undefined;\n  }\n\n  throw new EncodingError(`Unrecognized simple value: ${value.toString()}`);\n}\n\nfunction encodeBytes(majorType: CborMajorType, value: Uint8Array): void {\n  encodeHeader(majorType, value.length);\n\n  if (bytesOffset > target.length - value.length) {\n    target = resizeUint8Array(target, target.length + value.length);\n    targetView = new DataView(target.buffer);\n  }\n  target.set(value, bytesOffset);\n  bytesOffset += value.length;\n}\n\nfunction encodeInteger(majorType: CborMajorType, value: CborNumber): void {\n  encodeHeader(majorType, value);\n}\n\nfunction encodeUnsignedInteger(value: CborNumber): void {\n  encodeInteger(CborMajorType.UnsignedInteger, value);\n}\n\nfunction encodeNegativeInteger(value: CborNumber): void {\n  encodeInteger(\n    CborMajorType.NegativeInteger,\n    typeof value === 'bigint' ? -1n - value : -1 - value,\n  );\n}\n\nfunction encodeNumber(value: CborNumber): void {\n  value >= 0 ? encodeUnsignedInteger(value) : encodeNegativeInteger(value);\n}\n\nfunction encodeTextString(value: string): void {\n  encodeBytes(CborMajorType.TextString, textEncoder.encode(value));\n}\n\nfunction encodeByteString(value: Uint8Array): void {\n  encodeBytes(CborMajorType.ByteString, value);\n}\n\nfunction encodeTag(tag: number, value: CborValue, replacer?: Replacer): void {\n  encodeHeader(CborMajorType.Tag, tag);\n  encodeItem(value, replacer);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}