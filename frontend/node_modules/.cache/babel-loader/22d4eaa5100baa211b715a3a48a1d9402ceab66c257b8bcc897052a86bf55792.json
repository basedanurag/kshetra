{"ast":null,"code":"import { DerDecodeErrorCode, DerDecodeLengthMismatchErrorCode, DerEncodeErrorCode, InputError } from \"./errors.js\";\nimport { uint8Equals } from \"./utils/buffer.js\";\nexport const encodeLenBytes = len => {\n  if (len <= 0x7f) {\n    return 1;\n  } else if (len <= 0xff) {\n    return 2;\n  } else if (len <= 0xffff) {\n    return 3;\n  } else if (len <= 0xffffff) {\n    return 4;\n  } else {\n    throw InputError.fromCode(new DerEncodeErrorCode('Length too long (> 4 bytes)'));\n  }\n};\nexport const encodeLen = (buf, offset, len) => {\n  if (len <= 0x7f) {\n    buf[offset] = len;\n    return 1;\n  } else if (len <= 0xff) {\n    buf[offset] = 0x81;\n    buf[offset + 1] = len;\n    return 2;\n  } else if (len <= 0xffff) {\n    buf[offset] = 0x82;\n    buf[offset + 1] = len >> 8;\n    buf[offset + 2] = len;\n    return 3;\n  } else if (len <= 0xffffff) {\n    buf[offset] = 0x83;\n    buf[offset + 1] = len >> 16;\n    buf[offset + 2] = len >> 8;\n    buf[offset + 3] = len;\n    return 4;\n  } else {\n    throw InputError.fromCode(new DerEncodeErrorCode('Length too long (> 4 bytes)'));\n  }\n};\nexport const decodeLenBytes = (buf, offset) => {\n  if (buf[offset] < 0x80) return 1;\n  if (buf[offset] === 0x80) throw InputError.fromCode(new DerDecodeErrorCode('Invalid length 0'));\n  if (buf[offset] === 0x81) return 2;\n  if (buf[offset] === 0x82) return 3;\n  if (buf[offset] === 0x83) return 4;\n  throw InputError.fromCode(new DerDecodeErrorCode('Length too long (> 4 bytes)'));\n};\nexport const decodeLen = (buf, offset) => {\n  const lenBytes = decodeLenBytes(buf, offset);\n  if (lenBytes === 1) return buf[offset];else if (lenBytes === 2) return buf[offset + 1];else if (lenBytes === 3) return (buf[offset + 1] << 8) + buf[offset + 2];else if (lenBytes === 4) return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n  throw InputError.fromCode(new DerDecodeErrorCode('Length too long (> 4 bytes)'));\n};\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nexport const DER_COSE_OID = Uint8Array.from([...[0x30, 0x0c],\n// SEQUENCE\n...[0x06, 0x0a],\n// OID with 10 bytes\n...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01] // DER encoded COSE\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nexport const ED25519_OID = Uint8Array.from([...[0x30, 0x05],\n// SEQUENCE\n...[0x06, 0x03],\n// OID with 3 bytes\n...[0x2b, 0x65, 0x70] // id-Ed25519 OID\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nexport const SECP256K1_OID = Uint8Array.from([...[0x30, 0x10],\n// SEQUENCE\n...[0x06, 0x07],\n// OID with 7 bytes\n...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01],\n// OID ECDSA\n...[0x06, 0x05],\n// OID with 5 bytes\n...[0x2b, 0x81, 0x04, 0x00, 0x0a] // OID secp256k1\n]);\nexport const BLS12_381_G2_OID = Uint8Array.from([...[0x30, 0x1d],\n// SEQUENCE, length 29 bytes\n// Algorithm OID\n...[0x06, 0x0d], ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0xdc, 0x7c, 0x05, 0x03, 0x01, 0x02, 0x01],\n// Curve OID\n...[0x06, 0x0c], ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0xdc, 0x7c, 0x05, 0x03, 0x02, 0x01]]);\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nexport function wrapDER(payload, oid) {\n  // The Bit String header needs to include the unused bit count byte in its length\n  const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n  const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n  let offset = 0;\n  const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n  // Sequence\n  buf[offset++] = 0x30;\n  // Sequence Length\n  offset += encodeLen(buf, offset, len);\n  // OID\n  buf.set(oid, offset);\n  offset += oid.byteLength;\n  // Bit String Header\n  buf[offset++] = 0x03;\n  offset += encodeLen(buf, offset, payload.byteLength + 1);\n  // 0 padding\n  buf[offset++] = 0x00;\n  buf.set(new Uint8Array(payload), offset);\n  return buf;\n}\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nexport const unwrapDER = (derEncoded, oid) => {\n  let offset = 0;\n  const expect = (n, msg) => {\n    if (buf[offset++] !== n) {\n      throw InputError.fromCode(new DerDecodeErrorCode(`Expected ${msg} at offset ${offset}`));\n    }\n  };\n  const buf = new Uint8Array(derEncoded);\n  expect(0x30, 'sequence');\n  offset += decodeLenBytes(buf, offset);\n  if (!uint8Equals(buf.slice(offset, offset + oid.byteLength), oid)) {\n    throw InputError.fromCode(new DerDecodeErrorCode('Not the expected OID.'));\n  }\n  offset += oid.byteLength;\n  expect(0x03, 'bit string');\n  const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n  offset += decodeLenBytes(buf, offset);\n  expect(0x00, '0 padding');\n  const result = buf.slice(offset);\n  if (payloadLen !== result.length) {\n    throw InputError.fromCode(new DerDecodeLengthMismatchErrorCode(payloadLen, result.length));\n  }\n  return result;\n};","map":{"version":3,"names":["DerDecodeErrorCode","DerDecodeLengthMismatchErrorCode","DerEncodeErrorCode","InputError","uint8Equals","encodeLenBytes","len","fromCode","encodeLen","buf","offset","decodeLenBytes","decodeLen","lenBytes","DER_COSE_OID","Uint8Array","from","ED25519_OID","SECP256K1_OID","BLS12_381_G2_OID","wrapDER","payload","oid","bitStringHeaderLength","byteLength","set","unwrapDER","derEncoded","expect","n","msg","slice","payloadLen","result","length"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\der.ts"],"sourcesContent":["import {\n  DerDecodeErrorCode,\n  DerDecodeLengthMismatchErrorCode,\n  DerEncodeErrorCode,\n  InputError,\n} from './errors.ts';\nimport { uint8Equals } from './utils/buffer.ts';\n\nexport const encodeLenBytes = (len: number): number => {\n  if (len <= 0x7f) {\n    return 1;\n  } else if (len <= 0xff) {\n    return 2;\n  } else if (len <= 0xffff) {\n    return 3;\n  } else if (len <= 0xffffff) {\n    return 4;\n  } else {\n    throw InputError.fromCode(new DerEncodeErrorCode('Length too long (> 4 bytes)'));\n  }\n};\n\nexport const encodeLen = (buf: Uint8Array, offset: number, len: number): number => {\n  if (len <= 0x7f) {\n    buf[offset] = len;\n    return 1;\n  } else if (len <= 0xff) {\n    buf[offset] = 0x81;\n    buf[offset + 1] = len;\n    return 2;\n  } else if (len <= 0xffff) {\n    buf[offset] = 0x82;\n    buf[offset + 1] = len >> 8;\n    buf[offset + 2] = len;\n    return 3;\n  } else if (len <= 0xffffff) {\n    buf[offset] = 0x83;\n    buf[offset + 1] = len >> 16;\n    buf[offset + 2] = len >> 8;\n    buf[offset + 3] = len;\n    return 4;\n  } else {\n    throw InputError.fromCode(new DerEncodeErrorCode('Length too long (> 4 bytes)'));\n  }\n};\n\nexport const decodeLenBytes = (buf: Uint8Array, offset: number): number => {\n  if (buf[offset] < 0x80) return 1;\n  if (buf[offset] === 0x80) throw InputError.fromCode(new DerDecodeErrorCode('Invalid length 0'));\n  if (buf[offset] === 0x81) return 2;\n  if (buf[offset] === 0x82) return 3;\n  if (buf[offset] === 0x83) return 4;\n  throw InputError.fromCode(new DerDecodeErrorCode('Length too long (> 4 bytes)'));\n};\n\nexport const decodeLen = (buf: Uint8Array, offset: number): number => {\n  const lenBytes = decodeLenBytes(buf, offset);\n  if (lenBytes === 1) return buf[offset];\n  else if (lenBytes === 2) return buf[offset + 1];\n  else if (lenBytes === 3) return (buf[offset + 1] << 8) + buf[offset + 2];\n  else if (lenBytes === 4)\n    return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n  throw InputError.fromCode(new DerDecodeErrorCode('Length too long (> 4 bytes)'));\n};\n\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nexport const DER_COSE_OID = Uint8Array.from([\n  ...[0x30, 0x0c], // SEQUENCE\n  ...[0x06, 0x0a], // OID with 10 bytes\n  ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01], // DER encoded COSE\n]);\n\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nexport const ED25519_OID = Uint8Array.from([\n  ...[0x30, 0x05], // SEQUENCE\n  ...[0x06, 0x03], // OID with 3 bytes\n  ...[0x2b, 0x65, 0x70], // id-Ed25519 OID\n]);\n\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nexport const SECP256K1_OID = Uint8Array.from([\n  ...[0x30, 0x10], // SEQUENCE\n  ...[0x06, 0x07], // OID with 7 bytes\n  ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01], // OID ECDSA\n  ...[0x06, 0x05], // OID with 5 bytes\n  ...[0x2b, 0x81, 0x04, 0x00, 0x0a], // OID secp256k1\n]);\n\nexport const BLS12_381_G2_OID = Uint8Array.from([\n  ...[0x30, 0x1d], // SEQUENCE, length 29 bytes\n  // Algorithm OID\n  ...[0x06, 0x0d],\n  ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0xdc, 0x7c, 0x05, 0x03, 0x01, 0x02, 0x01],\n  // Curve OID\n  ...[0x06, 0x0c],\n  ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0xdc, 0x7c, 0x05, 0x03, 0x02, 0x01],\n]);\n\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nexport function wrapDER(payload: Uint8Array, oid: Uint8Array): Uint8Array {\n  // The Bit String header needs to include the unused bit count byte in its length\n  const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n  const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n  let offset = 0;\n  const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n  // Sequence\n  buf[offset++] = 0x30;\n  // Sequence Length\n  offset += encodeLen(buf, offset, len);\n\n  // OID\n  buf.set(oid, offset);\n  offset += oid.byteLength;\n\n  // Bit String Header\n  buf[offset++] = 0x03;\n  offset += encodeLen(buf, offset, payload.byteLength + 1);\n  // 0 padding\n  buf[offset++] = 0x00;\n  buf.set(new Uint8Array(payload), offset);\n\n  return buf;\n}\n\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nexport const unwrapDER = (derEncoded: Uint8Array, oid: Uint8Array): Uint8Array => {\n  let offset = 0;\n  const expect = (n: number, msg: string) => {\n    if (buf[offset++] !== n) {\n      throw InputError.fromCode(new DerDecodeErrorCode(`Expected ${msg} at offset ${offset}`));\n    }\n  };\n\n  const buf = new Uint8Array(derEncoded);\n  expect(0x30, 'sequence');\n  offset += decodeLenBytes(buf, offset);\n\n  if (!uint8Equals(buf.slice(offset, offset + oid.byteLength), oid)) {\n    throw InputError.fromCode(new DerDecodeErrorCode('Not the expected OID.'));\n  }\n  offset += oid.byteLength;\n\n  expect(0x03, 'bit string');\n  const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n  offset += decodeLenBytes(buf, offset);\n  expect(0x00, '0 padding');\n  const result = buf.slice(offset);\n  if (payloadLen !== result.length) {\n    throw InputError.fromCode(new DerDecodeLengthMismatchErrorCode(payloadLen, result.length));\n  }\n  return result;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}