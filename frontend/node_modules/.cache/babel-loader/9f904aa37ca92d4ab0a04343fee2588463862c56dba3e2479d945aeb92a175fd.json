{"ast":null,"code":"import * as cbor from \"./cbor.js\";\nimport { CertificateHasTooManyDelegationsErrorCode, CertificateNotAuthorizedErrorCode, CertificateTimeErrorCode, CertificateVerificationErrorCode, DerKeyLengthMismatchErrorCode, DerPrefixMismatchErrorCode, ProtocolError, LookupErrorCode, TrustError, UnknownError, HashTreeDecodeErrorCode, UNREACHABLE_ERROR, MalformedLookupFoundValueErrorCode, MissingLookupValueErrorCode } from \"./errors.js\";\nimport { Principal } from '@dfinity/principal';\nimport * as bls from \"./utils/bls.js\";\nimport { decodeTime } from \"./utils/leb.js\";\nimport { MANAGEMENT_CANISTER_ID } from \"./agent/index.js\";\nimport { bytesToHex, concatBytes, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { uint8Equals } from \"./utils/buffer.js\";\nimport { sha256 } from '@noble/hashes/sha2';\nexport var NodeType;\n(function (NodeType) {\n  NodeType[NodeType[\"Empty\"] = 0] = \"Empty\";\n  NodeType[NodeType[\"Fork\"] = 1] = \"Fork\";\n  NodeType[NodeType[\"Labeled\"] = 2] = \"Labeled\";\n  NodeType[NodeType[\"Leaf\"] = 3] = \"Leaf\";\n  NodeType[NodeType[\"Pruned\"] = 4] = \"Pruned\";\n})(NodeType || (NodeType = {}));\n/**\n * Make a human readable string out of a hash tree.\n * @param tree The hash tree to convert to a string\n */\nexport function hashTreeToString(tree) {\n  const indent = s => s.split('\\n').map(x => '  ' + x).join('\\n');\n  function labelToString(label) {\n    const decoder = new TextDecoder(undefined, {\n      fatal: true\n    });\n    try {\n      return JSON.stringify(decoder.decode(label));\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n  switch (tree[0]) {\n    case NodeType.Empty:\n      return '()';\n    case NodeType.Fork:\n      {\n        if (tree[1] instanceof Array && tree[2] instanceof Uint8Array) {\n          const left = hashTreeToString(tree[1]);\n          const right = hashTreeToString(tree[2]);\n          return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n        } else {\n          throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid tree structure for fork'));\n        }\n      }\n    case NodeType.Labeled:\n      {\n        if (tree[1] instanceof Uint8Array && tree[2] instanceof Uint8Array) {\n          const label = labelToString(tree[1]);\n          const sub = hashTreeToString(tree[2]);\n          return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n        } else {\n          throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid tree structure for labeled'));\n        }\n      }\n    case NodeType.Leaf:\n      {\n        if (!tree[1]) {\n          throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid tree structure for leaf'));\n        } else if (Array.isArray(tree[1])) {\n          return JSON.stringify(tree[1]);\n        }\n        return `leaf(...${tree[1].byteLength} bytes)`;\n      }\n    case NodeType.Pruned:\n      {\n        if (!tree[1]) {\n          throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid tree structure for pruned'));\n        } else if (Array.isArray(tree[1])) {\n          return JSON.stringify(tree[1]);\n        }\n        return `pruned(${bytesToHex(new Uint8Array(tree[1]))}`;\n      }\n    default:\n      {\n        return `unknown(${JSON.stringify(tree[0])})`;\n      }\n  }\n}\nfunction isBufferGreaterThan(a, b) {\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] > b[i]) {\n      return true;\n    }\n  }\n  return false;\n}\nexport class Certificate {\n  #disableTimeVerification = false;\n  /**\n   * Create a new instance of a certificate, automatically verifying it.\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {Uint8Array} options.certificate The bytes of the certificate\n   * @param {Uint8Array} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws if the certificate cannot be verified\n   */\n  static async create(options) {\n    const cert = Certificate.createUnverified(options);\n    await cert.verify();\n    return cert;\n  }\n  static createUnverified(options) {\n    return new Certificate(options.certificate, options.rootKey, options.canisterId, options.blsVerify ?? bls.blsVerify, options.maxAgeInMinutes, options.disableTimeVerification);\n  }\n  constructor(certificate, _rootKey, _canisterId, _blsVerify) {\n    let _maxAgeInMinutes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 5;\n    let disableTimeVerification = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    this._rootKey = _rootKey;\n    this._canisterId = _canisterId;\n    this._blsVerify = _blsVerify;\n    this._maxAgeInMinutes = _maxAgeInMinutes;\n    this.#disableTimeVerification = disableTimeVerification;\n    this.cert = cbor.decode(certificate);\n  }\n  /**\n   * Lookup a path in the certificate tree, using {@link lookup_path}.\n   * @param path The path to lookup.\n   * @returns The result of the lookup.\n   */\n  lookup_path(path) {\n    return lookup_path(path, this.cert.tree);\n  }\n  /**\n   * Lookup a subtree in the certificate tree, using {@link lookup_subtree}.\n   * @param path The path to lookup.\n   * @returns The result of the lookup.\n   */\n  lookup_subtree(path) {\n    return lookup_subtree(path, this.cert.tree);\n  }\n  async verify() {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concatBytes(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n    const lookupTime = lookupResultToBuffer(this.lookup_path(['time']));\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw ProtocolError.fromCode(new CertificateVerificationErrorCode('Certificate does not contain a time'));\n    }\n    // Certificate time verification checks\n    if (!this.#disableTimeVerification) {\n      const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n      const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n      const now = Date.now();\n      const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n      const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n      const certTime = decodeTime(lookupTime);\n      if (certTime.getTime() < earliestCertificateTime) {\n        throw TrustError.fromCode(new CertificateTimeErrorCode(this._maxAgeInMinutes, certTime, new Date(now), 'past'));\n      } else if (certTime.getTime() > fiveMinutesFromNow) {\n        throw TrustError.fromCode(new CertificateTimeErrorCode(5, certTime, new Date(now), 'future'));\n      }\n    }\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw TrustError.fromCode(new CertificateVerificationErrorCode('Signature verification failed'));\n    }\n  }\n  async _checkDelegationAndGetKey(d) {\n    if (!d) {\n      return this._rootKey;\n    }\n    const cert = Certificate.createUnverified({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      disableTimeVerification: true\n    });\n    if (cert.cert.delegation) {\n      throw ProtocolError.fromCode(new CertificateHasTooManyDelegationsErrorCode());\n    }\n    await cert.verify();\n    if (this._canisterId.toString() !== MANAGEMENT_CANISTER_ID) {\n      const canisterInRange = check_canister_ranges({\n        canisterId: this._canisterId,\n        subnetId: Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n        tree: cert.cert.tree\n      });\n      if (!canisterInRange) {\n        throw TrustError.fromCode(new CertificateNotAuthorizedErrorCode(this._canisterId, d.subnet_id));\n      }\n    }\n    const publicKeyLookup = lookupResultToBuffer(cert.lookup_path(['subnet', d.subnet_id, 'public_key']));\n    if (!publicKeyLookup) {\n      throw TrustError.fromCode(new MissingLookupValueErrorCode(`Could not find subnet key for subnet 0x${bytesToHex(d.subnet_id)}`));\n    }\n    return publicKeyLookup;\n  }\n}\nconst DER_PREFIX = hexToBytes('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw ProtocolError.fromCode(new DerKeyLengthMismatchErrorCode(expectedLength, buf.byteLength));\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!uint8Equals(prefix, DER_PREFIX)) {\n    throw ProtocolError.fromCode(new DerPrefixMismatchErrorCode(DER_PREFIX, prefix));\n  }\n  return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * Utility function to constrain the type of a lookup result\n * @param result the result of a lookup\n * @returns {Uint8Array | undefined} the value if the lookup was found, `undefined` otherwise\n */\nexport function lookupResultToBuffer(result) {\n  if (result.status !== LookupPathStatus.Found) {\n    return undefined;\n  }\n  if (result.value instanceof Uint8Array) {\n    return result.value;\n  }\n  return undefined;\n}\n/**\n * @param t The hash tree to reconstruct\n */\nexport async function reconstruct(t) {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return sha256(domain_sep('ic-hashtree-empty'));\n    case NodeType.Pruned:\n      return t[1];\n    case NodeType.Leaf:\n      return sha256(concatBytes(domain_sep('ic-hashtree-leaf'), t[1]));\n    case NodeType.Labeled:\n      return sha256(concatBytes(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n    case NodeType.Fork:\n      return sha256(concatBytes(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n    default:\n      throw UNREACHABLE_ERROR;\n  }\n}\n/**\n * Creates a domain separator for hashing by encoding the input string\n * with its length as a prefix.\n * @param s - The input string to encode.\n * @returns A Uint8Array containing the encoded domain separator.\n */\nexport function domain_sep(s) {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concatBytes(len, str);\n}\nfunction pathToLabel(path) {\n  return typeof path[0] === 'string' ? utf8ToBytes(path[0]) : path[0];\n}\nexport var LookupPathStatus;\n(function (LookupPathStatus) {\n  LookupPathStatus[\"Unknown\"] = \"Unknown\";\n  LookupPathStatus[\"Absent\"] = \"Absent\";\n  LookupPathStatus[\"Found\"] = \"Found\";\n  LookupPathStatus[\"Error\"] = \"Error\";\n})(LookupPathStatus || (LookupPathStatus = {}));\nexport var LookupSubtreeStatus;\n(function (LookupSubtreeStatus) {\n  LookupSubtreeStatus[\"Absent\"] = \"Absent\";\n  LookupSubtreeStatus[\"Unknown\"] = \"Unknown\";\n  LookupSubtreeStatus[\"Found\"] = \"Found\";\n})(LookupSubtreeStatus || (LookupSubtreeStatus = {}));\nexport var LookupLabelStatus;\n(function (LookupLabelStatus) {\n  LookupLabelStatus[\"Absent\"] = \"Absent\";\n  LookupLabelStatus[\"Unknown\"] = \"Unknown\";\n  LookupLabelStatus[\"Found\"] = \"Found\";\n  LookupLabelStatus[\"Less\"] = \"Less\";\n  LookupLabelStatus[\"Greater\"] = \"Greater\";\n})(LookupLabelStatus || (LookupLabelStatus = {}));\n/**\n * Lookup a path in a tree. If the path is a subtree, use {@link lookup_subtree} instead.\n * @param path the path to look up\n * @param tree the tree to search\n * @returns {LookupResult} the result of the lookup\n */\nexport function lookup_path(path, tree) {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeType.Empty:\n        {\n          return {\n            status: LookupPathStatus.Absent\n          };\n        }\n      case NodeType.Leaf:\n        {\n          if (!tree[1]) {\n            throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid tree structure for leaf'));\n          }\n          if (tree[1] instanceof Uint8Array) {\n            return {\n              status: LookupPathStatus.Found,\n              value: tree[1].slice(tree[1].byteOffset, tree[1].byteLength + tree[1].byteOffset)\n            };\n          }\n          throw UNREACHABLE_ERROR;\n        }\n      case NodeType.Pruned:\n        {\n          return {\n            status: LookupPathStatus.Unknown\n          };\n        }\n      case NodeType.Labeled:\n      case NodeType.Fork:\n        {\n          return {\n            status: LookupPathStatus.Error\n          };\n        }\n      default:\n        {\n          throw UNREACHABLE_ERROR;\n        }\n    }\n  }\n  const label = pathToLabel(path);\n  const lookupResult = find_label(label, tree);\n  switch (lookupResult.status) {\n    case LookupLabelStatus.Found:\n      {\n        return lookup_path(path.slice(1), lookupResult.value);\n      }\n    case LookupLabelStatus.Absent:\n    case LookupLabelStatus.Greater:\n    case LookupLabelStatus.Less:\n      {\n        return {\n          status: LookupPathStatus.Absent\n        };\n      }\n    case LookupLabelStatus.Unknown:\n      {\n        return {\n          status: LookupPathStatus.Unknown\n        };\n      }\n    default:\n      {\n        throw UNREACHABLE_ERROR;\n      }\n  }\n}\n/**\n * Lookup a subtree in a tree.\n * @param path the path to look up\n * @param tree the tree to search\n * @returns {SubtreeLookupResult} the result of the lookup\n */\nexport function lookup_subtree(path, tree) {\n  if (path.length === 0) {\n    return {\n      status: LookupSubtreeStatus.Found,\n      value: tree\n    };\n  }\n  const label = pathToLabel(path);\n  const lookupResult = find_label(label, tree);\n  switch (lookupResult.status) {\n    case LookupLabelStatus.Found:\n      {\n        return lookup_subtree(path.slice(1), lookupResult.value);\n      }\n    case LookupLabelStatus.Unknown:\n      {\n        return {\n          status: LookupSubtreeStatus.Unknown\n        };\n      }\n    case LookupLabelStatus.Absent:\n    case LookupLabelStatus.Greater:\n    case LookupLabelStatus.Less:\n      {\n        return {\n          status: LookupSubtreeStatus.Absent\n        };\n      }\n    default:\n      {\n        throw UNREACHABLE_ERROR;\n      }\n  }\n}\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param {HashTree} t the tree to flatten\n * @returns {HashTree[]} the flattened tree\n */\nexport function flatten_forks(t) {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return [];\n    case NodeType.Fork:\n      return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n    default:\n      return [t];\n  }\n}\n/**\n * Find a label in a tree\n * @param label the label to find\n * @param tree the tree to search\n * @returns {LabelLookupResult} the result of the label lookup\n */\nexport function find_label(label, tree) {\n  switch (tree[0]) {\n    // if we have a labelled node, compare the node's label to the one we are\n    // looking for\n    case NodeType.Labeled:\n      // if the label we're searching for is greater than this node's label,\n      // we need to keep searching\n      if (isBufferGreaterThan(label, tree[1])) {\n        return {\n          status: LookupLabelStatus.Greater\n        };\n      }\n      // if the label we're searching for is equal this node's label, we can\n      // stop searching and return the found node\n      if (uint8Equals(label, tree[1])) {\n        return {\n          status: LookupLabelStatus.Found,\n          value: tree[2]\n        };\n      }\n      // if the label we're searching for is not greater than or equal to this\n      // node's label, then it's less than this node's label, and we can stop\n      // searching because we've looked too far\n      return {\n        status: LookupLabelStatus.Less\n      };\n    // if we have a fork node, we need to search both sides, starting with the left\n    case NodeType.Fork:\n      {\n        // search in the left node\n        const leftLookupResult = find_label(label, tree[1]);\n        switch (leftLookupResult.status) {\n          // if the label we're searching for is greater than the left node lookup,\n          // we need to search the right node\n          case LookupLabelStatus.Greater:\n            {\n              const rightLookupResult = find_label(label, tree[2]);\n              // if the label we're searching for is less than the right node lookup,\n              // then we can stop searching and say that the label is provably Absent\n              if (rightLookupResult.status === LookupLabelStatus.Less) {\n                return {\n                  status: LookupLabelStatus.Absent\n                };\n              }\n              // if the label we're searching for is less than or equal to the right\n              // node lookup, then we let the caller handle it\n              return rightLookupResult;\n            }\n          // if the left node returns an uncertain result, we need to search the\n          // right node\n          case LookupLabelStatus.Unknown:\n            {\n              const rightLookupResult = find_label(label, tree[2]);\n              // if the label we're searching for is less than the right node lookup,\n              // then we also need to return an uncertain result\n              if (rightLookupResult.status === LookupLabelStatus.Less) {\n                return {\n                  status: LookupLabelStatus.Unknown\n                };\n              }\n              // if the label we're searching for is less than or equal to the right\n              // node lookup, then we let the caller handle it\n              return rightLookupResult;\n            }\n          // if the label we're searching for is not greater than the left node\n          // lookup, or the result is not uncertain, we stop searching and return\n          // whatever the result of the left node lookup was, which can be either\n          // Found or Absent\n          default:\n            {\n              return leftLookupResult;\n            }\n        }\n      }\n    // if we encounter a Pruned node, we can't know for certain if the label\n    // we're searching for is present or not\n    case NodeType.Pruned:\n      return {\n        status: LookupLabelStatus.Unknown\n      };\n    // if the current node is Empty, or a Leaf, we can stop searching because\n    // we know for sure that the label we're searching for is not present\n    default:\n      return {\n        status: LookupLabelStatus.Absent\n      };\n  }\n}\n/**\n * Check if a canister ID falls within the canister ranges of a given subnet\n * @param params the parameters with which to check the canister ranges\n * @param params.canisterId the canister ID to check\n * @param params.subnetId the subnet ID from which to check the canister ranges\n * @param params.tree the hash tree in which to lookup the subnet's canister ranges\n * @returns {boolean} `true` if the canister is in the range, `false` otherwise\n */\nexport function check_canister_ranges(params) {\n  const {\n    canisterId,\n    subnetId,\n    tree\n  } = params;\n  const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n  if (rangeLookup.status !== LookupPathStatus.Found) {\n    throw ProtocolError.fromCode(new LookupErrorCode(`Could not find canister ranges for subnet ${subnetId.toText()}`, rangeLookup.status));\n  }\n  if (!(rangeLookup.value instanceof Uint8Array)) {\n    throw ProtocolError.fromCode(new MalformedLookupFoundValueErrorCode(`Could not find canister ranges for subnet ${subnetId.toText()}`));\n  }\n  const ranges_arr = cbor.decode(rangeLookup.value);\n  const ranges = ranges_arr.map(v => [Principal.fromUint8Array(v[0]), Principal.fromUint8Array(v[1])]);\n  const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n  return canisterInRange;\n}","map":{"version":3,"names":["cbor","CertificateHasTooManyDelegationsErrorCode","CertificateNotAuthorizedErrorCode","CertificateTimeErrorCode","CertificateVerificationErrorCode","DerKeyLengthMismatchErrorCode","DerPrefixMismatchErrorCode","ProtocolError","LookupErrorCode","TrustError","UnknownError","HashTreeDecodeErrorCode","UNREACHABLE_ERROR","MalformedLookupFoundValueErrorCode","MissingLookupValueErrorCode","Principal","bls","decodeTime","MANAGEMENT_CANISTER_ID","bytesToHex","concatBytes","hexToBytes","utf8ToBytes","uint8Equals","sha256","NodeType","hashTreeToString","tree","indent","s","split","map","x","join","labelToString","label","decoder","TextDecoder","undefined","fatal","JSON","stringify","decode","e","byteLength","Empty","Fork","Array","Uint8Array","left","right","fromCode","Labeled","sub","Leaf","isArray","Pruned","isBufferGreaterThan","a","b","i","length","Certificate","disableTimeVerification","create","options","cert","createUnverified","verify","certificate","rootKey","canisterId","blsVerify","maxAgeInMinutes","constructor","_rootKey","_canisterId","_blsVerify","_maxAgeInMinutes","arguments","lookup_path","path","lookup_subtree","rootHash","reconstruct","derKey","_checkDelegationAndGetKey","delegation","sig","signature","key","extractDER","msg","domain_sep","sigVer","lookupTime","lookupResultToBuffer","FIVE_MINUTES_IN_MSEC","MAX_AGE_IN_MSEC","now","Date","earliestCertificateTime","fiveMinutesFromNow","certTime","getTime","err","d","toString","canisterInRange","check_canister_ranges","subnetId","fromUint8Array","subnet_id","publicKeyLookup","DER_PREFIX","KEY_LENGTH","buf","expectedLength","prefix","slice","result","status","LookupPathStatus","Found","value","t","len","str","TextEncoder","encode","pathToLabel","LookupSubtreeStatus","LookupLabelStatus","Absent","byteOffset","Unknown","Error","lookupResult","find_label","Greater","Less","flatten_forks","concat","leftLookupResult","rightLookupResult","params","rangeLookup","toUint8Array","toText","ranges_arr","ranges","v","some","r","ltEq","gtEq"],"sources":["D:\\Kshetra\\frontend\\node_modules\\@dfinity\\agent\\src\\certificate.ts"],"sourcesContent":["import * as cbor from './cbor.ts';\nimport {\n  CertificateHasTooManyDelegationsErrorCode,\n  CertificateNotAuthorizedErrorCode,\n  CertificateTimeErrorCode,\n  CertificateVerificationErrorCode,\n  DerKeyLengthMismatchErrorCode,\n  DerPrefixMismatchErrorCode,\n  ProtocolError,\n  LookupErrorCode,\n  TrustError,\n  UnknownError,\n  HashTreeDecodeErrorCode,\n  UNREACHABLE_ERROR,\n  MalformedLookupFoundValueErrorCode,\n  MissingLookupValueErrorCode,\n} from './errors.ts';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls.ts';\nimport { decodeTime } from './utils/leb.ts';\nimport { MANAGEMENT_CANISTER_ID } from './agent/index.ts';\nimport { bytesToHex, concatBytes, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { uint8Equals } from './utils/buffer.ts';\nimport { sha256 } from '@noble/hashes/sha2';\n\nexport interface Cert {\n  tree: HashTree;\n  signature: Uint8Array;\n  delegation?: Delegation;\n}\n\nexport enum NodeType {\n  Empty = 0,\n  Fork = 1,\n  Labeled = 2,\n  Leaf = 3,\n  Pruned = 4,\n}\n\nexport type NodePath = Array<Uint8Array | string>;\nexport type NodeLabel = Uint8Array & { __nodeLabel__: void };\nexport type NodeValue = Uint8Array & { __nodeValue__: void };\nexport type NodeHash = Uint8Array & { __nodeHash__: void };\n\nexport type EmptyHashTree = [NodeType.Empty];\nexport type ForkHashTree = [NodeType.Fork, HashTree, HashTree];\nexport type LabeledHashTree = [NodeType.Labeled, NodeLabel, HashTree];\nexport type LeafHashTree = [NodeType.Leaf, NodeValue];\nexport type PrunedHashTree = [NodeType.Pruned, NodeHash];\n\nexport type HashTree =\n  | EmptyHashTree\n  | ForkHashTree\n  | LabeledHashTree\n  | LeafHashTree\n  | PrunedHashTree;\n\n/**\n * Make a human readable string out of a hash tree.\n * @param tree The hash tree to convert to a string\n */\nexport function hashTreeToString(tree: HashTree): string {\n  const indent = (s: string) =>\n    s\n      .split('\\n')\n      .map(x => '  ' + x)\n      .join('\\n');\n  function labelToString(label: Uint8Array): string {\n    const decoder = new TextDecoder(undefined, { fatal: true });\n    try {\n      return JSON.stringify(decoder.decode(label));\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n\n  switch (tree[0]) {\n    case NodeType.Empty:\n      return '()';\n    case NodeType.Fork: {\n      if (tree[1] instanceof Array && tree[2] instanceof Uint8Array) {\n        const left = hashTreeToString(tree[1]);\n        const right = hashTreeToString(tree[2]);\n        return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n      } else {\n        throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid tree structure for fork'));\n      }\n    }\n    case NodeType.Labeled: {\n      if (tree[1] instanceof Uint8Array && tree[2] instanceof Uint8Array) {\n        const label = labelToString(tree[1]);\n        const sub = hashTreeToString(tree[2]);\n        return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n      } else {\n        throw UnknownError.fromCode(\n          new HashTreeDecodeErrorCode('Invalid tree structure for labeled'),\n        );\n      }\n    }\n    case NodeType.Leaf: {\n      if (!tree[1]) {\n        throw UnknownError.fromCode(new HashTreeDecodeErrorCode('Invalid tree structure for leaf'));\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n      return `leaf(...${tree[1].byteLength} bytes)`;\n    }\n    case NodeType.Pruned: {\n      if (!tree[1]) {\n        throw UnknownError.fromCode(\n          new HashTreeDecodeErrorCode('Invalid tree structure for pruned'),\n        );\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n\n      return `pruned(${bytesToHex(new Uint8Array(tree[1]))}`;\n    }\n    default: {\n      return `unknown(${JSON.stringify(tree[0])})`;\n    }\n  }\n}\n\ninterface Delegation extends Record<string, unknown> {\n  subnet_id: Uint8Array;\n  certificate: Uint8Array;\n}\n\nfunction isBufferGreaterThan(a: Uint8Array, b: Uint8Array): boolean {\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] > b[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\ntype VerifyFunc = (pk: Uint8Array, sig: Uint8Array, msg: Uint8Array) => Promise<boolean> | boolean;\n\nexport interface CreateCertificateOptions {\n  /**\n   * The bytes encoding the certificate to be verified\n   */\n  certificate: Uint8Array;\n  /**\n   * The root key against which to verify the certificate\n   * (normally, the root key of the IC main network)\n   */\n  rootKey: Uint8Array;\n  /**\n   * The effective canister ID of the request when verifying a response, or\n   * the signing canister ID when verifying a certified variable.\n   */\n  canisterId: Principal;\n  /**\n   * BLS Verification strategy. Default strategy uses bls12_381 from @noble/curves\n   */\n  blsVerify?: VerifyFunc;\n\n  /**\n   * The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @default 5\n   * This is used to verify the time the certificate was signed, particularly for validating Delegation certificates, which can live for longer than the default window of +/- 5 minutes. If the certificate is\n   * older than the specified age, it will fail verification.\n   */\n  maxAgeInMinutes?: number;\n\n  /**\n   * Overrides the maxAgeInMinutes setting and skips comparing the client's time against the certificate. Used for scenarios where the machine's clock is known to be out of sync, or for inspecting expired certificates.\n   */\n  disableTimeVerification?: boolean;\n}\n\nexport class Certificate {\n  public cert: Cert;\n  #disableTimeVerification: boolean = false;\n\n  /**\n   * Create a new instance of a certificate, automatically verifying it.\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {Uint8Array} options.certificate The bytes of the certificate\n   * @param {Uint8Array} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws if the certificate cannot be verified\n   */\n  public static async create(options: CreateCertificateOptions): Promise<Certificate> {\n    const cert = Certificate.createUnverified(options);\n\n    await cert.verify();\n    return cert;\n  }\n\n  private static createUnverified(options: CreateCertificateOptions): Certificate {\n    return new Certificate(\n      options.certificate,\n      options.rootKey,\n      options.canisterId,\n      options.blsVerify ?? bls.blsVerify,\n      options.maxAgeInMinutes,\n      options.disableTimeVerification,\n    );\n  }\n\n  private constructor(\n    certificate: Uint8Array,\n    private _rootKey: Uint8Array,\n    private _canisterId: Principal,\n    private _blsVerify: VerifyFunc,\n    // Default to 5 minutes\n    private _maxAgeInMinutes: number = 5,\n    disableTimeVerification: boolean = false,\n  ) {\n    this.#disableTimeVerification = disableTimeVerification;\n    this.cert = cbor.decode(certificate);\n  }\n\n  /**\n   * Lookup a path in the certificate tree, using {@link lookup_path}.\n   * @param path The path to lookup.\n   * @returns The result of the lookup.\n   */\n  public lookup_path(path: NodePath): LookupResult {\n    return lookup_path(path, this.cert.tree);\n  }\n\n  /**\n   * Lookup a subtree in the certificate tree, using {@link lookup_subtree}.\n   * @param path The path to lookup.\n   * @returns The result of the lookup.\n   */\n  public lookup_subtree(path: NodePath): SubtreeLookupResult {\n    return lookup_subtree(path, this.cert.tree);\n  }\n\n  private async verify(): Promise<void> {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concatBytes(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n\n    const lookupTime = lookupResultToBuffer(this.lookup_path(['time']));\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw ProtocolError.fromCode(\n        new CertificateVerificationErrorCode('Certificate does not contain a time'),\n      );\n    }\n\n    // Certificate time verification checks\n    if (!this.#disableTimeVerification) {\n      const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n      const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n      const now = Date.now();\n      const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n      const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n\n      const certTime = decodeTime(lookupTime);\n\n      if (certTime.getTime() < earliestCertificateTime) {\n        throw TrustError.fromCode(\n          new CertificateTimeErrorCode(this._maxAgeInMinutes, certTime, new Date(now), 'past'),\n        );\n      } else if (certTime.getTime() > fiveMinutesFromNow) {\n        throw TrustError.fromCode(\n          new CertificateTimeErrorCode(5, certTime, new Date(now), 'future'),\n        );\n      }\n    }\n\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw TrustError.fromCode(\n        new CertificateVerificationErrorCode('Signature verification failed'),\n      );\n    }\n  }\n\n  private async _checkDelegationAndGetKey(d?: Delegation): Promise<Uint8Array> {\n    if (!d) {\n      return this._rootKey;\n    }\n\n    const cert = Certificate.createUnverified({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      disableTimeVerification: true,\n    });\n\n    if (cert.cert.delegation) {\n      throw ProtocolError.fromCode(new CertificateHasTooManyDelegationsErrorCode());\n    }\n\n    await cert.verify();\n\n    if (this._canisterId.toString() !== MANAGEMENT_CANISTER_ID) {\n      const canisterInRange = check_canister_ranges({\n        canisterId: this._canisterId,\n        subnetId: Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n        tree: cert.cert.tree,\n      });\n      if (!canisterInRange) {\n        throw TrustError.fromCode(\n          new CertificateNotAuthorizedErrorCode(this._canisterId, d.subnet_id),\n        );\n      }\n    }\n    const publicKeyLookup = lookupResultToBuffer(\n      cert.lookup_path(['subnet', d.subnet_id, 'public_key']),\n    );\n    if (!publicKeyLookup) {\n      throw TrustError.fromCode(\n        new MissingLookupValueErrorCode(\n          `Could not find subnet key for subnet 0x${bytesToHex(d.subnet_id)}`,\n        ),\n      );\n    }\n    return publicKeyLookup;\n  }\n}\n\nconst DER_PREFIX = hexToBytes(\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100',\n);\nconst KEY_LENGTH = 96;\n\nfunction extractDER(buf: Uint8Array): Uint8Array {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw ProtocolError.fromCode(new DerKeyLengthMismatchErrorCode(expectedLength, buf.byteLength));\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!uint8Equals(prefix, DER_PREFIX)) {\n    throw ProtocolError.fromCode(new DerPrefixMismatchErrorCode(DER_PREFIX, prefix));\n  }\n\n  return buf.slice(DER_PREFIX.byteLength);\n}\n\n/**\n * Utility function to constrain the type of a lookup result\n * @param result the result of a lookup\n * @returns {Uint8Array | undefined} the value if the lookup was found, `undefined` otherwise\n */\nexport function lookupResultToBuffer(result: LookupResult): Uint8Array | undefined {\n  if (result.status !== LookupPathStatus.Found) {\n    return undefined;\n  }\n\n  if (result.value instanceof Uint8Array) {\n    return result.value;\n  }\n\n  return undefined;\n}\n\n/**\n * @param t The hash tree to reconstruct\n */\nexport async function reconstruct(t: HashTree): Promise<Uint8Array> {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return sha256(domain_sep('ic-hashtree-empty'));\n    case NodeType.Pruned:\n      return t[1];\n    case NodeType.Leaf:\n      return sha256(concatBytes(domain_sep('ic-hashtree-leaf'), t[1]));\n    case NodeType.Labeled:\n      return sha256(concatBytes(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n    case NodeType.Fork:\n      return sha256(\n        concatBytes(\n          domain_sep('ic-hashtree-fork'),\n          await reconstruct(t[1]),\n          await reconstruct(t[2]),\n        ),\n      );\n    default:\n      throw UNREACHABLE_ERROR;\n  }\n}\n\n/**\n * Creates a domain separator for hashing by encoding the input string\n * with its length as a prefix.\n * @param s - The input string to encode.\n * @returns A Uint8Array containing the encoded domain separator.\n */\nexport function domain_sep(s: string): Uint8Array {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concatBytes(len, str);\n}\n\nfunction pathToLabel(path: NodePath): NodeLabel {\n  return (typeof path[0] === 'string' ? utf8ToBytes(path[0]) : path[0]) as NodeLabel;\n}\n\nexport enum LookupPathStatus {\n  Unknown = 'Unknown',\n  Absent = 'Absent',\n  Found = 'Found',\n  Error = 'Error',\n}\n\nexport interface LookupPathResultAbsent {\n  status: LookupPathStatus.Absent;\n}\n\nexport interface LookupPathResultUnknown {\n  status: LookupPathStatus.Unknown;\n}\n\nexport interface LookupPathResultFound {\n  status: LookupPathStatus.Found;\n  value: Uint8Array;\n}\n\nexport interface LookupPathResultError {\n  status: LookupPathStatus.Error;\n}\n\nexport type LookupResult =\n  | LookupPathResultAbsent\n  | LookupPathResultUnknown\n  | LookupPathResultFound\n  | LookupPathResultError;\n\nexport enum LookupSubtreeStatus {\n  Absent = 'Absent',\n  Unknown = 'Unknown',\n  Found = 'Found',\n}\n\nexport interface LookupSubtreeResultAbsent {\n  status: LookupSubtreeStatus.Absent;\n}\n\nexport interface LookupSubtreeResultUnknown {\n  status: LookupSubtreeStatus.Unknown;\n}\n\nexport interface LookupSubtreeResultFound {\n  status: LookupSubtreeStatus.Found;\n  value: HashTree;\n}\n\nexport type SubtreeLookupResult =\n  | LookupSubtreeResultAbsent\n  | LookupSubtreeResultUnknown\n  | LookupSubtreeResultFound;\n\nexport enum LookupLabelStatus {\n  Absent = 'Absent',\n  Unknown = 'Unknown',\n  Found = 'Found',\n  Less = 'Less',\n  Greater = 'Greater',\n}\n\nexport interface LookupLabelResultAbsent {\n  status: LookupLabelStatus.Absent;\n}\n\nexport interface LookupLabelResultUnknown {\n  status: LookupLabelStatus.Unknown;\n}\n\nexport interface LookupLabelResultFound {\n  status: LookupLabelStatus.Found;\n  value: HashTree;\n}\n\nexport interface LookupLabelResultGreater {\n  status: LookupLabelStatus.Greater;\n}\n\nexport interface LookupLabelResultLess {\n  status: LookupLabelStatus.Less;\n}\n\nexport type LabelLookupResult =\n  | LookupLabelResultAbsent\n  | LookupLabelResultUnknown\n  | LookupLabelResultFound\n  | LookupLabelResultGreater\n  | LookupLabelResultLess;\n\n/**\n * Lookup a path in a tree. If the path is a subtree, use {@link lookup_subtree} instead.\n * @param path the path to look up\n * @param tree the tree to search\n * @returns {LookupResult} the result of the lookup\n */\nexport function lookup_path(path: NodePath, tree: HashTree): LookupResult {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeType.Empty: {\n        return {\n          status: LookupPathStatus.Absent,\n        };\n      }\n\n      case NodeType.Leaf: {\n        if (!tree[1]) {\n          throw UnknownError.fromCode(\n            new HashTreeDecodeErrorCode('Invalid tree structure for leaf'),\n          );\n        }\n\n        if (tree[1] instanceof Uint8Array) {\n          return {\n            status: LookupPathStatus.Found,\n            value: tree[1].slice(tree[1].byteOffset, tree[1].byteLength + tree[1].byteOffset),\n          };\n        }\n\n        throw UNREACHABLE_ERROR;\n      }\n\n      case NodeType.Pruned: {\n        return {\n          status: LookupPathStatus.Unknown,\n        };\n      }\n\n      case NodeType.Labeled:\n      case NodeType.Fork: {\n        return {\n          status: LookupPathStatus.Error,\n        };\n      }\n\n      default: {\n        throw UNREACHABLE_ERROR;\n      }\n    }\n  }\n\n  const label = pathToLabel(path);\n  const lookupResult = find_label(label, tree);\n\n  switch (lookupResult.status) {\n    case LookupLabelStatus.Found: {\n      return lookup_path(path.slice(1), lookupResult.value);\n    }\n\n    case LookupLabelStatus.Absent:\n    case LookupLabelStatus.Greater:\n    case LookupLabelStatus.Less: {\n      return {\n        status: LookupPathStatus.Absent,\n      };\n    }\n\n    case LookupLabelStatus.Unknown: {\n      return {\n        status: LookupPathStatus.Unknown,\n      };\n    }\n\n    default: {\n      throw UNREACHABLE_ERROR;\n    }\n  }\n}\n\n/**\n * Lookup a subtree in a tree.\n * @param path the path to look up\n * @param tree the tree to search\n * @returns {SubtreeLookupResult} the result of the lookup\n */\nexport function lookup_subtree(path: NodePath, tree: HashTree): SubtreeLookupResult {\n  if (path.length === 0) {\n    return {\n      status: LookupSubtreeStatus.Found,\n      value: tree,\n    };\n  }\n\n  const label = pathToLabel(path);\n  const lookupResult = find_label(label, tree);\n\n  switch (lookupResult.status) {\n    case LookupLabelStatus.Found: {\n      return lookup_subtree(path.slice(1), lookupResult.value);\n    }\n\n    case LookupLabelStatus.Unknown: {\n      return {\n        status: LookupSubtreeStatus.Unknown,\n      };\n    }\n\n    case LookupLabelStatus.Absent:\n    case LookupLabelStatus.Greater:\n    case LookupLabelStatus.Less: {\n      return {\n        status: LookupSubtreeStatus.Absent,\n      };\n    }\n\n    default: {\n      throw UNREACHABLE_ERROR;\n    }\n  }\n}\n\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param {HashTree} t the tree to flatten\n * @returns {HashTree[]} the flattened tree\n */\nexport function flatten_forks(t: HashTree): Array<LabeledHashTree | LeafHashTree | PrunedHashTree> {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return [];\n    case NodeType.Fork:\n      return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n    default:\n      return [t];\n  }\n}\n\n/**\n * Find a label in a tree\n * @param label the label to find\n * @param tree the tree to search\n * @returns {LabelLookupResult} the result of the label lookup\n */\nexport function find_label(label: NodeLabel, tree: HashTree): LabelLookupResult {\n  switch (tree[0]) {\n    // if we have a labelled node, compare the node's label to the one we are\n    // looking for\n    case NodeType.Labeled:\n      // if the label we're searching for is greater than this node's label,\n      // we need to keep searching\n      if (isBufferGreaterThan(label, tree[1])) {\n        return {\n          status: LookupLabelStatus.Greater,\n        };\n      }\n\n      // if the label we're searching for is equal this node's label, we can\n      // stop searching and return the found node\n      if (uint8Equals(label, tree[1])) {\n        return {\n          status: LookupLabelStatus.Found,\n          value: tree[2],\n        };\n      }\n\n      // if the label we're searching for is not greater than or equal to this\n      // node's label, then it's less than this node's label, and we can stop\n      // searching because we've looked too far\n      return {\n        status: LookupLabelStatus.Less,\n      };\n\n    // if we have a fork node, we need to search both sides, starting with the left\n    case NodeType.Fork: {\n      // search in the left node\n      const leftLookupResult = find_label(label, tree[1]);\n\n      switch (leftLookupResult.status) {\n        // if the label we're searching for is greater than the left node lookup,\n        // we need to search the right node\n        case LookupLabelStatus.Greater: {\n          const rightLookupResult = find_label(label, tree[2]);\n\n          // if the label we're searching for is less than the right node lookup,\n          // then we can stop searching and say that the label is provably Absent\n          if (rightLookupResult.status === LookupLabelStatus.Less) {\n            return {\n              status: LookupLabelStatus.Absent,\n            };\n          }\n\n          // if the label we're searching for is less than or equal to the right\n          // node lookup, then we let the caller handle it\n          return rightLookupResult;\n        }\n\n        // if the left node returns an uncertain result, we need to search the\n        // right node\n        case LookupLabelStatus.Unknown: {\n          const rightLookupResult = find_label(label, tree[2]);\n\n          // if the label we're searching for is less than the right node lookup,\n          // then we also need to return an uncertain result\n          if (rightLookupResult.status === LookupLabelStatus.Less) {\n            return {\n              status: LookupLabelStatus.Unknown,\n            };\n          }\n\n          // if the label we're searching for is less than or equal to the right\n          // node lookup, then we let the caller handle it\n          return rightLookupResult;\n        }\n\n        // if the label we're searching for is not greater than the left node\n        // lookup, or the result is not uncertain, we stop searching and return\n        // whatever the result of the left node lookup was, which can be either\n        // Found or Absent\n        default: {\n          return leftLookupResult;\n        }\n      }\n    }\n\n    // if we encounter a Pruned node, we can't know for certain if the label\n    // we're searching for is present or not\n    case NodeType.Pruned:\n      return {\n        status: LookupLabelStatus.Unknown,\n      };\n\n    // if the current node is Empty, or a Leaf, we can stop searching because\n    // we know for sure that the label we're searching for is not present\n    default:\n      return {\n        status: LookupLabelStatus.Absent,\n      };\n  }\n}\n\n/**\n * Check if a canister ID falls within the canister ranges of a given subnet\n * @param params the parameters with which to check the canister ranges\n * @param params.canisterId the canister ID to check\n * @param params.subnetId the subnet ID from which to check the canister ranges\n * @param params.tree the hash tree in which to lookup the subnet's canister ranges\n * @returns {boolean} `true` if the canister is in the range, `false` otherwise\n */\nexport function check_canister_ranges(params: {\n  canisterId: Principal;\n  subnetId: Principal;\n  tree: HashTree;\n}): boolean {\n  const { canisterId, subnetId, tree } = params;\n  const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n\n  if (rangeLookup.status !== LookupPathStatus.Found) {\n    throw ProtocolError.fromCode(\n      new LookupErrorCode(\n        `Could not find canister ranges for subnet ${subnetId.toText()}`,\n        rangeLookup.status,\n      ),\n    );\n  }\n\n  if (!(rangeLookup.value instanceof Uint8Array)) {\n    throw ProtocolError.fromCode(\n      new MalformedLookupFoundValueErrorCode(\n        `Could not find canister ranges for subnet ${subnetId.toText()}`,\n      ),\n    );\n  }\n\n  const ranges_arr = cbor.decode<Array<[Uint8Array, Uint8Array]>>(rangeLookup.value);\n  const ranges: Array<[Principal, Principal]> = ranges_arr.map(v => [\n    Principal.fromUint8Array(v[0]),\n    Principal.fromUint8Array(v[1]),\n  ]);\n\n  const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n\n  return canisterInRange;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}